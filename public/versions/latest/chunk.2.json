{"core/integration/modules/hb_beamr.md":{"content":"# Module: hb_beamr\n\n## Basic Information\n- **Source File:** hb_beamr.erl\n- **Module Type:** Integration\n- **Purpose:** WASM Runtime Integration via WAMR\n\n## Purpose\nBEAMR (BEAM Runtime) provides a sophisticated wrapper around the WebAssembly Micro Runtime (WAMR) for BEAM, enabling seamless execution of WASM modules within Erlang applications. The module is specifically designed to support long-running WASM executions with easy interaction between WASM functions and Erlang processes.\n\n## Interface\n\n### Core Operations\n- `start/1, start/2` - Initialize WASM executor with binary\n- `call/3, call/4, call/5, call/6` - Execute WASM functions\n- `stop/1` - Terminate WASM executor\n- `wasm_send/2` - Send message to WASM executor\n- `serialize/1` - Save WASM state to binary\n- `deserialize/2` - Restore WASM state from binary\n\n## Dependencies\n\n### Direct Dependencies\n- erl_ddll: Dynamic driver loading\n- code: Path management\n- file: File operations\n- hb_beamr_io: Memory I/O operations\n- hb_util: Utility functions\n\n### Inverse Dependencies\n- Used by WASM-dependent modules\n- Core WASM execution provider\n- Process integration point\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Driver Integration**\n   ```erlang\n   % Driver loading with error handling\n   load_driver() ->\n       case erl_ddll:load(code:priv_dir(hb), ?MODULE) of\n           ok -> ok;\n           {error, already_loaded} -> ok;\n           {error, Error} -> {error, Error}\n       end.\n   ```\n   The module manages:\n   - Dynamic driver loading\n   - Error handling\n   - Resource cleanup\n   - State management\n\n2. **WASM Execution**\n   ```erlang\n   % WASM executor initialization\n   start(WasmBinary, Mode) when is_binary(WasmBinary) ->\n       Self = self(),\n       WASM = spawn(\n           fun() ->\n               ok = load_driver(),\n               Port = open_port({spawn, \"hb_beamr\"}, []),\n               Port ! {self(), {command, term_to_binary({init, WasmBinary, Mode})}},\n               worker(Port, Self)\n           end\n       )\n   ```\n   Provides:\n   - Asynchronous execution\n   - Process isolation\n   - Error handling\n   - Resource management\n\n3. **Function Calls**\n   ```erlang\n   % WASM function invocation\n   call(WASM, FuncRef, Args, ImportFun, StateMsg, Opts) ->\n       case is_valid_arg_list(Args) of\n           true ->\n               wasm_send(WASM,\n                   {command,\n                       term_to_binary(\n                           case is_integer(FuncRef) of\n                               true -> {indirect_call, FuncRef, Args};\n                               false -> {call, FuncRef, Args}\n                           end\n                       )\n                   }\n               ),\n               monitor_call(WASM, ImportFun, StateMsg, Opts);\n           false ->\n               {error, {invalid_args, Args}}\n       end.\n   ```\n   Features:\n   - Type validation\n   - Error handling\n   - State management\n   - Import handling\n\n### State Management\n\n1. **Worker State**\n   ```erlang\n   % Worker process state management\n   worker(Port, Listener) ->\n       receive\n           stop ->\n               port_close(Port),\n               ok;\n           {wasm_send, NewListener, Message} ->\n               Port ! {self(), Message},\n               worker(Port, NewListener);\n           WASMResult ->\n               Listener ! WASMResult,\n               worker(Port, Listener)\n       end.\n   ```\n   Manages:\n   - Port lifecycle\n   - Message routing\n   - State transitions\n   - Resource cleanup\n\n2. **Execution State**\n   ```erlang\n   % State serialization\n   serialize(WASM) when is_pid(WASM) ->\n       {ok, Size} = hb_beamr_io:size(WASM),\n       {ok, Mem} = hb_beamr_io:read(WASM, 0, Size),\n       {ok, Mem}.\n   ```\n   Handles:\n   - Memory management\n   - State persistence\n   - Error handling\n   - Resource tracking\n\n### Error Handling\n\n1. **Validation Errors**\n   ```erlang\n   % Argument validation\n   is_valid_arg_list(Args) when is_list(Args) ->\n       lists:all(fun(Arg) -> is_integer(Arg) or is_float(Arg) end, Args);\n   is_valid_arg_list(_) ->\n       false.\n   ```\n   Checks:\n   - Type safety\n   - Value constraints\n   - List structure\n   - Error propagation\n\n2. **Import Errors**\n   ```erlang\n   % Import error handling\n   catch\n       Err:Reason:Stack ->\n           stop(WASM),\n           receive\n               {error, _} -> ok\n           end,\n           {error, Err, Reason, Stack, StateMsg}\n   ```\n   Manages:\n   - Error capture\n   - Resource cleanup\n   - State recovery\n   - Error reporting\n\n## Integration Points\n\n1. **Driver System**\n   - Dynamic loading\n   - Port communication\n   - Resource management\n   - Error handling\n\n2. **Process System**\n   - Worker processes\n   - Message passing\n   - State management\n   - Resource coordination\n\n3. **Memory System**\n   - WASM memory\n   - State serialization\n   - Resource tracking\n   - Error handling\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Execution Performance**\n   ```erlang\n   % Benchmark results\n   benchmark_test() ->\n       BenchTime = 1,\n       Iterations = hb:benchmark(\n           fun() ->\n               {ok, [Result]} = call(WASM, \"fac\", [5.0]),\n               ?assertEqual(120.0, Result)\n           end,\n           BenchTime\n       )\n   ```\n   Shows:\n   - High throughput\n   - Low latency\n   - Resource efficiency\n   - Stable performance\n\n2. **Memory Management**\n   - Efficient serialization\n   - Smart state handling\n   - Resource optimization\n   - Memory safety\n\n### Security Implications\n\n1. **Process Isolation**\n   - WASM sandboxing\n   - Resource limits\n   - Error containment\n   - State protection\n\n2. **Resource Protection**\n   - Memory boundaries\n   - Port security\n   - Process isolation\n   - Error handling\n\n### Best Practices\n\n1. **WASM Integration**\n   ```erlang\n   % Recommended WASM initialization\n   init_wasm(Binary) ->\n       case start(Binary) of\n           {ok, WASM, Imports, Exports} ->\n               setup_imports(WASM, Imports),\n               {ok, WASM, Exports};\n           Error ->\n               Error\n       end.\n   ```\n\n2. **Function Calls**\n   ```erlang\n   % Recommended function call pattern\n   call_wasm(WASM, Func, Args) ->\n       case call(WASM, Func, Args) of\n           {ok, Result} ->\n               process_result(Result);\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n3. **State Management**\n   ```erlang\n   % Recommended state handling\n   manage_state(WASM) ->\n       {ok, State} = serialize(WASM),\n       store_state(State),\n       {ok, State}.\n   ```\n\n### Example Usage\n\n```erlang\n% Initialize WASM module\n{ok, File} = file:read_file(\"module.wasm\"),\n{ok, WASM, Imports, Exports} = hb_beamr:start(File),\n\n% Call WASM function\n{ok, [Result]} = hb_beamr:call(WASM, \"calculate\", [5.0]),\n\n% Handle imports\n{ok, [Result], State} = hb_beamr:call(WASM, \"process\", [Input],\n    fun(State, #{args := Args}) ->\n        {ok, process_args(Args), State}\n    end),\n\n% Save state\n{ok, State} = hb_beamr:serialize(WASM),\n\n% Restore state\nok = hb_beamr:deserialize(WASM, State),\n\n% Cleanup\nok = hb_beamr:stop(WASM)\n```\n\n## WASM Integration Flow\n\n```mermaid\ngraph TD\n    A[WASM Binary] -->|Load| B[BEAMR Driver]\n    B -->|Initialize| C[WASM Instance]\n    C -->|Execute| D[WASM Function]\n    \n    D -->|Import| E[Erlang Function]\n    E -->|Return| D\n    \n    D -->|Result| F[Erlang Process]\n    \n    subgraph \"State Management\"\n        G[Serialize]\n        H[Deserialize]\n    end\n    \n    C --> G\n    H --> C\n```\n\n## Function Call Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant BEAMR as BEAMR\n    participant WASM as WASM Instance\n    participant Import as Import Handler\n\n    App->>BEAMR: call(Function, Args)\n    BEAMR->>WASM: Execute Function\n    \n    alt Import Required\n        WASM->>Import: Call Import\n        Import->>WASM: Return Result\n    end\n    \n    WASM->>BEAMR: Return Result\n    BEAMR->>App: {ok, Result}\n"},"core/integration/modules/hb_structured_fields.md":{"content":"# Module: hb_structured_fields\n\n## Basic Information\n- **Source File:** hb_structured_fields.erl\n- **Module Type:** Integration\n- **Purpose:** HTTP Structured Fields Parser/Formatter (RFC-9651)\n\n## Purpose\nProvides a comprehensive implementation of RFC-9651 for parsing and converting between Erlang terms and HTTP Structured Fields. The module handles complex data structures like lists, dictionaries, and items with parameters while ensuring strict compliance with the specification.\n\n## Interface\n\n### Core Operations\n- `parse_dictionary/1` - Parse structured dictionary\n- `parse_item/1` - Parse structured item\n- `parse_list/1` - Parse structured list\n- `parse_bare_item/1` - Parse bare item\n- `dictionary/1` - Format dictionary to string\n- `item/1` - Format item to string\n- `list/1` - Format list to string\n- `to_dictionary/1` - Convert to dictionary\n- `to_list/1` - Convert to list\n- `to_item/1, to_item/2` - Convert to item\n\n## Dependencies\n\n### Direct Dependencies\n- binary: Binary manipulation\n- base64: Binary encoding\n- jsx: JSON parsing (tests)\n- eunit: Testing framework\n\n### Inverse Dependencies\n- Used by HTTP protocol modules\n- Data structure conversion\n- Protocol integration\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Type Mapping**\n   ```erlang\n   % Type definitions\n   -type sh_list() :: [sh_item() | sh_inner_list()].\n   -type sh_inner_list() :: {list, [sh_item()], sh_params()}.\n   -type sh_params() :: [{binary(), sh_bare_item()}].\n   -type sh_dictionary() :: [{binary(), sh_item() | sh_inner_list()}].\n   -type sh_item() :: {item, sh_bare_item(), sh_params()}.\n   -type sh_bare_item() ::\n       integer()\n       | sh_decimal()\n       | boolean()\n       | {string | token | binary, binary()}.\n   ```\n   Comprehensive type system:\n   - Lists and inner lists\n   - Dictionaries\n   - Items with parameters\n   - Bare items\n\n2. **Parsing System**\n   ```erlang\n   % Dictionary parsing\n   parse_dictionary(<<>>) ->\n       [];\n   parse_dictionary(<<C, R/bits>>) when ?IS_ALPHA(C)\n           or ?IS_DIGIT(C) or (C =:= $*) or (C =:= $%) or (C =:= $_) or (C =:= $-) ->\n       parse_dict_key(R, [], <<C>>).\n   ```\n   Features:\n   - Character-level parsing\n   - State management\n   - Error handling\n   - Type validation\n\n3. **Formatting System**\n   ```erlang\n   % Dictionary formatting\n   dictionary(Map) when is_map(Map) ->\n       dictionary(maps:to_list(Map));\n   dictionary(KVList) when is_list(KVList) ->\n       lists:join(\n           <<\", \">>,\n           [\n               case Value of\n                   true -> Key;\n                   _ -> [Key, $=, item_or_inner_list(Value)]\n               end\n           ||\n               {Key, Value} <- KVList\n           ]\n       ).\n   ```\n   Provides:\n   - Clean formatting\n   - Type conversion\n   - Error handling\n   - Standard compliance\n\n### State Management\n\n1. **Parser State**\n   ```erlang\n   % Parser state management\n   parse_dict_key(<<$=, $(, R0/bits>>, Acc, K) ->\n       {Item, R} = parse_inner_list(R0, []),\n       parse_dict_before_sep(R, lists:keystore(K, 1, Acc, {K, Item}));\n   parse_dict_key(<<$=, R0/bits>>, Acc, K) ->\n       {Item, R} = parse_item1(R0),\n       parse_dict_before_sep(R, lists:keystore(K, 1, Acc, {K, Item})).\n   ```\n   Handles:\n   - Parsing state\n   - Accumulator management\n   - Error recovery\n   - Type tracking\n\n2. **Formatter State**\n   ```erlang\n   % Formatter state management\n   to_dictionary(Dict, []) ->\n       {ok, Dict};\n   to_dictionary(_Dict, [{ Name, Value } | _Rest]) when is_map(Value) ->\n       {too_deep, Name};\n   to_dictionary(Dict, [{Name, Value} | Rest]) ->\n       case to_item_or_inner_list(Value) of\n           {ok, ItemOrInner} -> \n               to_dictionary([{key_to_binary(Name), ItemOrInner} | Dict], Rest);\n           E -> E\n       end.\n   ```\n   Manages:\n   - Conversion state\n   - Error handling\n   - Type validation\n   - Resource tracking\n\n### Error Handling\n\n1. **Parser Errors**\n   ```erlang\n   % Parser error handling\n   parse_number(R, L, Acc) when L =< 15 ->\n       {binary_to_integer(Acc), R}.\n   ```\n   Ensures:\n   - Length validation\n   - Type checking\n   - Error propagation\n   - Clean recovery\n\n2. **Formatter Errors**\n   ```erlang\n   % Formatter error handling\n   to_dictionary(_Dict, [{ Name, Value } | _Rest]) when is_map(Value) ->\n       {too_deep, Name};\n   ```\n   Handles:\n   - Type errors\n   - Depth limits\n   - Invalid values\n   - Error reporting\n\n## Integration Points\n\n1. **HTTP System**\n   - Header parsing\n   - Value formatting\n   - Type conversion\n   - Error handling\n\n2. **Protocol System**\n   - Data structures\n   - Type mapping\n   - Value validation\n   - Error handling\n\n3. **Testing System**\n   - Comprehensive tests\n   - Edge cases\n   - Error conditions\n   - Standard compliance\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Parsing Performance**\n   ```erlang\n   % Efficient parsing\n   parse_string(<<$\\\\, $\", R/bits>>, Acc) ->\n       parse_string(R, <<Acc/binary, $\">>);\n   parse_string(<<$\\\\, $\\\\, R/bits>>, Acc) ->\n       parse_string(R, <<Acc/binary, $\\\\>>).\n   ```\n   Features:\n   - Binary matching\n   - Efficient accumulation\n   - State management\n   - Memory usage\n\n2. **Formatting Performance**\n   ```erlang\n   % Efficient formatting\n   bare_item({string, String}) ->\n       [$\", escape_string(String, <<>>), $\"];\n   bare_item({token, Token}) ->\n       Token.\n   ```\n   Optimizations:\n   - Direct conversion\n   - Minimal copying\n   - Memory efficiency\n   - Type safety\n\n### Security Implications\n\n1. **Input Validation**\n   - Length checks\n   - Type validation\n   - Character sets\n   - Error handling\n\n2. **Resource Protection**\n   - Memory limits\n   - Stack safety\n   - Error containment\n   - State protection\n\n### Best Practices\n\n1. **Parsing**\n   ```erlang\n   % Recommended parsing pattern\n   parse_value(Input) ->\n       case parse_item(Input) of\n           {item, Value, Params} ->\n               process_value(Value, Params);\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n2. **Formatting**\n   ```erlang\n   % Recommended formatting pattern\n   format_value(Value) ->\n       case to_item(Value) of\n           {ok, Item} ->\n               iolist_to_binary(item(Item));\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n3. **Integration**\n   ```erlang\n   % Recommended integration pattern\n   handle_header(Name, Value) ->\n       case parse_dictionary(Value) of\n           Dict when is_list(Dict) ->\n               process_dictionary(Name, Dict);\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n### Example Usage\n\n```erlang\n% Parse dictionary header\nDict = hb_structured_fields:parse_dictionary(<<\"key=value, other=123\">>),\n\n% Parse list header\nList = hb_structured_fields:parse_list(<<\"value1, value2, (inner1 inner2)\">>),\n\n% Parse item header\nItem = hb_structured_fields:parse_item(<<\"value;param=123\">>),\n\n% Format dictionary\nFormatted = hb_structured_fields:dictionary([\n    {<<\"key\">>, {item, {string, <<\"value\">>}, []}},\n    {<<\"other\">>, {item, 123, []}}\n]),\n\n% Convert Erlang terms\n{ok, Dict} = hb_structured_fields:to_dictionary(#{\n    key => \"value\",\n    other => 123,\n    list => [\"a\", \"b\", \"c\"]\n})\n```\n\n## Parsing Flow\n\n```mermaid\ngraph TD\n    A[Input String] -->|Parse| B{Type Check}\n    B -->|Dictionary| C[Parse Dictionary]\n    B -->|List| D[Parse List]\n    B -->|Item| E[Parse Item]\n    \n    C -->|Key-Value| F[Parse Items]\n    D -->|Members| F\n    E -->|Value| G[Parse Bare Item]\n    \n    F --> G\n    G --> H[Result]\n```\n\n## Formatting Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant SF as Structured Fields\n    participant Conv as Converter\n    participant Fmt as Formatter\n\n    App->>SF: Format Value\n    SF->>Conv: Convert Type\n    Conv->>Fmt: Format Parts\n    \n    alt Dictionary\n        Fmt->>Fmt: Format Key-Value\n    else List\n        Fmt->>Fmt: Format Members\n    else Item\n        Fmt->>Fmt: Format Value+Params\n    end\n    \n    Fmt-->>App: Formatted String\n"},"core/integration/observations.md":{"content":"# Integration Module Observations\n\n## Architectural Patterns\n\n### 1. External System Integration\nThe integration modules demonstrate sophisticated patterns for interfacing with external systems:\n\n1. **WASM Integration (hb_beamr)**\n   - Clean abstraction over WAMR\n   - Process isolation\n   - Resource management\n   - Error handling\n\n2. **Memory Management (hb_beamr_io)**\n   - Safe memory operations\n   - Resource tracking\n   - Type safety\n   - Error handling\n\n3. **Protocol Integration (hb_structured_fields)**\n   - RFC-9651 compliance\n   - Type mapping\n   - Parsing/formatting\n   - Error handling\n\n### 2. Component Separation\nClear separation of concerns across integration components:\n\n1. **Runtime Integration**\n   - WASM execution\n   - Memory management\n   - Resource control\n   - State tracking\n\n2. **Protocol Integration**\n   - Data structures\n   - Type conversion\n   - Validation\n   - Error handling\n\n3. **Resource Management**\n   - Memory allocation\n   - Process lifecycle\n   - State management\n   - Cleanup operations\n\n## Implementation Patterns\n\n### 1. Error Handling\nSophisticated error handling strategies:\n\n```erlang\n% Defensive error handling in hb_structured_fields\nparse_number(R, L, Acc) when L =< 15 ->\n    {binary_to_integer(Acc), R}.\n\n% Resource cleanup in hb_beamr\ncatch\n    Err:Reason:Stack ->\n        stop(WASM),\n        receive {error, _} -> ok end,\n        {error, Err, Reason, Stack, StateMsg}\n```\n\nKey aspects:\n- Early validation\n- Resource cleanup\n- Error propagation\n- State recovery\n\n### 2. Type Safety\nStrong type safety mechanisms:\n\n```erlang\n% Type validation in hb_structured_fields\n-type sh_bare_item() ::\n    integer()\n    | sh_decimal()\n    | boolean()\n    | {string | token | binary, binary()}.\n\n% Memory validation in hb_beamr_io\nwrite(WASM, Offset, Data)\n    when is_pid(WASM)\n    andalso is_binary(Data)\n    andalso is_integer(Offset)\n```\n\nFeatures:\n- Type definitions\n- Runtime checks\n- Validation guards\n- Error prevention\n\n### 3. Resource Management\nCareful resource handling:\n\n```erlang\n% Memory management in hb_beamr_io\nmalloc(WASM, Size) when is_pid(WASM) andalso is_integer(Size) ->\n    case hb_beamr:call(WASM, \"malloc\", [Size]) of\n        {ok, [0]} -> {error, malloc_failed};\n        {ok, [Ptr]} -> {ok, Ptr};\n        {error, Error} -> {error, Error}\n    end.\n```\n\nPatterns:\n- Resource allocation\n- State tracking\n- Error handling\n- Cleanup operations\n\n## Integration Insights\n\n### 1. WASM Integration\nThe WASM integration demonstrates several key patterns:\n\n1. **Process Isolation**\n   - Separate processes\n   - Message passing\n   - Resource isolation\n   - Error containment\n\n2. **Memory Safety**\n   - Bounds checking\n   - Type validation\n   - Resource tracking\n   - Cleanup operations\n\n3. **Error Handling**\n   - Early validation\n   - Resource cleanup\n   - Error propagation\n   - State recovery\n\n### 2. Protocol Integration\nThe structured fields implementation shows:\n\n1. **Type Mapping**\n   - Clear mappings\n   - Validation rules\n   - Error handling\n   - Standard compliance\n\n2. **Parsing Strategy**\n   - Character-level parsing\n   - State management\n   - Error handling\n   - Type validation\n\n3. **Formatting Strategy**\n   - Clean output\n   - Type conversion\n   - Error handling\n   - Standard compliance\n\n## Common Themes\n\n### 1. Safety First\nAll modules prioritize safety:\n\n1. **Type Safety**\n   - Strong typing\n   - Runtime checks\n   - Validation guards\n   - Error prevention\n\n2. **Resource Safety**\n   - Careful allocation\n   - Proper cleanup\n   - State tracking\n   - Error handling\n\n3. **Error Safety**\n   - Early validation\n   - Clean recovery\n   - Resource cleanup\n   - State protection\n\n### 2. Performance Considerations\nPerformance optimizations across modules:\n\n1. **Memory Operations**\n   - Efficient allocation\n   - Smart cleanup\n   - Resource reuse\n   - State caching\n\n2. **Parsing Operations**\n   - Binary matching\n   - State management\n   - Efficient accumulation\n   - Resource usage\n\n3. **Type Conversions**\n   - Direct mapping\n   - Minimal copying\n   - State tracking\n   - Resource efficiency\n\n### 3. Integration Patterns\nCommon integration approaches:\n\n1. **External Systems**\n   - Clean abstraction\n   - Resource isolation\n   - Error handling\n   - State management\n\n2. **Protocol Handling**\n   - Standard compliance\n   - Type mapping\n   - Validation rules\n   - Error handling\n\n3. **Resource Management**\n   - Allocation tracking\n   - State management\n   - Cleanup operations\n   - Error handling\n\n## Areas for Improvement\n\n### 1. Error Handling\nPotential improvements in error handling:\n\n1. **Error Types**\n   - More specific errors\n   - Better context\n   - Recovery hints\n   - State information\n\n2. **Recovery Strategies**\n   - Better cleanup\n   - State recovery\n   - Resource handling\n   - Error prevention\n\n### 2. Documentation\nDocumentation could be enhanced:\n\n1. **API Documentation**\n   - More examples\n   - Edge cases\n   - Error scenarios\n   - Best practices\n\n2. **Integration Guides**\n   - Setup guides\n   - Usage patterns\n   - Error handling\n   - Performance tips\n\n### 3. Testing\nTesting could be expanded:\n\n1. **Test Coverage**\n   - Edge cases\n   - Error scenarios\n   - Performance tests\n   - Integration tests\n\n2. **Test Tools**\n   - Better helpers\n   - Test utilities\n   - Coverage tools\n   - Performance tests\n\n## Future Considerations\n\n### 1. Feature Expansion\nPotential areas for expansion:\n\n1. **WASM Integration**\n   - More features\n   - Better tooling\n   - Performance improvements\n   - Resource optimization\n\n2. **Protocol Support**\n   - New standards\n   - Better parsing\n   - More formats\n   - Better validation\n\n### 2. Performance Optimization\nAreas for optimization:\n\n1. **Memory Usage**\n   - Better allocation\n   - Smarter cleanup\n   - Resource pooling\n   - State caching\n\n2. **Processing Speed**\n   - Faster parsing\n   - Better formatting\n   - Resource reuse\n   - State management\n\n### 3. Integration Enhancement\nWays to enhance integration:\n\n1. **External Systems**\n   - More systems\n   - Better abstraction\n   - Cleaner interfaces\n   - Better tooling\n\n2. **Protocol Support**\n   - More protocols\n   - Better handling\n   - Cleaner interfaces\n   - Better validation\n"},"core/integration/OVERVIEW.md":{"content":"# Integration System Overview\n\n## System Architecture\n\nThe Integration system provides a sophisticated layer for interfacing with external systems and protocols. It consists of three key components that work together to enable seamless integration:\n\n### 1. WASM Runtime Integration (hb_beamr)\nThe BEAMR (BEAM Runtime) module serves as the primary interface for WebAssembly execution:\n\n```erlang\n% Core WASM execution interface\nstart(WasmBinary) ->\n    WASM = spawn(fun() ->\n        ok = load_driver(),\n        Port = open_port({spawn, \"hb_beamr\"}, []),\n        Port ! {self(), {command, term_to_binary({init, WasmBinary, Mode})}},\n        worker(Port, Self)\n    end).\n```\n\nThis provides:\n- Asynchronous WASM execution\n- Process isolation for safety\n- Resource management\n- Error handling\n- State tracking\n\nThe module enables:\n1. **Long-running WASM executions**\n   - Process supervision\n   - Resource management\n   - State persistence\n   - Error recovery\n\n2. **Erlang Integration**\n   - Function calls\n   - Message passing\n   - Resource sharing\n   - Error propagation\n\n### 2. Memory Management (hb_beamr_io)\nThe BEAMR I/O module handles all memory operations for WASM instances:\n\n```erlang\n% Memory management interface\nwrite_string(WASM, Data) when is_pid(WASM) andalso is_binary(Data) ->\n    DataSize = byte_size(Data) + 1,\n    String = <<Data/bitstring, 0:8>>,\n    case malloc(WASM, DataSize) of\n        {ok, Ptr} ->\n            case write(WASM, Ptr, String) of\n                ok -> {ok, Ptr};\n                {error, Error} -> {error, Error}\n            end;\n        Error -> Error\n    end.\n```\n\nThis enables:\n1. **Safe Memory Operations**\n   - Bounds checking\n   - Type validation\n   - Resource tracking\n   - Error handling\n\n2. **Resource Management**\n   - Memory allocation\n   - Resource cleanup\n   - State tracking\n   - Error recovery\n\n### 3. Protocol Integration (hb_structured_fields)\nThe Structured Fields module implements RFC-9651 for HTTP header handling:\n\n```erlang\n% Type system for structured fields\n-type sh_list() :: [sh_item() | sh_inner_list()].\n-type sh_inner_list() :: {list, [sh_item()], sh_params()}.\n-type sh_params() :: [{binary(), sh_bare_item()}].\n-type sh_dictionary() :: [{binary(), sh_item() | sh_inner_list()}].\n```\n\nThis provides:\n1. **Type Mapping**\n   - Clear type definitions\n   - Validation rules\n   - Error handling\n   - Standard compliance\n\n2. **Data Processing**\n   - Parsing operations\n   - Formatting operations\n   - Type conversion\n   - Error handling\n\n## System Integration\n\n### 1. Component Interaction\nThe components work together in a layered architecture:\n\n```mermaid\ngraph TD\n    A[Application] -->|Execute| B[BEAMR]\n    B -->|Memory Ops| C[BEAMR IO]\n    B -->|Protocol| D[Structured Fields]\n    \n    subgraph \"Memory Management\"\n        C -->|Allocate| E[WASM Memory]\n        C -->|Read/Write| E\n    end\n    \n    subgraph \"Protocol Handling\"\n        D -->|Parse| F[HTTP Headers]\n        D -->|Format| F\n    end\n```\n\nThis enables:\n1. **Clean Abstraction**\n   - Clear interfaces\n   - Resource isolation\n   - Error handling\n   - State management\n\n2. **Resource Coordination**\n   - Memory sharing\n   - Process communication\n   - State synchronization\n   - Error propagation\n\n### 2. Data Flow\nThe system manages complex data flows:\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant WASM as BEAMR\n    participant Mem as Memory\n    participant Proto as Protocol\n\n    App->>WASM: Execute WASM\n    WASM->>Mem: Allocate Memory\n    WASM->>Mem: Write Data\n    \n    loop Execution\n        WASM->>Mem: Read/Write\n        WASM->>Proto: Parse/Format\n        WASM->>App: Return Results\n    end\n    \n    WASM->>Mem: Cleanup\n```\n\nThis provides:\n1. **Data Management**\n   - Memory operations\n   - Protocol handling\n   - Resource tracking\n   - Error handling\n\n2. **State Management**\n   - Process state\n   - Memory state\n   - Protocol state\n   - Error state\n\n## Core Functionality\n\n### 1. WASM Execution\nThe system provides robust WASM execution:\n\n1. **Process Management**\n   ```erlang\n   % Process supervision\n   worker(Port, Listener) ->\n       receive\n           stop ->\n               port_close(Port),\n               ok;\n           {wasm_send, NewListener, Message} ->\n               Port ! {self(), Message},\n               worker(Port, NewListener)\n       end.\n   ```\n\n   Features:\n   - Process isolation\n   - Message passing\n   - Resource management\n   - Error handling\n\n2. **Memory Operations**\n   ```erlang\n   % Memory management\n   malloc(WASM, Size) ->\n       case hb_beamr:call(WASM, \"malloc\", [Size]) of\n           {ok, [Ptr]} -> {ok, Ptr};\n           {error, Error} -> {error, Error}\n       end.\n   ```\n\n   Provides:\n   - Safe allocation\n   - Resource tracking\n   - Error handling\n   - State management\n\n### 2. Protocol Handling\nThe system implements sophisticated protocol handling:\n\n1. **Type System**\n   ```erlang\n   % Protocol type mapping\n   to_dictionary(Map) when is_map(Map) ->\n       to_dictionary(maps:to_list(Map));\n   to_dictionary(Pairs) when is_list(Pairs) ->\n       to_dictionary([], Pairs).\n   ```\n\n   Features:\n   - Clear mappings\n   - Type validation\n   - Error handling\n   - Standard compliance\n\n2. **Data Processing**\n   ```erlang\n   % Data formatting\n   bare_item({string, String}) ->\n       [$\", escape_string(String, <<>>), $\"];\n   bare_item({token, Token}) ->\n       Token.\n   ```\n\n   Provides:\n   - Clean formatting\n   - Type conversion\n   - Error handling\n   - Standard compliance\n\n## System Capabilities\n\n### 1. Integration Support\nThe system enables various integration scenarios:\n\n1. **WASM Integration**\n   - Long-running executions\n   - Resource management\n   - State persistence\n   - Error handling\n\n2. **Protocol Integration**\n   - Standard compliance\n   - Type conversion\n   - Data validation\n   - Error handling\n\n### 2. Resource Management\nComprehensive resource handling:\n\n1. **Memory Management**\n   - Safe allocation\n   - Resource tracking\n   - State management\n   - Error handling\n\n2. **Process Management**\n   - Process isolation\n   - Message passing\n   - State tracking\n   - Error handling\n\n## Best Practices\n\n### 1. Error Handling\nRobust error handling strategies:\n\n```erlang\n% Recommended error handling\nhandle_operation(Input) ->\n    try\n        case validate_input(Input) of\n            ok -> perform_operation(Input);\n            {error, Reason} -> handle_error(Reason)\n        end\n    catch\n        Error:Reason:Stack ->\n            cleanup_resources(),\n            {error, {Error, Reason, Stack}}\n    end.\n```\n\n### 2. Resource Management\nSafe resource management patterns:\n\n```erlang\n% Recommended resource handling\nmanage_resources(Resources) ->\n    try\n        allocate_resources(Resources),\n        use_resources(Resources)\n    after\n        cleanup_resources(Resources)\n    end.\n```\n\n### 3. Integration Patterns\nClean integration approaches:\n\n```erlang\n% Recommended integration pattern\nintegrate_system(System) ->\n    case initialize_system(System) of\n        {ok, Handle} ->\n            setup_resources(Handle),\n            monitor_system(Handle);\n        Error ->\n            handle_error(Error)\n    end.\n```\n\n## Future Directions\n\n### 1. System Enhancement\nPotential improvements:\n\n1. **WASM Integration**\n   - More features\n   - Better tooling\n   - Performance optimization\n   - Resource management\n\n2. **Protocol Support**\n   - New standards\n   - Better parsing\n   - More formats\n   - Better validation\n\n### 2. Performance Optimization\nAreas for optimization:\n\n1. **Memory Usage**\n   - Better allocation\n   - Smarter cleanup\n   - Resource pooling\n   - State caching\n\n2. **Processing Speed**\n   - Faster parsing\n   - Better formatting\n   - Resource reuse\n   - State management\n"},"core/message_protocol/modules/hb_ao.md":{"content":"# Module: hb_ao\n\n## Basic Information\n- **Source File:** hb_ao.erl\n- **Module Type:** Core Message Protocol\n- **Behavior:** None\n\n## Purpose\nRoot module for the AO-Core protocol's device call logic in HyperBEAM. Implements message resolution through devices, where each message is a collection of keys that can be resolved to yield values.\n\n## Interface\n\n### Core Protocol Functions\n- `resolve/2,3` - Resolve a message's key using its device\n- `resolve_many/2` - Resolve a sequence of messages\n- `message_to_fun/3` - Convert message to executable function\n- `message_to_device/2` - Extract device module from message\n- `load_device/2` - Load device module from name/ID\n\n### Key Management\n- `normalize_key/1,2` - Convert key to normalized binary form\n- `normalize_keys/1` - Ensure message is processable\n- `keys/1,2,3` - Get list of keys from message\n\n### Message Operations\n- `get/2,3,4` - Get key value without status\n- `get_first/2,3` - Get first resolvable value\n- `set/2,3,4` - Set key in message using device\n- `remove/2,3` - Remove key from message\n- `info/2` - Get device info map\n\n## Dependencies\n\n### Direct Dependencies\n- hb_message: Message handling\n- hb_path: Path manipulation\n- hb_util: Utility functions\n- hb_opts: Options handling\n- hb_cache: Message caching\n- dev_message: Default device\n\n### Inverse Dependencies\n- Used by all modules needing message resolution\n- Core component for device interaction\n- Essential for protocol operation\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Message Resolution Process**\n   ```\n   ao(Message1, Message2) -> {Status, Message3}\n   ```\n   - Message1: Base message\n   - Message2: Operation to perform\n   - Message3: Result or raw value\n\n2. **Resolution Stages**\n   1. Normalization\n   2. Cache lookup\n   3. Validation check\n   4. Persistent-resolver lookup\n   5. Device lookup\n   6. Execution\n   7. Cryptographic linking\n   8. Result caching\n   9. Notify waiters\n   10. Fork worker\n   11. Recurse or terminate\n\n3. **Device Implementation**\n   ```erlang\n   DevMod:ExportedFunc(Msg1, Msg2, Opts) -> {Status, Result}\n   DevMod:info() -> #{options}\n   ```\n   - ExportedFunc: Key resolution functions\n   - info: Optional device configuration\n   - Options control device behavior\n\n### State Management\n\n1. **Device State**\n   - Devices can be modules or maps\n   - State maintained by individual devices\n   - Persistent resolvers track execution\n\n2. **Execution State**\n   - Tracked through HashPaths\n   - Maintained in message history\n   - Cached for performance\n\n3. **Resolution State**\n   - Managed by resolver stages\n   - Tracked for concurrent executions\n   - Preserved across recursion\n\n### Error Handling\n\n1. **Device Errors**\n   - Invalid message format\n   - Device not loadable\n   - Key not resolvable\n   - Infinite recursion\n\n2. **Resolution Errors**\n   - Cache misses\n   - Validation failures\n   - Execution failures\n   - State inconsistencies\n\n## Integration Points\n\n1. **Device System**\n   - Device loading mechanism\n   - Function resolution\n   - Key normalization\n   - State management\n\n2. **Cache System**\n   - Result caching\n   - Message loading\n   - State persistence\n   - Performance optimization\n\n3. **Protocol System**\n   - Message resolution\n   - Device interaction\n   - Key management\n   - Error handling\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Resolution Optimization**\n   - Caches resolved values\n   - Minimizes device reloading\n   - Optimizes key normalization\n   - Manages execution state\n\n2. **Concurrency Management**\n   - Persistent resolvers\n   - Worker processes\n   - State synchronization\n   - Resource sharing\n\n### Security Implications\n\n1. **Device Loading**\n   - Verifies device compatibility\n   - Validates trusted signers\n   - Checks system requirements\n   - Controls remote loading\n\n2. **Message Validation**\n   - Verifies message integrity\n   - Validates device operations\n   - Manages execution context\n   - Controls state access\n\n### Best Practices\n\n1. **Device Implementation**\n   - Use info/0 for configuration\n   - Implement key handlers\n   - Handle state properly\n   - Manage resources\n\n2. **Message Resolution**\n   - Check cache first\n   - Validate inputs\n   - Handle errors gracefully\n   - Maintain state consistency\n"},"core/message_protocol/modules/hb_message.md":{"content":"# Module: hb_message\n\n## Basic Information\n- **Source File:** hb_message.erl\n- **Module Type:** Core Message Protocol\n- **Behavior:** None\n\n## Purpose\nActs as an adapter between messages in the AO-Core protocol and their underlying binary representations and formats. Converts between different message formats using a common intermediate format called Type Annotated Binary Messages (TABM).\n\n## Supported Message Formats\n1. Richly typed AO-Core structured messages\n2. Arweave transactions\n3. ANS-104 data items\n4. HTTP Signed Messages\n5. Flat Maps\n\n## Interface\n\n### Public Functions\n\n#### Message Conversion\n- `convert/3(Msg, TargetFormat, Opts)` - Convert message to target format\n- `convert/4(Msg, TargetFormat, SourceFormat, Opts)` - Convert from source to target format\n\n#### Message Identification\n- `id/1(Msg)` - Get message ID\n- `id/2(Msg, Committers)` - Get ID with specific committers\n- `id/3(Msg, Committers, Opts)` - Get ID with committers and options\n\n#### Message Verification\n- `verify/1(Msg)` - Verify message signatures\n- `verify/2(Msg, Committers)` - Verify specific committers' signatures\n\n#### Message Commitment\n- `commit/2(Msg, WalletOrOpts)` - Sign message with wallet\n- `commit/3(Msg, Wallet, Format)` - Sign message in specific format\n- `committed/1,2,3` - Get committed keys from message\n\n#### Message Manipulation\n- `with_only_committed/1,2` - Filter to only committed keys\n- `with_only_committers/2` - Filter to specific committers\n- `uncommitted/1` - Get unsigned version\n- `minimize/1` - Remove regeneratable keys\n\n## Dependencies\n\n### Direct Dependencies\n- hb_ao: Core protocol operations\n- hb_util: Utility functions\n- hb_crypto: Cryptographic operations\n- hb_path: Path handling\n- dev_message: Device interface for message formats\n\n### Inverse Dependencies\n- Used by most modules that need to handle messages\n- Core component for message processing\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Type Annotated Binary Messages (TABM)**\n   - Common intermediate format\n   - Deep Erlang maps\n   - Keys contain only TABMs or binary values\n   - O(1) access for efficiency\n\n2. **Conversion Flow**\n```\nArweave TX/ANS-104 ==> dev_codec_ans104:from/1 ==> TABM\nHTTP Signed Message ==> dev_codec_httpsig_conv:from/1 ==> TABM\nFlat Maps ==> dev_codec_flat:from/1 ==> TABM\n\nTABM ==> dev_codec_structured:to/1 ==> AO-Core Message\nAO-Core Message ==> dev_codec_structured:from/1 ==> TABM\n\nTABM ==> dev_codec_ans104:to/1 ==> Arweave TX/ANS-104\nTABM ==> dev_codec_httpsig_conv:to/1 ==> HTTP Signed Message\nTABM ==> dev_codec_flat:to/1 ==> Flat Maps\n```\n\n3. **Message Signing**\n   - Supports multiple signature formats\n   - Handles nested signed messages\n   - Preserves signature verification across conversions\n\n### State Management\n- Stateless module\n- Uses TABM as intermediate state during conversions\n- Preserves private data across conversions\n\n### Error Handling\n- Throws errors for invalid message formats\n- Validates signatures during verification\n- Preserves error information across conversions\n\n## Integration Points\n\n1. **Message Codecs**\n   - Pluggable codec system\n   - Each format has dedicated codec module\n   - Codecs handle format-specific details\n\n2. **Cache Integration**\n   - Works with hb_cache for storage\n   - Uses TABM as storage format\n   - Handles cache control headers\n\n3. **Protocol Integration**\n   - Core part of AO-Core protocol\n   - Handles message normalization\n   - Manages protocol versioning\n\n## Analysis Insights\n\n### Performance Considerations\n1. Uses O(1) access maps for efficiency\n2. Minimizes data duplication\n3. Lazy verification of signatures\n4. Efficient handling of large messages\n\n### Security Implications\n1. Preserves signatures across conversions\n2. Handles multiple signature formats\n3. Supports nested signed messages\n4. Maintains signature verification integrity\n\n### Best Practices\n1. Use TABM for internal processing\n2. Verify signatures before processing\n3. Handle private data carefully\n4. Use appropriate codec for each format\n"},"core/message_protocol/modules/hb_path.md":{"content":"# Module: hb_path\n\n## Basic Information\n- **Source File:** hb_path.erl\n- **Module Type:** Core Message Protocol\n- **Behavior:** None\n\n## Purpose\nProvides utilities for manipulating two types of paths in messages:\n1. Request Path (referred to as just 'Path')\n2. HashPath - a rolling Merkle list of messages that represents message history\n\n## Interface\n\n### HashPath Functions\n- `hashpath/2(Msg, Opts)` - Get message's HashPath\n- `hashpath/3(Msg1, Msg2, Opts)` - Add Msg2's ID to Msg1's HashPath\n- `hashpath/4(Msg1, Msg2, HashpathAlg, Opts)` - Add with specific algorithm\n- `hashpath_alg/1(Msg)` - Get message's HashPath algorithm\n- `verify_hashpath/2(MsgList, Opts)` - Verify HashPath against message history\n\n### Path Manipulation\n- `hd/2(Msg, Opts)` - Extract first key from Path\n- `tl/2(Msg, Opts)` - Return message without first path element\n- `push_request/2(Msg, Path)` - Add message to head of request path\n- `queue_request/2(Msg, Path)` - Queue message at back of request path\n- `pop_request/2(Msg, Opts)` - Pop next element from request path\n\n### Private Path Functions\n- `priv_remaining/2(Msg, Opts)` - Get remaining path from private AO-Core key\n- `priv_store_remaining/2(Msg, Path)` - Store remaining path in private AO-Core key\n\n### Path Utilities\n- `term_to_path_parts/1,2` - Convert term to executable path\n- `from_message/2` - Extract request path or hashpath from message\n- `matches/2` - Check if two keys match\n- `regex_matches/2` - Check if keys match using regex\n- `normalize/1` - Normalize path to binary\n- `to_binary/1` - Convert path to binary\n\n## Dependencies\n\n### Direct Dependencies\n- hb_ao: Core protocol operations\n- hb_util: Utility functions\n- hb_crypto: Cryptographic operations\n- hb_private: Private data handling\n- dev_message: Message operations\n\n### Inverse Dependencies\n- Used by modules that need path manipulation\n- Core component for message routing\n- Essential for message history tracking\n\n## Implementation Details\n\n### Key Concepts\n\n1. **HashPath Implementation**\n   ```\n   Msg1.HashPath = Msg1.ID\n   Msg3.HashPath = Hash(Msg1.HashPath, Msg2.ID)\n   Msg3.{...} = AO-Core.apply(Msg1, Msg2)\n   ```\n   - Rolling Merkle list of applied messages\n   - Each message depends on all previous messages\n   - Represents a history tree, not just linear history\n\n2. **HashPath Algorithms**\n   - Default: sha-256-chain\n   - Alternative: accumulate-256\n   - Customizable per message\n\n3. **Path Manipulation**\n   - Supports multiple path formats\n   - Handles binary, list, and atom paths\n   - Provides regex matching capabilities\n\n### State Management\n- Stateless module\n- Paths stored in message maps\n- Private paths in AO-Core key\n- HashPaths maintained in message history\n\n### Error Handling\n- Validates path formats\n- Handles missing paths\n- Verifies HashPath integrity\n- Supports custom error strategies\n\n## Integration Points\n\n1. **Message System**\n   - Core part of message routing\n   - Integrates with message history\n   - Supports message verification\n\n2. **Protocol Integration**\n   - Essential for AO-Core protocol\n   - Handles path normalization\n   - Manages message history\n\n3. **Security Integration**\n   - HashPath verification\n   - Message history integrity\n   - Cryptographic algorithm support\n\n## Analysis Insights\n\n### Performance Considerations\n1. Efficient path manipulation\n   - O(1) head/tail operations\n   - Optimized binary handling\n   - Lazy path normalization\n\n2. HashPath Optimization\n   - Caches computed HashPaths\n   - Minimizes recalculations\n   - Efficient verification\n\n### Security Implications\n1. Message History Integrity\n   - Merkle tree structure\n   - Cryptographic verification\n   - History tampering detection\n\n2. Path Security\n   - Path normalization\n   - Regex safety checks\n   - Private path protection\n\n### Best Practices\n1. HashPath Usage\n   - Verify message history\n   - Use appropriate algorithms\n   - Handle verification failures\n\n2. Path Manipulation\n   - Normalize paths consistently\n   - Use appropriate path formats\n   - Handle private paths carefully\n"},"core/message_protocol/modules/hb_private.md":{"content":"# Module: hb_private\n\n## Basic Information\n- **Source File:** hb_private.erl\n- **Module Type:** Core Message Protocol\n- **Behavior:** None\n\n## Purpose\nProvides utilities for managing the private element of messages, which stores state that is not included in serialized messages or exposed via APIs. This temporary state storage is useful for caching expensive computations but should not be used for non-deterministic execution state.\n\n## Interface\n\n### Core Functions\n- `from_message/1` - Get private key from message, returns empty map if not found\n- `reset/1` - Unset all private keys in message\n- `is_private/1` - Check if a key is private\n\n### Private Data Management\n- `get/3,4` - Get value from private element using AO-Core resolve\n- `set/3,4` - Set key in private element\n- `set_priv/2` - Set complete private element\n\n## Dependencies\n\n### Direct Dependencies\n- hb_ao: Core protocol operations\n- hb_path: Path manipulation\n- hb_util: Utility functions\n\n### Inverse Dependencies\n- Used by modules needing private state\n- Core component for message state\n- Essential for caching operations\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Private Element Structure**\n   ```erlang\n   Message = #{\n     <<\"priv\">> => #{\n       <<\"key1\">> => Value1,\n       <<\"key2\">> => Value2\n     },\n     <<\"public_key\">> => PublicValue\n   }\n   ```\n\n2. **Private Path Resolution**\n   - Removes private specifier from path\n   - Uses AO-Core resolve internally\n   - Maintains path structure\n\n3. **State Management**\n   - Temporary state storage\n   - Non-serialized data\n   - Cache-friendly design\n\n### State Management\n\n1. **Private Data**\n   - Stored in \"priv\" key\n   - Not serialized\n   - Not exposed via APIs\n\n2. **Cache Management**\n   - Supports expensive computation caching\n   - Temporary state storage\n   - Reset functionality\n\n3. **Path Handling**\n   - Private path specifiers\n   - Path normalization\n   - Resolution options\n\n### Error Handling\n\n1. **Missing Data**\n   - Returns empty map for missing private data\n   - Uses default values in get operations\n   - Handles non-map messages\n\n2. **Path Resolution**\n   - Handles invalid paths\n   - Manages private specifiers\n   - Validates key types\n\n## Integration Points\n\n1. **Message System**\n   - Private data storage\n   - State management\n   - Path resolution\n\n2. **Cache System**\n   - Temporary state storage\n   - Performance optimization\n   - Resource management\n\n3. **Protocol System**\n   - AO-Core integration\n   - Path handling\n   - State persistence\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **State Management**\n   - Efficient map operations\n   - Minimal data duplication\n   - Cache-friendly design\n\n2. **Path Resolution**\n   - Optimized path handling\n   - Efficient key normalization\n   - Minimal overhead\n\n### Security Implications\n\n1. **Data Privacy**\n   - Non-serialized state\n   - Hidden from APIs\n   - Controlled access\n\n2. **State Isolation**\n   - Separate from public data\n   - Protected from external access\n   - Controlled modification\n\n### Best Practices\n\n1. **Private Data Usage**\n   - Use for temporary state only\n   - Cache expensive computations\n   - Avoid non-deterministic state\n\n2. **State Management**\n   - Reset when no longer needed\n   - Use appropriate paths\n   - Handle missing data gracefully\n"}}