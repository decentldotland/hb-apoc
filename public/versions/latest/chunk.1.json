{"core/development_tools/modules/hb_debugger.md":{"content":"# Module: hb_debugger\n\n## Basic Information\n- **Source File:** hb_debugger.erl\n- **Module Type:** Development Tool\n- **Purpose:** External Debugger Integration Interface\n\n## Purpose\nProvides bootstrapping interfaces for external debuggers to connect to HyperBEAM. The module is specifically designed to work with Language Server Protocol (LSP) compatible editors like VS Code and Emacs through the erlang-ls extension, enabling graphical debugging capabilities.\n\n## Interface\n\n### Core Operations\n- `start/0` - Initialize debugger and await connection\n- `start_and_break/2, start_and_break/3` - Start debugger with breakpoint\n- `await_breakpoint/0` - Wait for breakpoint to be set\n- `interpret/1` - Load module into debugger (internal)\n- `await_debugger/0, await_debugger/1` - Wait for debugger connection (internal)\n\n## Dependencies\n\n### Direct Dependencies\n- debugger: Erlang debugger application\n- int: Interpreter interface\n- timer: Sleep functionality\n- init: System control\n- io: Output formatting\n\n### Inverse Dependencies\n- Used by development tools\n- IDE integration point\n- Debug workflow support\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Debugger Initialization**\n   ```erlang\n   % Start debugger and await connection\n   start() ->\n       io:format(\"Starting debugger...~n\", []),\n       DebuggerRes = application:ensure_all_started(debugger),\n       io:format(\"Started debugger server. Result: ~p.~n\", [DebuggerRes]),\n       io:format(\n           \"Waiting for debugger. Node is: ~p. Cookie is: ~p.~n\",\n           [node(), erlang:get_cookie()]\n       ),\n       await_debugger().\n   ```\n   Features:\n   - Application startup\n   - Connection handling\n   - Status reporting\n   - Error handling\n\n2. **Module Interpretation**\n   ```erlang\n   % Safe module interpretation\n   interpret(Module) ->\n       Parent = self(),\n       spawn(fun() ->\n           case int:interpretable(Module) of\n               true ->\n                   try Parent ! {interpreted, Module, int:i(Module) == ok}\n                   catch _:_ ->\n                       io:format(\"Could not load module: ~p.~n\", [Module]),\n                       false\n                   end;\n               Error ->\n                   io:format(\n                       \"Could not interpret module: ~p. Error: ~p.~n\",\n                       [Module, Error]\n                   ),\n                   false\n           end\n       end).\n   ```\n   Provides:\n   - Safe loading\n   - Error handling\n   - Status reporting\n   - Timeout protection\n\n3. **Breakpoint Management**\n   ```erlang\n   % Breakpoint setup and execution\n   start_and_break(Module, Function, Args) ->\n       start(),\n       interpret(Module),\n       SetRes = int:break_in(Module, Function, length(Args)),\n       io:format(\n           \"Breakpoint set. Result from `int:break_in/3': ~p.~n\",\n           [SetRes]\n       ),\n       io:format(\"Invoking function...~n\", []),\n       apply(Module, Function, Args),\n       io:format(\"Function invoked. Terminating.~n\", []),\n       init:stop().\n   ```\n   Features:\n   - Breakpoint setup\n   - Function execution\n   - Status reporting\n   - Clean termination\n\n### State Management\n\n1. **Connection State**\n   ```erlang\n   % Connection detection\n   is_debugging_node_connected() ->\n       case nodes() ++ nodes(hidden) of\n           [] -> false;\n           [Node | _] -> Node\n       end.\n   ```\n   Handles:\n   - Node detection\n   - Connection state\n   - Hidden nodes\n   - Error handling\n\n2. **Breakpoint State**\n   ```erlang\n   % Breakpoint monitoring\n   await_breakpoint(N) ->\n       io:format(\"Waiting for breakpoint to be set in function...~n\", []),\n       case int:all_breaks() of\n           [] ->\n               timer:sleep(1000),\n               io:format(\"Still waiting for breakpoint after ~p seconds...~n\", [N]),\n               await_breakpoint(N + 1);\n           [Breakpoint | _] ->\n               io:format(\"Breakpoint set. Info: ~p.~n\", [Breakpoint]),\n               Breakpoint\n       end.\n   ```\n   Manages:\n   - Breakpoint status\n   - Wait cycles\n   - Status reporting\n   - Error handling\n\n### Error Handling\n\n1. **Interpretation Errors**\n   ```erlang\n   % Safe module interpretation\n   try Parent ! {interpreted, Module, int:i(Module) == ok}\n   catch _:_ ->\n       io:format(\"Could not load module: ~p.~n\", [Module]),\n       false\n   end\n   ```\n   Ensures:\n   - Safe loading\n   - Error reporting\n   - State recovery\n   - Process isolation\n\n2. **Connection Errors**\n   ```erlang\n   % Connection monitoring\n   await_debugger(N) ->\n       case is_debugging_node_connected() of\n           false ->\n               timer:sleep(1000),\n               io:format(\"Still waiting for debugger after ~p seconds...~n\", [N]),\n               await_debugger(N + 1);\n           Node ->\n               io:format(\n                   \"External node connection detected. Peer: ~p.~n\",\n                   [Node]\n               ),\n               N\n       end.\n   ```\n   Handles:\n   - Connection failures\n   - Timeout handling\n   - Status reporting\n   - State recovery\n\n## Integration Points\n\n1. **IDE Integration**\n   - VS Code support\n   - Emacs support\n   - LSP compatibility\n   - Configuration files\n\n2. **Debugger System**\n   - Process control\n   - State tracking\n   - Event handling\n   - Resource management\n\n3. **Node System**\n   - Connection handling\n   - State tracking\n   - Error handling\n   - Resource cleanup\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Startup Time**\n   - ~10 second boot time\n   - Connection delays\n   - Resource allocation\n   - State initialization\n\n2. **Operation Efficiency**\n   - Safe interpretation\n   - Quick connection\n   - Fast breakpoints\n   - Clean termination\n\n### Security Implications\n\n1. **Node Security**\n   - Cookie handling\n   - Node visibility\n   - Connection control\n   - Resource protection\n\n2. **Resource Safety**\n   - Process isolation\n   - State protection\n   - Error containment\n   - Clean termination\n\n### Best Practices\n\n1. **Debugger Setup**\n   ```erlang\n   % Recommended debugger initialization\n   setup_debugger(Module, Function) ->\n       start(),\n       case interpret(Module) of\n           true ->\n               setup_breakpoint(Module, Function);\n           false ->\n               handle_interpretation_error(Module)\n       end.\n   ```\n\n2. **Connection Handling**\n   ```erlang\n   % Recommended connection handling\n   handle_connection() ->\n       case await_debugger() of\n           Node when is_atom(Node) ->\n               setup_debugging(Node);\n           timeout ->\n               handle_timeout()\n       end.\n   ```\n\n3. **Breakpoint Management**\n   ```erlang\n   % Recommended breakpoint handling\n   manage_breakpoint(Module, Function) ->\n       case int:break_in(Module, Function, 0) of\n           ok -> monitor_execution();\n           error -> handle_breakpoint_error()\n       end.\n   ```\n\n### Example Usage\n\n```erlang\n% Start debugger and wait for connection\nhb_debugger:start(),\n\n% Start with breakpoint\nhb_debugger:start_and_break(my_module, my_function),\n\n% Start with breakpoint and args\nhb_debugger:start_and_break(my_module, my_function, [arg1, arg2]),\n\n% Wait for manual breakpoint\nhb_debugger:await_breakpoint()\n```\n\n## Debug Flow\n\n```mermaid\ngraph TD\n    A[Start Debugger] -->|Initialize| B[Wait for Connection]\n    B -->|Connected| C[Load Module]\n    C -->|Loaded| D[Set Breakpoint]\n    \n    D -->|Execute| E[Function Call]\n    E -->|Break| F[Debug Session]\n    F -->|Continue| G[Function Return]\n    \n    G -->|Complete| H[Terminate]\n```\n\n## Connection Flow\n\n```mermaid\nsequenceDiagram\n    participant IDE as IDE/Editor\n    participant Debug as Debugger\n    participant Node as Erlang Node\n    participant Mod as Module\n\n    IDE->>Debug: Connect Request\n    Debug->>Node: Start Server\n    Node-->>Debug: Server Ready\n    Debug-->>IDE: Ready for Connection\n    \n    IDE->>Debug: Set Breakpoint\n    Debug->>Mod: Load Module\n    Mod-->>Debug: Module Ready\n    Debug->>Mod: Set Break\n    \n    Mod-->>Debug: Break Set\n    Debug-->>IDE: Ready to Debug\n"},"core/development_tools/modules/hb_escape.md":{"content":"# Module: hb_escape\n\n## Basic Information\n- **Source File:** hb_escape.erl\n- **Module Type:** Development Tool\n- **Purpose:** HTTP Header Case Handling\n\n## Purpose\nProvides functionality for escaping and unescaping mixed case values in HTTP headers, specifically for AO-Core message transmission in HTTP/2 and HTTP/3 where uppercase header keys are disallowed. The module handles the conversion of mixed-case IDs to lowercase %-encoded URI-style strings.\n\n## Interface\n\n### Core Operations\n- `encode/1` - URI encode a binary\n- `decode/1` - Decode URI-encoded binary\n- `encode_keys/1` - Encode map keys\n- `decode_keys/1` - Decode map keys\n\n## Dependencies\n\n### Direct Dependencies\n- lists: List operations\n- binary: Binary manipulation\n- maps: Map operations\n- eunit: Testing framework\n\n### Inverse Dependencies\n- Used by HTTP handlers\n- Protocol integration\n- Message encoding\n\n## Implementation Details\n\n### Key Concepts\n\n1. **URI Encoding**\n   ```erlang\n   % Binary encoding\n   encode(Bin) when is_binary(Bin) ->\n       list_to_binary(percent_escape(binary_to_list(Bin))).\n   ```\n   Features:\n   - Binary handling\n   - Character escaping\n   - List conversion\n   - Safe encoding\n\n2. **URI Decoding**\n   ```erlang\n   % Binary decoding\n   decode(Bin) when is_binary(Bin) ->\n       list_to_binary(percent_unescape(binary_to_list(Bin))).\n   ```\n   Provides:\n   - Binary handling\n   - Character unescaping\n   - List conversion\n   - Safe decoding\n\n3. **Map Key Handling**\n   ```erlang\n   % Key encoding in maps\n   encode_keys(Msg) when is_map(Msg) ->\n       maps:from_list(\n           lists:map(\n               fun({Key, Value}) -> {encode(Key), Value} end,\n               maps:to_list(Msg)\n           )\n       ).\n   ```\n   Features:\n   - Map traversal\n   - Key encoding\n   - Value preservation\n   - Structure maintenance\n\n### Character Handling\n\n1. **Character Escaping**\n   ```erlang\n   % Character escape logic\n   percent_escape([]) -> [];\n   percent_escape([C | Cs]) when C >= $a, C =< $z -> [C | percent_escape(Cs)];\n   percent_escape([C | Cs]) when C >= $0, C =< $9 -> [C | percent_escape(Cs)];\n   percent_escape([C | Cs]) when\n           C == $.; C == $-; C == $_; C == $/;\n           C == $?; C == $&; C == $+ ->\n       [C | percent_escape(Cs)];\n   percent_escape([C | Cs]) -> [escape_byte(C) | percent_escape(Cs)].\n   ```\n   Handles:\n   - Safe characters\n   - Special characters\n   - Byte encoding\n   - Recursive processing\n\n2. **Byte Encoding**\n   ```erlang\n   % Byte-level encoding\n   escape_byte(C) when C >= 0, C =< 255 ->\n       [$%, hex_digit(C bsr 4), hex_digit(C band 15)].\n\n   hex_digit(N) when N >= 0, N =< 9 ->\n       N + $0;\n   hex_digit(N) when N > 9, N =< 15 ->\n       N + $a - 10.\n   ```\n   Provides:\n   - Hex conversion\n   - Byte validation\n   - Safe encoding\n   - Character mapping\n\n### Error Handling\n\n1. **Input Validation**\n   ```erlang\n   % Binary validation\n   encode(Bin) when is_binary(Bin) ->\n       % Only accept binary input\n       list_to_binary(percent_escape(binary_to_list(Bin))).\n   ```\n   Ensures:\n   - Type checking\n   - Input validation\n   - Safe conversion\n   - Error prevention\n\n2. **Character Validation**\n   ```erlang\n   % Character validation\n   hex_value(C) when C >= $0, C =< $9 ->\n       C - $0;\n   hex_value(C) when C >= $a, C =< $f ->\n       C - $a + 10;\n   hex_value(C) when C >= $A, C =< $F ->\n       C - $A + 10.\n   ```\n   Handles:\n   - Valid ranges\n   - Case handling\n   - Value mapping\n   - Error prevention\n\n## Integration Points\n\n1. **HTTP System**\n   - Header encoding\n   - Key normalization\n   - Value preservation\n   - Protocol compliance\n\n2. **Message System**\n   - Map handling\n   - Key encoding\n   - Value preservation\n   - Structure maintenance\n\n3. **Protocol System**\n   - HTTP/2 compliance\n   - HTTP/3 compliance\n   - Case handling\n   - Safe transmission\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Memory Usage**\n   ```erlang\n   % Efficient list processing\n   percent_escape([C | Cs]) when C >= $a, C =< $z -> [C | percent_escape(Cs)];\n   percent_escape([C | Cs]) when C >= $0, C =< $9 -> [C | percent_escape(Cs)];\n   ```\n   Features:\n   - Tail recursion\n   - Pattern matching\n   - Early returns\n   - Memory efficiency\n\n2. **Operation Efficiency**\n   ```erlang\n   % Efficient map processing\n   encode_keys(Msg) when is_map(Msg) ->\n       maps:from_list(\n           lists:map(\n               fun({Key, Value}) -> {encode(Key), Value} end,\n               maps:to_list(Msg)\n           )\n       ).\n   ```\n   Provides:\n   - Single pass\n   - Bulk processing\n   - Memory reuse\n   - Fast conversion\n\n### Security Implications\n\n1. **Input Safety**\n   - Binary validation\n   - Character validation\n   - Range checking\n   - Safe conversion\n\n2. **Output Safety**\n   - Safe encoding\n   - Valid characters\n   - Protocol compliance\n   - Error prevention\n\n### Best Practices\n\n1. **Encoding**\n   ```erlang\n   % Recommended encoding pattern\n   handle_encoding(Input) ->\n       case encode(Input) of\n           Encoded when is_binary(Encoded) ->\n               process_encoded(Encoded);\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n2. **Decoding**\n   ```erlang\n   % Recommended decoding pattern\n   handle_decoding(Input) ->\n       try decode(Input) of\n           Decoded ->\n               process_decoded(Decoded)\n       catch\n           _:_ ->\n               handle_error(invalid_encoding)\n       end.\n   ```\n\n3. **Map Handling**\n   ```erlang\n   % Recommended map processing\n   process_map(Map) ->\n       EncodedMap = encode_keys(Map),\n       validate_map(EncodedMap),\n       process_encoded_map(EncodedMap).\n   ```\n\n### Example Usage\n\n```erlang\n% Encode binary\nEncoded = hb_escape:encode(<<\"Hello-World\">>),\n\n% Decode binary\nDecoded = hb_escape:decode(<<\"%48ello-%57orld\">>),\n\n% Encode map keys\nEncodedMap = hb_escape:encode_keys(#{\n    <<\"MixedCase\">> => value,\n    <<\"UPPERCASE\">> => other_value\n}),\n\n% Decode map keys\nDecodedMap = hb_escape:decode_keys(#{\n    <<\"%4dixedCase\">> => value,\n    <<\"%55PPERCASE\">> => other_value\n})\n```\n\n## Encoding Flow\n\n```mermaid\ngraph TD\n    A[Input Binary] -->|Validate| B{Is Binary?}\n    B -->|Yes| C[Convert to List]\n    C -->|Process| D[Escape Characters]\n    D -->|Convert| E[Output Binary]\n    \n    B -->|No| F[Error]\n```\n\n## Character Processing Flow\n\n```mermaid\nsequenceDiagram\n    participant Input as Input Char\n    participant Check as Validator\n    participant Escape as Escaper\n    participant Output as Output\n\n    Input->>Check: Character\n    Check->>Check: Check Range\n    \n    alt Safe Character\n        Check->>Output: Keep Original\n    else Special Character\n        Check->>Escape: Encode\n        Escape->>Output: Hex Encoded\n    end\n"},"core/development_tools/modules/hb_json.md":{"content":"# Module: hb_json\n\n## Basic Information\n- **Source File:** hb_json.erl\n- **Module Type:** Development Tool\n- **Purpose:** JSON Encoding/Decoding Wrapper\n\n## Purpose\nProvides an abstraction layer over JSON encoding and decoding operations, supporting both maps and Jiffy's 'ejson' format. The module is designed to allow easy switching between different JSON libraries in the future by centralizing JSON operations through a single interface.\n\n## Interface\n\n### Core Operations\n- `encode/1` - Convert Erlang term to JSON string\n- `decode/1` - Convert JSON string to Erlang term\n- `decode/2` - Convert JSON string with options (forwards to decode/1)\n\n## Dependencies\n\n### Direct Dependencies\n- json: Underlying JSON library\n- iolist: Binary conversion\n\n### Inverse Dependencies\n- Used by data handlers\n- Protocol integration\n- Message formatting\n\n## Implementation Details\n\n### Key Concepts\n\n1. **JSON Encoding**\n   ```erlang\n   % Term to JSON conversion\n   encode(Term) ->\n       iolist_to_binary(json:encode(Term)).\n   ```\n   Features:\n   - Term conversion\n   - Binary output\n   - Library abstraction\n   - Safe encoding\n\n2. **JSON Decoding**\n   ```erlang\n   % JSON to term conversion\n   decode(Bin) -> json:decode(Bin).\n   decode(Bin, _Opts) -> decode(Bin).\n   ```\n   Provides:\n   - JSON parsing\n   - Term conversion\n   - Options handling\n   - Library abstraction\n\n### Format Support\n\n1. **Data Types**\n   - Maps\n   - Jiffy ejson\n   - Binary strings\n   - Erlang terms\n\n2. **Conversion Flow**\n   ```erlang\n   % Encoding flow\n   Erlang Term -> json:encode -> iolist -> binary\n\n   % Decoding flow\n   Binary -> json:decode -> Erlang Term\n   ```\n\n### Error Handling\n\n1. **Encoding Safety**\n   ```erlang\n   % Safe encoding with binary conversion\n   encode(Term) ->\n       iolist_to_binary(json:encode(Term)).\n   ```\n   Ensures:\n   - Valid output\n   - Binary format\n   - Error propagation\n   - Safe conversion\n\n2. **Decoding Safety**\n   ```erlang\n   % Safe decoding with option handling\n   decode(Bin, _Opts) -> decode(Bin).\n   ```\n   Handles:\n   - Input validation\n   - Option ignoring\n   - Error propagation\n   - Safe conversion\n\n## Integration Points\n\n1. **Data System**\n   - Term encoding\n   - JSON decoding\n   - Format conversion\n   - Binary handling\n\n2. **Protocol System**\n   - Message formatting\n   - Data exchange\n   - Format standardization\n   - Error handling\n\n3. **Library System**\n   - JSON abstraction\n   - Library switching\n   - Format support\n   - Error handling\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Memory Usage**\n   - Binary conversion\n   - Efficient encoding\n   - Direct decoding\n   - Memory optimization\n\n2. **Operation Efficiency**\n   - Single pass\n   - Direct conversion\n   - Library delegation\n   - Minimal overhead\n\n### Security Implications\n\n1. **Data Safety**\n   - Input validation\n   - Output safety\n   - Error handling\n   - Format checking\n\n2. **Format Safety**\n   - Valid JSON\n   - Safe conversion\n   - Error handling\n   - Type checking\n\n### Best Practices\n\n1. **Encoding**\n   ```erlang\n   % Recommended encoding pattern\n   handle_encoding(Term) ->\n       try\n           JSON = hb_json:encode(Term),\n           process_json(JSON)\n       catch\n           Error -> handle_error(Error)\n       end.\n   ```\n\n2. **Decoding**\n   ```erlang\n   % Recommended decoding pattern\n   handle_decoding(JSON) ->\n       try\n           Term = hb_json:decode(JSON),\n           process_term(Term)\n       catch\n           Error -> handle_error(Error)\n       end.\n   ```\n\n3. **Integration**\n   ```erlang\n   % Recommended integration pattern\n   process_data(Data) ->\n       case needs_json(Data) of\n           true -> \n               JSON = hb_json:encode(Data),\n               send_json(JSON);\n           false ->\n               process_raw(Data)\n       end.\n   ```\n\n### Example Usage\n\n```erlang\n% Encode term to JSON\nJSON = hb_json:encode(#{\n    name => <<\"test\">>,\n    value => 42,\n    list => [1, 2, 3]\n}),\n\n% Decode JSON to term\nTerm = hb_json:decode(<<\"{\\\"name\\\":\\\"test\\\",\\\"value\\\":42}\">>),\n\n% Decode with options (forwards to basic decode)\nTerm = hb_json:decode(JSON, #{})\n```\n\n## Encoding Flow\n\n```mermaid\ngraph TD\n    A[Erlang Term] -->|encode| B[JSON Library]\n    B -->|encode| C[IOList]\n    C -->|convert| D[Binary JSON]\n```\n\n## Decoding Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant JSON as hb_json\n    participant Lib as JSON Library\n    participant Term as Erlang Term\n\n    App->>JSON: decode(Binary)\n    JSON->>Lib: json:decode\n    Lib->>Lib: Parse JSON\n    Lib->>Term: Convert\n    Term-->>App: Erlang Term\n"},"core/development_tools/modules/hb_tracer.md":{"content":"# Module: hb_tracer\n\n## Basic Information\n- **Source File:** hb_tracer.erl\n- **Module Type:** Development Tool\n- **Purpose:** Request Lifecycle Tracing\n\n## Purpose\nProvides a comprehensive tracing system for tracking request lifecycles through HyperBEAM, from initial HTTP receipt through processing and response. The module enables detailed monitoring and debugging of request flows with user-friendly error reporting.\n\n## Interface\n\n### Core Operations\n- `start_trace/0` - Initialize new trace process\n- `record_step/2` - Record trace step\n- `get_trace/1` - Retrieve trace data\n- `format_error_trace/1` - Format trace for error display\n\n## Dependencies\n\n### Direct Dependencies\n- queue: Queue data structure\n- string: String manipulation\n- maps: Map operations\n- lists: List operations\n\n### Inverse Dependencies\n- Used by request handlers\n- Error reporting system\n- Debug workflow support\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Trace Process**\n   ```erlang\n   % Trace process initialization\n   start_trace() ->\n       Trace = #{ steps => queue:new() },\n       TracePID = spawn(fun() -> trace_loop(Trace) end),\n       ?event(trace, {trace_started, TracePID}),\n       TracePID.\n   ```\n   Features:\n   - Dedicated process\n   - Queue-based storage\n   - Event tracking\n   - Process isolation\n\n2. **Trace Recording**\n   ```erlang\n   % Trace step recording\n   trace_loop(Trace) ->\n       receive\n           {record_step, Step} ->\n               Steps = maps:get(steps, Trace),\n               NewTrace = Trace#{steps => queue:in(Step, Steps)},\n               ?event(trace, {step_recorded, Step}),\n               trace_loop(NewTrace);\n           {get_trace, From} ->\n               TraceWithList = Trace#{steps => queue:to_list(maps:get(steps, Trace))},\n               From ! {trace, TraceWithList},\n               trace_loop(Trace)\n       end.\n   ```\n   Provides:\n   - Step recording\n   - State management\n   - Event tracking\n   - Data retrieval\n\n3. **Error Formatting**\n   ```erlang\n   % Error trace formatting\n   format_error_trace(Trace) ->\n       Steps = maps:get(steps, Trace, []),\n       TraceMap = lists:foldl(fun (TraceItem, Acc) ->\n           case TraceItem of\n               {http, {parsed_singleton, _, _}} -> \n                   maps:put(request_parsing, true, Acc);\n               {ao_core, {stage, Stage, _Task}} -> \n                   maps:put(resolve_stage, Stage, Acc);\n               {ao_result, {load_device_failed, _, _, _, _, {exec_exception, Exception}, _, _}} ->\n                   maps:put(error, Exception, Acc);\n               {ao_result, {exec_failed, _, _, _, {func, Fun}, _, {exec_exception, Error}, _, _}} ->\n                   maps:put(error, {Fun, Error}, Acc);\n               _ -> Acc\n           end\n       end, #{}, Steps).\n   ```\n   Features:\n   - Error analysis\n   - Stage tracking\n   - User-friendly output\n   - Emoji integration\n\n### State Management\n\n1. **Trace State**\n   ```erlang\n   % Trace state structure\n   Trace = #{ \n       steps => queue:new() \n   }\n   ```\n   Manages:\n   - Step sequence\n   - Queue operations\n   - State updates\n   - Data retrieval\n\n2. **Error State**\n   ```erlang\n   % Error state tracking\n   TraceMap = #{\n       request_parsing => boolean(),\n       resolve_stage => integer(),\n       error => term()\n   }\n   ```\n   Tracks:\n   - Parse status\n   - Stage progress\n   - Error details\n   - Execution state\n\n### Error Handling\n\n1. **Trace Retrieval**\n   ```erlang\n   % Safe trace retrieval\n   get_trace(TracePID) ->\n       TracePID! {get_trace, self()},\n       receive\n           {trace, Trace} ->\n               Trace\n           after 5000 ->\n               ?event(trace, {trace_timeout, TracePID}),\n               {trace, #{}}\n       end.\n   ```\n   Ensures:\n   - Timeout handling\n   - Default values\n   - Event tracking\n   - Clean recovery\n\n2. **Error Formatting**\n   ```erlang\n   % Error message formatting\n   TraceStrings = [\"Oops! Something went wrong. Here's the rundown:\"],\n   ParsingTrace = case maps:get(request_parsing, TraceMap, false) of\n       false ->\n           TraceStrings ++ [[failure_emoji(), \"Parsing your request\"]];\n       true ->\n           TraceStrings ++ [[checkmark_emoji(), \"Parsing your request\"]]\n   end.\n   ```\n   Provides:\n   - Clear messages\n   - Visual indicators\n   - Stage tracking\n   - Error context\n\n## Integration Points\n\n1. **Request System**\n   - HTTP handling\n   - Request tracking\n   - Error detection\n   - State monitoring\n\n2. **Error System**\n   - Error formatting\n   - Message generation\n   - Visual indicators\n   - User feedback\n\n3. **Debug System**\n   - Trace collection\n   - State tracking\n   - Event monitoring\n   - Error analysis\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Memory Usage**\n   - Queue-based storage\n   - Process isolation\n   - State management\n   - Resource cleanup\n\n2. **Operation Efficiency**\n   - Fast recording\n   - Quick retrieval\n   - Smart formatting\n   - Clean termination\n\n### Security Implications\n\n1. **Process Safety**\n   - Isolated processes\n   - State protection\n   - Error containment\n   - Resource cleanup\n\n2. **Data Safety**\n   - Controlled access\n   - Safe formatting\n   - Error handling\n   - State protection\n\n### Best Practices\n\n1. **Trace Management**\n   ```erlang\n   % Recommended trace handling\n   handle_trace() ->\n       TracePID = start_trace(),\n       try\n           process_request(TracePID)\n       after\n           format_trace(TracePID)\n       end.\n   ```\n\n2. **Error Handling**\n   ```erlang\n   % Recommended error handling\n   handle_error(TracePID, Error) ->\n       record_step(TracePID, {error, Error}),\n       Trace = get_trace(TracePID),\n       format_error_trace(Trace).\n   ```\n\n3. **State Management**\n   ```erlang\n   % Recommended state handling\n   manage_state(TracePID, State) ->\n       record_step(TracePID, {state, State}),\n       process_state(State).\n   ```\n\n### Example Usage\n\n```erlang\n% Start tracing\nTracePID = hb_tracer:start_trace(),\n\n% Record steps\nhb_tracer:record_step(TracePID, {http, {request_received}}),\nhb_tracer:record_step(TracePID, {http, {parsing_started}}),\nhb_tracer:record_step(TracePID, {http, {parsed_singleton, ReqData, _}}),\n\n% Get trace\nTrace = hb_tracer:get_trace(TracePID),\n\n% Format error trace\nErrorMessage = hb_tracer:format_error_trace(Trace)\n```\n\n## Trace Flow\n\n```mermaid\ngraph TD\n    A[Request Start] -->|Record| B[Parse Request]\n    B -->|Record| C[Process Request]\n    C -->|Record| D[Execute Request]\n    \n    D -->|Success| E[Record Success]\n    D -->|Error| F[Record Error]\n    \n    E --> G[Format Trace]\n    F --> G\n```\n\n## Error Flow\n\n```mermaid\nsequenceDiagram\n    participant Req as Request\n    participant Trace as Tracer\n    participant Error as Error Handler\n    participant Format as Formatter\n\n    Req->>Trace: Record Step\n    Trace->>Error: Detect Error\n    Error->>Trace: Record Error\n    \n    Trace->>Format: Get Trace\n    Format->>Format: Process Steps\n    Format->>Format: Add Emojis\n    Format-->>Req: Error Message\n"},"core/development_tools/observations.md":{"content":"# Development Tools Observations\n\n## Architectural Patterns\n\n### 1. Tool Abstraction\nThe development tools demonstrate strong abstraction patterns:\n\n1. **Interface Abstraction**\n   - `hb_json`: Abstracts JSON library implementation\n   - `hb_escape`: Abstracts character encoding/decoding\n   - `hb_debugger`: Abstracts debugger connection\n   - `hb_tracer`: Abstracts request tracing\n\n2. **Implementation Hiding**\n   ```erlang\n   % JSON library abstraction\n   encode(Term) ->\n       iolist_to_binary(json:encode(Term)).\n   ```\n   Features:\n   - Clean interfaces\n   - Library independence\n   - Easy switching\n   - Future flexibility\n\n### 2. Process Management\nStrong process handling patterns:\n\n1. **Process Isolation**\n   ```erlang\n   % Tracer process creation\n   start_trace() ->\n       Trace = #{ steps => queue:new() },\n       TracePID = spawn(fun() -> trace_loop(Trace) end),\n       ?event(trace, {trace_started, TracePID}),\n       TracePID.\n   ```\n   Provides:\n   - State isolation\n   - Error containment\n   - Resource management\n   - Clean termination\n\n2. **Message Passing**\n   ```erlang\n   % Trace recording\n   record_step(TracePID, Step) ->\n       TracePID! {record_step, Step}.\n   ```\n   Features:\n   - Asynchronous operation\n   - State management\n   - Event tracking\n   - Error handling\n\n### 3. Error Handling\nSophisticated error handling approaches:\n\n1. **Safe Operations**\n   ```erlang\n   % Safe module interpretation\n   interpret(Module) ->\n       Parent = self(),\n       spawn(fun() ->\n           case int:interpretable(Module) of\n               true -> try_interpret(Module, Parent);\n               Error -> handle_error(Error)\n           end\n       end).\n   ```\n   Ensures:\n   - Operation safety\n   - Error recovery\n   - State protection\n   - Resource cleanup\n\n2. **Timeout Management**\n   ```erlang\n   % Timeout handling\n   get_trace(TracePID) ->\n       TracePID! {get_trace, self()},\n       receive\n           {trace, Trace} -> Trace\n           after 5000 -> {trace, #{}}\n       end.\n   ```\n   Provides:\n   - Operation timeouts\n   - Default values\n   - Clean recovery\n   - State protection\n\n## Implementation Patterns\n\n### 1. State Management\nConsistent state handling approaches:\n\n1. **Process State**\n   - Dedicated processes\n   - Message-based updates\n   - State isolation\n   - Clean termination\n\n2. **Data State**\n   - Queue-based storage\n   - Map structures\n   - Binary handling\n   - Safe conversion\n\n### 2. Resource Management\nCareful resource handling:\n\n1. **Process Resources**\n   - Process spawning\n   - Resource tracking\n   - Clean termination\n   - Error recovery\n\n2. **Memory Resources**\n   - Binary handling\n   - Efficient conversion\n   - Resource cleanup\n   - State management\n\n### 3. Protocol Integration\nClean protocol handling:\n\n1. **HTTP Integration**\n   - Header encoding\n   - Case handling\n   - Protocol compliance\n   - Safe transmission\n\n2. **Debug Protocol**\n   - Debugger connection\n   - State tracking\n   - Event handling\n   - Safe operation\n\n## Common Themes\n\n### 1. Safety First\nAll modules prioritize safety:\n\n1. **Operation Safety**\n   - Input validation\n   - Safe conversion\n   - Error handling\n   - State protection\n\n2. **Resource Safety**\n   - Process isolation\n   - Resource tracking\n   - Clean termination\n   - Error recovery\n\n### 2. Flexibility\nModules designed for flexibility:\n\n1. **Library Independence**\n   - Clean abstractions\n   - Easy switching\n   - Future proofing\n   - Clear interfaces\n\n2. **Protocol Support**\n   - Multiple formats\n   - Easy extension\n   - Clean integration\n   - Safe handling\n\n### 3. Developer Focus\nStrong developer experience:\n\n1. **Debugging Support**\n   - Easy connection\n   - Clear tracing\n   - Visual feedback\n   - Error context\n\n2. **Tool Integration**\n   - IDE support\n   - Protocol support\n   - Clear interfaces\n   - Easy usage\n\n## Areas for Improvement\n\n### 1. Documentation\nDocumentation could be enhanced:\n\n1. **Usage Examples**\n   - More examples\n   - Common patterns\n   - Best practices\n   - Error scenarios\n\n2. **Integration Guides**\n   - Setup guides\n   - Tool chains\n   - Common flows\n   - Error handling\n\n### 2. Testing\nTesting could be expanded:\n\n1. **Test Coverage**\n   - Edge cases\n   - Error scenarios\n   - Integration tests\n   - Performance tests\n\n2. **Test Tools**\n   - Helper functions\n   - Test utilities\n   - Coverage tools\n   - Performance tools\n\n## Future Directions\n\n### 1. Tool Enhancement\nPotential improvements:\n\n1. **Debugger**\n   - More features\n   - Better integration\n   - Visual tools\n   - Performance tools\n\n2. **Tracer**\n   - More formats\n   - Better visualization\n   - Performance tracking\n   - Error analysis\n\n### 2. Integration Enhancement\nWays to improve integration:\n\n1. **IDE Support**\n   - More editors\n   - Better integration\n   - Visual tools\n   - Debug support\n\n2. **Tool Chain**\n   - Better workflow\n   - Tool combination\n   - Clear patterns\n   - Easy setup\n\n## Development Patterns\n\n### 1. Code Structure\n```mermaid\ngraph TD\n    A[Development Tools] -->|Abstraction| B[Tool Interface]\n    B -->|Implementation| C[Core Logic]\n    C -->|Integration| D[System Interface]\n    \n    subgraph \"Tool Layer\"\n        B -->|API| E[Public Interface]\n        B -->|Internal| F[Private Logic]\n    end\n    \n    subgraph \"Core Layer\"\n        C -->|Processing| G[Business Logic]\n        C -->|State| H[Data Management]\n    end\n```\n\n### 2. Process Flow\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant Tool as Tool Interface\n    participant Core as Core Logic\n    participant System as System Interface\n\n    App->>Tool: Request\n    Tool->>Core: Process\n    Core->>System: Execute\n    System-->>Core: Result\n    Core-->>Tool: Format\n    Tool-->>App: Response\n```\n\n## Integration Architecture\n\n### 1. Component Structure\n```mermaid\ngraph TD\n    A[Development Tools] -->|Debug| B[Debug System]\n    A -->|Trace| C[Trace System]\n    A -->|Format| D[Format System]\n    \n    subgraph \"Debug Components\"\n        B -->|Connect| E[IDE]\n        B -->|Execute| F[Runtime]\n    end\n    \n    subgraph \"Trace Components\"\n        C -->|Record| G[Events]\n        C -->|Format| H[Output]\n    end\n```\n\n### 2. Data Flow\n```mermaid\nsequenceDiagram\n    participant IDE as Development IDE\n    participant Tools as Dev Tools\n    participant Core as Core System\n    participant Output as System Output\n\n    IDE->>Tools: Development Request\n    Tools->>Core: Process Request\n    Core->>Tools: System Response\n    Tools->>Output: Format Output\n    Output-->>IDE: Developer Feedback\n"},"core/development_tools/OVERVIEW.md":{"content":"# Development Tools System Overview\n\n## System Architecture\n\nThe Development Tools system provides a comprehensive suite of utilities that work together to support development, debugging, and system introspection. This system is built around four key components that provide essential development capabilities:\n\n### 1. Debugging Infrastructure (hb_debugger)\nThe debugging component serves as the primary interface for development-time system inspection:\n\n```erlang\n% Core debugging interface\nstart_and_break(Module, Function, Args) ->\n    start(),\n    interpret(Module),\n    SetRes = int:break_in(Module, Function, length(Args)),\n    apply(Module, Function, Args).\n```\n\nThis provides:\n- **IDE Integration**: Seamless connection with VS Code, Emacs, and other LSP-compatible editors\n- **Process Control**: Fine-grained control over execution and inspection\n- **State Inspection**: Runtime examination of system state\n- **Breakpoint Management**: Strategic execution control points\n\nThe debugger enables:\n1. **Interactive Development**\n   - Live code inspection\n   - State examination\n   - Execution control\n   - Error investigation\n\n2. **Development Workflow**\n   - Editor integration\n   - Process monitoring\n   - State tracking\n   - Error handling\n\n### 2. Request Tracing (hb_tracer)\nThe tracing system provides detailed request lifecycle tracking:\n\n```erlang\n% Core tracing system\nstart_trace() ->\n    Trace = #{ steps => queue:new() },\n    TracePID = spawn(fun() -> trace_loop(Trace) end),\n    ?event(trace, {trace_started, TracePID}),\n    TracePID.\n```\n\nThis enables:\n- **Request Tracking**: Complete lifecycle monitoring\n- **State Recording**: Step-by-step state capture\n- **Error Context**: Detailed error information\n- **Visual Feedback**: User-friendly output\n\nThe tracer provides:\n1. **Request Monitoring**\n   - Step recording\n   - State tracking\n   - Error detection\n   - Flow visualization\n\n2. **Development Insights**\n   - Performance analysis\n   - Error patterns\n   - Flow optimization\n   - System understanding\n\n### 3. Protocol Support (hb_escape)\nThe protocol support system handles data encoding requirements:\n\n```erlang\n% Protocol encoding system\nencode(Bin) when is_binary(Bin) ->\n    list_to_binary(percent_escape(binary_to_list(Bin))).\n\ndecode(Bin) when is_binary(Bin) ->\n    list_to_binary(percent_unescape(binary_to_list(Bin))).\n```\n\nThis provides:\n- **Case Handling**: Mixed-case value support\n- **Protocol Compliance**: HTTP/2 and HTTP/3 compatibility\n- **Safe Conversion**: Reliable data transformation\n- **Clean Integration**: Seamless system interaction\n\nThe encoder enables:\n1. **Protocol Integration**\n   - Header handling\n   - Case management\n   - Safe transmission\n   - Clean conversion\n\n2. **Data Management**\n   - Safe encoding\n   - Clean decoding\n   - State preservation\n   - Error handling\n\n### 4. Data Formatting (hb_json)\nThe formatting system provides data transformation capabilities:\n\n```erlang\n% Data formatting system\nencode(Term) ->\n    iolist_to_binary(json:encode(Term)).\n\ndecode(Bin) -> \n    json:decode(Bin).\n```\n\nThis enables:\n- **Format Abstraction**: Library-independent operation\n- **Clean Conversion**: Safe data transformation\n- **Format Support**: Multiple data formats\n- **Easy Integration**: Simple system interaction\n\nThe formatter provides:\n1. **Data Handling**\n   - Term conversion\n   - Format management\n   - Safe transformation\n   - Clean integration\n\n2. **System Integration**\n   - Library abstraction\n   - Format support\n   - Error handling\n   - State preservation\n\n## System Integration\n\n### 1. Component Interaction\nThe components work together in a layered architecture:\n\n```mermaid\ngraph TD\n    A[Development Tools] -->|Debug| B[Debug Layer]\n    A -->|Trace| C[Trace Layer]\n    A -->|Format| D[Format Layer]\n    \n    subgraph \"Debug System\"\n        B -->|Connect| E[IDE Integration]\n        B -->|Control| F[Process Management]\n    end\n    \n    subgraph \"Trace System\"\n        C -->|Record| G[Request Tracking]\n        C -->|Analyze| H[Flow Analysis]\n    end\n    \n    subgraph \"Format System\"\n        D -->|Transform| I[Data Conversion]\n        D -->|Validate| J[Data Validation]\n    end\n```\n\nThis enables:\n1. **Clean Architecture**\n   - Clear separation\n   - Strong cohesion\n   - Loose coupling\n   - Easy extension\n\n2. **System Coordination**\n   - Component interaction\n   - State management\n   - Error handling\n   - Flow control\n\n### 2. Data Flow\nThe system manages complex data flows:\n\n```mermaid\nsequenceDiagram\n    participant IDE as Development IDE\n    participant Debug as Debug System\n    participant Trace as Trace System\n    participant Format as Format System\n\n    IDE->>Debug: Development Request\n    Debug->>Trace: Record Operation\n    Trace->>Format: Transform Data\n    Format-->>Debug: Formatted Result\n    Debug-->>IDE: Development Response\n```\n\nThis provides:\n1. **Flow Management**\n   - Request tracking\n   - State monitoring\n   - Error detection\n   - Result formatting\n\n2. **System Coordination**\n   - Component synchronization\n   - State preservation\n   - Error propagation\n   - Clean interaction\n\n## Core Functionality\n\n### 1. Development Support\nThe system provides comprehensive development capabilities:\n\n1. **Debugging**\n   ```erlang\n   % Debug support\n   start_and_break(Module, Function) ->\n       start(),\n       interpret(Module),\n       break_in(Module, Function).\n   ```\n\n   Features:\n   - Live debugging\n   - State inspection\n   - Flow control\n   - Error analysis\n\n2. **Tracing**\n   ```erlang\n   % Trace support\n   record_step(TracePID, Step) ->\n       TracePID ! {record_step, Step}.\n   ```\n\n   Provides:\n   - Request tracking\n   - State recording\n   - Flow analysis\n   - Error context\n\n### 2. Protocol Support\nThe system enables protocol integration:\n\n1. **Encoding**\n   ```erlang\n   % Protocol encoding\n   encode_keys(Msg) when is_map(Msg) ->\n       maps:from_list(\n           lists:map(\n               fun({Key, Value}) -> {encode(Key), Value} end,\n               maps:to_list(Msg)\n           )\n       ).\n   ```\n\n   Features:\n   - Safe encoding\n   - Clean conversion\n   - Error handling\n   - State preservation\n\n2. **Formatting**\n   ```erlang\n   % Data formatting\n   format_error_trace(Trace) ->\n       Steps = maps:get(steps, Trace, []),\n       format_steps(Steps).\n   ```\n\n   Provides:\n   - Clean formatting\n   - Error context\n   - Visual feedback\n   - State representation\n\n## System Capabilities\n\n### 1. Development Tools\nThe system provides essential development capabilities:\n\n1. **Debug Tools**\n   - Interactive debugging\n   - State inspection\n   - Flow control\n   - Error analysis\n\n2. **Trace Tools**\n   - Request tracking\n   - State recording\n   - Flow analysis\n   - Error context\n\n### 2. Integration Tools\nComprehensive integration support:\n\n1. **Protocol Tools**\n   - Data encoding\n   - Format conversion\n   - State preservation\n   - Error handling\n\n2. **Format Tools**\n   - Data transformation\n   - Format management\n   - Clean conversion\n   - Error handling\n\n## Best Practices\n\n### 1. Development Workflow\nRecommended development approaches:\n\n```erlang\n% Development pattern\ndevelop_feature() ->\n    % Start debug session\n    Debug = start_debug(),\n    \n    % Enable tracing\n    Trace = start_trace(),\n    \n    % Execute with monitoring\n    try\n        execute_feature(Debug, Trace)\n    after\n        cleanup_resources()\n    end.\n```\n\n### 2. Integration Pattern\nRecommended integration approaches:\n\n```erlang\n% Integration pattern\nintegrate_system() ->\n    % Format data\n    Data = format_data(),\n    \n    % Encode for protocol\n    Encoded = encode_data(Data),\n    \n    % Execute with tracing\n    execute_with_trace(Encoded).\n```\n\n## Future Directions\n\n### 1. Tool Enhancement\nPotential improvements:\n\n1. **Debug System**\n   - Enhanced IDE integration\n   - Better visualization\n   - More control options\n   - Performance tools\n\n2. **Trace System**\n   - Better analysis\n   - More formats\n   - Visual tools\n   - Performance tracking\n\n### 2. Integration Enhancement\nWays to improve integration:\n\n1. **Protocol Support**\n   - More protocols\n   - Better handling\n   - Clean integration\n   - Performance optimization\n\n2. **Format Support**\n   - More formats\n   - Better conversion\n   - Clean integration\n   - Performance optimization\n"},"core/integration/modules/hb_beamr_io.md":{"content":"# Module: hb_beamr_io\n\n## Basic Information\n- **Source File:** hb_beamr_io.erl\n- **Module Type:** Integration\n- **Purpose:** WASM Memory Management Interface\n\n## Purpose\nProvides a comprehensive interface for managing memory in WASM instances through BEAMR. Unlike typical HyperBEAM modules, it takes a defensive approach to type checking on the Erlang side rather than in C/WASM, ensuring robust memory operations and early error detection.\n\n## Interface\n\n### Core Operations\n- `size/1` - Get WASM instance memory size\n- `read/3` - Read memory at offset\n- `write/3` - Write memory at offset\n- `read_string/2, read_string/3` - Read null-terminated string\n- `write_string/2` - Write null-terminated string\n- `malloc/2` - Allocate WASM memory\n- `free/2` - Free WASM memory\n\n## Dependencies\n\n### Direct Dependencies\n- hb_beamr: WASM execution interface\n- file: File operations for tests\n- binary: Binary manipulation\n- iolist: String handling\n\n### Inverse Dependencies\n- Used by WASM-dependent modules\n- Memory management provider\n- Resource allocation service\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Memory Size Management**\n   ```erlang\n   % Get WASM memory size\n   size(WASM) when is_pid(WASM) ->\n       hb_beamr:wasm_send(WASM, {command, term_to_binary({size})}),\n       receive\n           {execution_result, Size} ->\n               {ok, Size}\n       end.\n   ```\n   Important characteristics:\n   - Fixed page size (65,536 bytes)\n   - No memory reduction\n   - Growth-only allocation\n   - Size tracking\n\n2. **Memory Operations**\n   ```erlang\n   % Memory write with bounds checking\n   write(WASM, Offset, Data)\n           when is_pid(WASM)\n           andalso is_binary(Data)\n           andalso is_integer(Offset) ->\n       hb_beamr:wasm_send(WASM, {command, term_to_binary({write, Offset, Data})}),\n       receive\n           ok -> ok;\n           {error, Error} -> {error, Error}\n       end.\n   ```\n   Features:\n   - Type validation\n   - Bounds checking\n   - Error handling\n   - Safe operations\n\n3. **String Handling**\n   ```erlang\n   % String write with null termination\n   write_string(WASM, Data) when is_pid(WASM) andalso is_binary(Data) ->\n       DataSize = byte_size(Data) + 1,\n       String = <<Data/bitstring, 0:8>>,\n       case malloc(WASM, DataSize) of\n           {ok, Ptr} ->\n               case write(WASM, Ptr, String) of\n                   ok -> {ok, Ptr};\n                   {error, Error} -> {error, Error}\n               end;\n           Error -> Error\n       end.\n   ```\n   Provides:\n   - Null termination\n   - Memory allocation\n   - Error handling\n   - Resource cleanup\n\n### State Management\n\n1. **Memory Allocation**\n   ```erlang\n   % Memory allocation with validation\n   malloc(WASM, Size) when is_pid(WASM) andalso is_integer(Size) ->\n       case hb_beamr:call(WASM, \"malloc\", [Size]) of\n           {ok, [0]} ->\n               {error, malloc_failed};\n           {ok, [Ptr]} ->\n               {ok, Ptr};\n           {error, Error} ->\n               {error, Error}\n       end.\n   ```\n   Handles:\n   - Size validation\n   - Pointer management\n   - Error handling\n   - Resource tracking\n\n2. **Memory Deallocation**\n   ```erlang\n   % Memory deallocation with validation\n   free(WASM, Ptr) when is_pid(WASM) andalso is_integer(Ptr) ->\n       case hb_beamr:call(WASM, \"free\", [Ptr]) of\n           {ok, Res} ->\n               ok;\n           {error, Error} ->\n               {error, Error}\n       end.\n   ```\n   Manages:\n   - Pointer validation\n   - Resource cleanup\n   - Error handling\n   - State tracking\n\n### Error Handling\n\n1. **Type Validation**\n   ```erlang\n   % Defensive type checking\n   read(WASM, Offset, Size)\n           when is_pid(WASM)\n           andalso is_integer(Offset)\n           andalso is_integer(Size) ->\n   ```\n   Ensures:\n   - Valid types\n   - Safe operations\n   - Early failures\n   - Clear errors\n\n2. **Operation Errors**\n   ```erlang\n   % Error propagation\n   case write(WASM, Ptr, String) of\n       ok -> {ok, Ptr};\n       {error, Error} -> {error, Error}\n   end\n   ```\n   Handles:\n   - Operation failures\n   - Resource errors\n   - State corruption\n   - Clean recovery\n\n## Integration Points\n\n1. **WASM System**\n   - Memory allocation\n   - Resource management\n   - State tracking\n   - Error handling\n\n2. **String System**\n   - Null termination\n   - Chunked reading\n   - Buffer management\n   - Resource cleanup\n\n3. **Resource System**\n   - Memory tracking\n   - Pointer management\n   - State validation\n   - Error handling\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Memory Management**\n   ```erlang\n   % Chunked string reading\n   read_string(WASM, Offset, ChunkSize) ->\n       {ok, Data} = read(WASM, Offset, ChunkSize),\n       case binary:split(Data, [<<0>>]) of\n           [Data|[]] -> [Data|read_string(WASM, Offset + ChunkSize, ChunkSize)];\n           [FinalData|_] -> [FinalData]\n       end.\n   ```\n   Features:\n   - Efficient chunking\n   - Smart allocation\n   - Resource reuse\n   - Memory safety\n\n2. **Operation Efficiency**\n   ```erlang\n   % Page size constants\n   WASMPageSize = 65536,\n   File1Pages = 1,\n   File2Pages = 193\n   ```\n   Considerations:\n   - Fixed page sizes\n   - Growth patterns\n   - Memory limits\n   - Resource usage\n\n### Security Implications\n\n1. **Memory Protection**\n   - Bounds checking\n   - Type validation\n   - Resource isolation\n   - Error handling\n\n2. **Resource Safety**\n   - Pointer validation\n   - Memory cleanup\n   - State protection\n   - Error containment\n\n### Best Practices\n\n1. **Memory Operations**\n   ```erlang\n   % Recommended memory handling\n   handle_memory(WASM, Data) ->\n       case write_string(WASM, Data) of\n           {ok, Ptr} ->\n               process_data(WASM, Ptr),\n               free(WASM, Ptr);\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n2. **String Management**\n   ```erlang\n   % Recommended string handling\n   process_string(WASM, String) ->\n       {ok, Ptr} = write_string(WASM, String),\n       try\n           handle_string(WASM, Ptr)\n       after\n           free(WASM, Ptr)\n       end.\n   ```\n\n3. **Resource Management**\n   ```erlang\n   % Recommended resource handling\n   manage_resources(WASM, Size) ->\n       case malloc(WASM, Size) of\n           {ok, Ptr} ->\n               try\n                   use_memory(WASM, Ptr, Size)\n               after\n                   free(WASM, Ptr)\n               end;\n           Error ->\n               handle_error(Error)\n       end.\n   ```\n\n### Example Usage\n\n```erlang\n% Initialize WASM instance\n{ok, WASM, _, _} = hb_beamr:start(WasmBinary),\n\n% Get memory size\n{ok, Size} = hb_beamr_io:size(WASM),\n\n% Write string to memory\n{ok, Ptr} = hb_beamr_io:write_string(WASM, <<\"Hello World\">>),\n\n% Read string from memory\n{ok, String} = hb_beamr_io:read_string(WASM, Ptr),\n\n% Allocate memory\n{ok, NewPtr} = hb_beamr_io:malloc(WASM, 1024),\n\n% Write to memory\nok = hb_beamr_io:write(WASM, NewPtr, Data),\n\n% Read from memory\n{ok, Data} = hb_beamr_io:read(WASM, NewPtr, 1024),\n\n% Free memory\nok = hb_beamr_io:free(WASM, NewPtr)\n```\n\n## Memory Operation Flow\n\n```mermaid\ngraph TD\n    A[Memory Request] -->|Validate| B{Type Check}\n    B -->|Pass| C[Operation]\n    B -->|Fail| D[Error]\n    \n    C -->|Execute| E{Bounds Check}\n    E -->|Pass| F[Success]\n    E -->|Fail| D\n    \n    subgraph \"Memory Management\"\n        G[Allocation]\n        H[Deallocation]\n    end\n    \n    C --> G\n    C --> H\n```\n\n## String Operation Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant IO as BEAMR IO\n    participant WASM as WASM Instance\n    participant Mem as Memory\n\n    App->>IO: write_string(Data)\n    IO->>WASM: malloc(Size)\n    WASM->>Mem: Allocate\n    Mem-->>WASM: Pointer\n    WASM-->>IO: {ok, Ptr}\n    \n    IO->>WASM: write(Ptr, Data)\n    WASM->>Mem: Write\n    Mem-->>WASM: ok\n    WASM-->>IO: ok\n    \n    IO-->>App: {ok, Ptr}\n"}}