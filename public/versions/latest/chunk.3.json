{"core/message_protocol/modules/hb_singleton.md":{"content":"# Module: hb_singleton\n\n## Basic Information\n- **Source File:** hb_singleton.erl\n- **Module Type:** Core Message Protocol\n- **Behavior:** None\n\n## Purpose\nParser that translates AO-Core HTTP API requests in TABM format into an ordered list of messages to evaluate. Handles complex path syntax and message transformations.\n\n## Interface\n\n### Core Functions\n- `from/1` - Convert singleton TABM message to list of executable AO-Core messages\n- `to/1` - Convert list of AO-Core messages into TABM message\n\n## Dependencies\n\n### Direct Dependencies\n- hb_message: Message handling\n- hb_util: Utility functions\n- cowboy_req: HTTP request parsing\n- uri_string: URL decoding\n\n### Inverse Dependencies\n- Used by HTTP API handlers\n- Core component for API requests\n- Essential for message routing\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Path Syntax**\n   ```\n   /Part1/Part2/.../PartN/    => [Part1, Part2, ..., PartN]\n   /ID/Part2/.../PartN        => [ID, Part2, ..., PartN]\n   ```\n\n2. **Part Syntax**\n   ```\n   Part                       => #{path => Part}\n   Part&Key=Value            => #{path => Part, Key => Value}\n   Part&Key                  => #{path => Part, Key => true}\n   Part&k1=v1&k2=v2         => #{path => Part, k1 => \"v1\", k2 => \"v2\"}\n   Part~Device              => {as, Device, #{path => Part}}\n   Part~D&K1=V1            => {as, D, #{path => Part, K1 => \"v1\"}}\n   pt&k1+int=1             => #{path => pt, k1 => 1}\n   pt~d&k1+int=1           => {as, d, #{path => pt, k1 => 1}}\n   (/nested/path)          => Resolution of /nested/path\n   (/nested/path&k1=v1)    => (resolve /nested/path)#{k1 => v1}\n   pt&k1+res=(/a/b/c)     => #{path => pt, k1 => (resolve /a/b/c)}\n   ```\n\n3. **Key Syntax**\n   ```\n   key: \"value\"             => #{key => \"value\"} for all messages\n   n.key: \"value\"          => #{key => \"value\"} for Nth message\n   key+Int: 1              => #{key => 1}\n   key+Res: /nested/path   => #{key => (resolve /nested/path)}\n   N.Key+Res=(/a/b/c)     => #{Key => (resolve /a/b/c)}\n   ```\n\n### State Management\n\n1. **Path Processing**\n   - Parses relative references\n   - Handles query parameters\n   - Manages path segments\n   - Validates segment length\n\n2. **Message Building**\n   - Merges base messages\n   - Applies scoped modifications\n   - Handles device specifiers\n   - Manages typed values\n\n3. **Type Handling**\n   - Integer conversion\n   - Binary handling\n   - Resolution types\n   - Value validation\n\n### Error Handling\n\n1. **Path Validation**\n   - Checks segment length\n   - Validates syntax\n   - Handles malformed paths\n   - Manages encoding errors\n\n2. **Type Conversion**\n   - Validates type specifiers\n   - Handles conversion errors\n   - Manages invalid values\n   - Scope validation\n\n## Integration Points\n\n1. **HTTP System**\n   - Request parsing\n   - Path handling\n   - Query parameters\n   - Message conversion\n\n2. **Message System**\n   - TABM format\n   - AO-Core messages\n   - Message transformation\n   - State management\n\n3. **Device System**\n   - Device specifiers\n   - Message routing\n   - Resolution handling\n   - Type conversion\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Path Processing**\n   - Efficient parsing\n   - Minimal allocations\n   - Optimized splitting\n   - Cached results\n\n2. **Message Building**\n   - Efficient merging\n   - Smart type handling\n   - Minimal copying\n   - Optimized conversion\n\n### Security Implications\n\n1. **Path Validation**\n   - Length limits\n   - Syntax checking\n   - Encoding validation\n   - Safe decoding\n\n2. **Type Safety**\n   - Value validation\n   - Safe conversion\n   - Scope checking\n   - Error handling\n\n### Best Practices\n\n1. **Path Construction**\n   - Use clear paths\n   - Validate segments\n   - Handle encoding\n   - Check lengths\n\n2. **Message Handling**\n   - Validate types\n   - Check scopes\n   - Handle errors\n   - Manage state\n"},"core/message_protocol/observations.md":{"content":"# Observations: Message & Protocol Chunk\n\n## Patterns Identified\n\n1. **Message Transformation Pattern**\n   - All modules contribute to message transformation pipeline\n   - Clear separation between different message formats\n   - Consistent use of TABM as intermediate format\n   - Strong typing and validation throughout\n\n2. **Protocol Integration Pattern**\n   - Layered approach to protocol implementation\n   - Clear separation of concerns between modules\n   - Consistent error handling and validation\n   - Flexible device integration system\n\n3. **State Management Pattern**\n   - Private state handled separately from public\n   - Temporary state for caching and optimization\n   - Clear state transition rules\n   - Consistent state validation\n\n4. **Path Handling Pattern**\n   - Unified path representation\n   - Flexible path syntax\n   - Efficient path manipulation\n   - Strong path validation\n\n## Integration Insights\n\n1. **Module Relationships**\n   ```mermaid\n   graph TD\n      hb_message[hb_message] --> hb_path[hb_path]\n      hb_message --> hb_ao[hb_ao]\n      hb_message --> hb_private[hb_private]\n      hb_singleton[hb_singleton] --> hb_message\n      hb_ao --> hb_path\n      hb_ao --> hb_private\n      hb_private --> hb_path\n   ```\n\n2. **Data Flow**\n   ```mermaid\n   graph LR\n      HTTP[HTTP Request] --> Singleton[hb_singleton]\n      Singleton --> TABM[TABM Format]\n      TABM --> Message[hb_message]\n      Message --> Device[Device System]\n      Device --> Response[Response]\n   ```\n\n3. **State Flow**\n   ```mermaid\n   graph TD\n      Public[Public State] --> Private[Private State]\n      Private --> Cache[Cache State]\n      Cache --> Temporary[Temporary State]\n      Temporary --> Result[Result State]\n   ```\n\n## Evolution Notes\n\n1. **Architecture Evolution**\n   - Started with simple message passing\n   - Evolved to support complex transformations\n   - Added HTTP API support\n   - Integrated device system\n\n2. **Protocol Evolution**\n   - Basic message protocol\n   - Added path-based routing\n   - Introduced device system\n   - Added HTTP API layer\n\n3. **Performance Evolution**\n   - Optimized message handling\n   - Improved caching system\n   - Enhanced state management\n   - Refined path processing\n\n## Special Considerations\n\n1. **Security Aspects**\n   - Message validation\n   - Path sanitization\n   - State isolation\n   - Type safety\n   - Access control\n\n2. **Performance Aspects**\n   - Message transformation efficiency\n   - Path processing optimization\n   - State management overhead\n   - Cache utilization\n\n3. **Maintenance Aspects**\n   - Clear module boundaries\n   - Consistent interfaces\n   - Well-documented patterns\n   - Strong test coverage\n\n4. **Integration Aspects**\n   - HTTP API compatibility\n   - Device system integration\n   - Protocol versioning\n   - State synchronization\n\n## Key Findings\n\n1. **Core Strengths**\n   - Strong message transformation system\n   - Flexible path handling\n   - Efficient state management\n   - Clear protocol implementation\n\n2. **Potential Improvements**\n   - Enhanced error handling\n   - More detailed validation\n   - Better performance monitoring\n   - Extended documentation\n\n3. **Critical Components**\n   - Message transformation\n   - Path processing\n   - State management\n   - Protocol handling\n\n4. **Future Considerations**\n   - Protocol extensions\n   - Performance optimizations\n   - Security enhancements\n   - Documentation improvements\n"},"core/message_protocol/OVERVIEW.md":{"content":"# Overview: Message & Protocol Chunk\n\n## Purpose\nThe Message & Protocol chunk forms the core of HyperBEAM's message processing system. It provides a sophisticated pipeline for transforming, routing, and managing messages across different formats and protocols. This chunk is essential for enabling communication between different parts of the system while maintaining message integrity and state consistency.\n\n## System Architecture\n\n```mermaid\ngraph TD\n    subgraph \"External Interface\"\n        HTTP[HTTP API]\n        Device[Device System]\n        Storage[Storage System]\n    end\n\n    subgraph \"Message Processing\"\n        hb_singleton[hb_singleton]\n        hb_message[hb_message]\n        hb_path[hb_path]\n        hb_ao[hb_ao]\n        hb_private[hb_private]\n    end\n\n    HTTP --> hb_singleton\n    hb_singleton --> hb_message\n    hb_message --> hb_path\n    hb_message --> hb_ao\n    hb_message --> hb_private\n    hb_ao --> Device\n    hb_ao --> hb_path\n    hb_ao --> hb_private\n    hb_private --> Storage\n    hb_private --> hb_path\n```\n\n## Core Components\n\n### 1. Message Transformation Pipeline\nThe message transformation system starts with hb_singleton, which acts as the entry point for HTTP API requests. It parses complex path syntax and query parameters into a standardized format. The message then flows through hb_message, which converts between different message formats using TABM (Type Annotated Binary Messages) as an intermediate representation. This allows seamless conversion between formats like Arweave transactions, ANS-104 data items, and HTTP signed messages.\n\nFor example, when an HTTP request arrives:\n```erlang\n% HTTP Request: /compute/data?format=json\n% Gets transformed by hb_singleton into:\n#{ \n    <<\"path\">> => [<<\"compute\">>, <<\"data\">>],\n    <<\"format\">> => <<\"json\">>\n}\n% Then processed by hb_message into TABM format\n```\n\n### 2. Path Resolution System\nThe path system, implemented in hb_path, handles three types of paths:\n1. Request Paths: Used for routing messages to their destinations\n2. HashPaths: Track message history and ensure integrity\n3. Private Paths: Manage internal state and caching\n\nEach path type serves a specific purpose. For instance, HashPaths create a verifiable history of message transformations:\n```erlang\n% Message transformation creates a HashPath:\nMsg1.HashPath = Hash(Msg1.ID)\nMsg2.HashPath = Hash(Msg1.HashPath, Msg2.ID)\nMsg3.HashPath = Hash(Msg2.HashPath, Msg3.ID)\n```\n\n### 3. Device Integration System\nThe hb_ao module serves as the core of the device system. It implements the AO-Core protocol by:\n1. Resolving device functions based on message paths\n2. Managing device state and execution\n3. Handling device loading and verification\n4. Coordinating message routing\n\nFor example, when resolving a device function:\n```erlang\n% Given a message with path \"compute\"\n{ok, DeviceMod} = hb_ao:message_to_device(Msg)\n{ok, Function} = hb_ao:message_to_fun(Msg, <<\"compute\">>, Opts)\nResult = apply(DeviceMod, Function, [Msg, Opts])\n```\n\n### 4. State Management System\nThe hb_private module manages message state that shouldn't be exposed or serialized. This includes:\n1. Temporary computation results\n2. Caching information\n3. Internal routing state\n4. Performance optimizations\n\nState is carefully isolated:\n```erlang\n% Private state is stored separately\nMsg = #{\n    <<\"public\">> => PublicData,\n    <<\"priv\">> => #{\n        <<\"cache\">> => CacheData,\n        <<\"temp\">> => TempState\n    }\n}\n```\n\n## Integration Points\n\n### 1. HTTP API Integration\nThe system integrates with HTTP APIs through hb_singleton, which provides:\n1. Rich path syntax for complex operations\n2. Query parameter handling\n3. Type conversion\n4. Device routing\n\nExample path syntax:\n```\n/part1/part2~device&key=value  => Route through 'device' with parameters\n/part1/(nested/path)           => Resolve nested path first\n/part1&key+type=value         => Apply type conversion to value\n```\n\n### 2. Device System Integration\nDevices integrate through hb_ao using:\n1. Function resolution based on message paths\n2. State management through private data\n3. Caching and optimization support\n4. Error handling and recovery\n\n### 3. Storage System Integration\nStorage integration happens through:\n1. Cache management in private state\n2. HashPath tracking for message history\n3. State persistence when needed\n4. Efficient retrieval mechanisms\n\n## Protocol Implementation\n\nThe AO-Core protocol is implemented through several layers:\n\n1. **Message Layer** (hb_message)\n   - Format conversion\n   - Message validation\n   - State management\n   - Type safety\n\n2. **Path Layer** (hb_path)\n   - Path resolution\n   - History tracking\n   - State routing\n   - Validation\n\n3. **Device Layer** (hb_ao)\n   - Function resolution\n   - State coordination\n   - Error handling\n   - Device management\n\n4. **State Layer** (hb_private)\n   - Private data\n   - Caching\n   - Temporary state\n   - Optimization\n\n## Best Practices\n\nWhen working with this system:\n\n1. **Message Handling**\n   - Always validate message formats before processing\n   - Use appropriate message types for different operations\n   - Handle errors at each transformation step\n   - Maintain message integrity through transformations\n\n2. **Path Processing**\n   - Validate paths before resolution\n   - Use appropriate path types for different operations\n   - Handle path encoding carefully\n   - Maintain path integrity\n\n3. **State Management**\n   - Keep private state isolated\n   - Use caching appropriately\n   - Handle state transitions carefully\n   - Validate state at boundaries\n\n4. **Device Integration**\n   - Implement proper device interfaces\n   - Handle device errors appropriately\n   - Manage device state carefully\n   - Follow protocol specifications\n"},"core/network_http/modules/hb_gateway_client.md":{"content":"# Module: hb_gateway_client\n\n## Basic Information\n- **Source File:** hb_gateway_client.erl\n- **Module Type:** Core Network & HTTP\n- **Purpose:** Arweave GraphQL API client for data retrieval\n\n## Purpose\nImplements Arweave's GraphQL API to access data items stored on the network. This module is essential for retrieving full HyperBEAM `structured@1.0` form messages from Arweave, as gateways currently don't expose all necessary fields outside the GraphQL API. The module will be deprecated once gateways integrate serving in `httpsig@1.0` form.\n\n## Interface\n\n### Raw Access Operations\n- `read/2` - Get data item by ID including data and tags\n- `data/2` - Get raw data associated with transaction ID\n- `result_to_message/2` - Convert GraphQL result to message format\n\n### Application Operations\n- `scheduler_location/2` - Find scheduler location by address\n\n## Dependencies\n\n### Direct Dependencies\n- hb_http: HTTP request handling\n- hb_json: JSON encoding/decoding\n- hb_ao: Core operations\n- ar_bundles: ANS-104 bundle handling\n- dev_codec_ans104: ANS-104 codec\n- dev_codec_structured: Structured codec\n\n### Inverse Dependencies\n- Used by gateway integration components\n- Used by scheduler location services\n- Core Arweave data access provider\n\n## Implementation Details\n\n### Key Concepts\n\n1. **GraphQL Schema**\n   ```graphql\n   type Transaction {\n     id: ID!\n     anchor: String!\n     signature: String!\n     recipient: String!\n     owner: Owner { address: String! key: String! }!\n     fee: Amount!\n     quantity: Amount!\n     data: MetaData!\n     tags: [Tag { name: String! value: String! }!]!\n   }\n   ```\n\n2. **Data Retrieval**\n   ```erlang\n   % GraphQL query execution\n   query(Query, Opts) ->\n       hb_http:request(#{\n           <<\"method\">> => <<\"POST\">>,\n           <<\"path\">> => <<\"/graphql\">>,\n           <<\"content-type\">> => <<\"application/json\">>,\n           <<\"body\">> => hb_json:encode(Query)\n       }, Opts)\n   ```\n\n3. **Message Conversion**\n   ```erlang\n   % Convert GraphQL result to ANS-104 format\n   result_to_message(ExpectedID, Item, Opts) ->\n       % Extract data and tags\n       Data = get_data(ExpectedID, Item, Opts),\n       Tags = get_tags(Item, Opts),\n       \n       % Create ANS-104 transaction\n       TX = create_ans104_tx(ExpectedID, Item, Data, Tags),\n       \n       % Convert to structured format\n       TABM = dev_codec_ans104:from(TX),\n       Structured = dev_codec_structured:to(TABM)\n   ```\n\n### State Management\n\n1. **Query State**\n   - GraphQL queries\n   - Response handling\n   - Data validation\n   - Error management\n\n2. **Data State**\n   - Raw data retrieval\n   - Format conversion\n   - State verification\n   - Error handling\n\n3. **Message State**\n   - Format conversion\n   - State tracking\n   - Verification\n   - Error handling\n\n### Error Handling\n\n1. **GraphQL Errors**\n   - Query failures\n   - Response validation\n   - Data verification\n   - State recovery\n\n2. **Gateway Errors**\n   - Connection failures\n   - Data retrieval errors\n   - Format errors\n   - State verification\n\n## Integration Points\n\n1. **Arweave Network**\n   - GraphQL API\n   - Gateway access\n   - Data retrieval\n   - State verification\n\n2. **Message System**\n   - Format conversion\n   - State tracking\n   - Error handling\n   - Data validation\n\n3. **Scheduler System**\n   - Location lookup\n   - State tracking\n   - Error handling\n   - Data validation\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Data Retrieval**\n   - Query optimization\n   - Response caching\n   - State management\n   - Error handling\n\n2. **Message Processing**\n   - Format conversion\n   - State tracking\n   - Resource usage\n   - Error recovery\n\n### Security Implications\n\n1. **Data Verification**\n   - Message signing\n   - State validation\n   - Trust management\n   - Error isolation\n\n2. **Gateway Trust**\n   - Trust configuration\n   - Data validation\n   - State verification\n   - Error handling\n\n### Best Practices\n\n1. **GraphQL Usage**\n   - Query optimization\n   - Response handling\n   - Error management\n   - State tracking\n\n2. **Data Handling**\n   - Format validation\n   - State verification\n   - Error handling\n   - Resource cleanup\n\n3. **Integration**\n   - API usage\n   - Error handling\n   - State management\n   - Resource cleanup\n\n### Example Usage\n\n```erlang\n% Read data item by ID\n{ok, Message} = hb_gateway_client:read(\n    <<\"0Tb9mULcx8MjYVgXleWMVvqo1_jaw_P6AO_CJMTj0XE\">>,\n    #{}\n),\n\n% Get scheduler location\n{ok, Location} = hb_gateway_client:scheduler_location(\n    <<\"fcoN_xJeisVsPXA-trzVAuIiqO3ydLQxM-L4XbrQKzY\">>,\n    #{}\n),\n\n% Get raw data by ID\n{ok, Data} = hb_gateway_client:data(\n    <<\"0Tb9mULcx8MjYVgXleWMVvqo1_jaw_P6AO_CJMTj0XE\">>,\n    #{}\n),\n\n% Convert GraphQL result to message\n{ok, Message} = hb_gateway_client:result_to_message(\n    <<\"0Tb9mULcx8MjYVgXleWMVvqo1_jaw_P6AO_CJMTj0XE\">>,\n    GraphQLResult,\n    #{}\n)\n"},"core/network_http/modules/hb_http_client_sup.md":{"content":"# Module: hb_http_client_sup\n\n## Basic Information\n- **Source File:** hb_http_client_sup.erl\n- **Module Type:** Core Network & HTTP\n- **Purpose:** Supervisor for the Gun HTTP client wrapper\n\n## Purpose\nProvides supervision for the HTTP client (hb_http_client) using OTP supervisor behavior. This module ensures proper lifecycle management and fault tolerance for the HTTP client process, with configurable shutdown timeouts based on build environment.\n\n## Interface\n\n### Core Operations\n- `start_link/1` - Start supervisor with configuration options\n- `init/1` - Initialize supervisor with child specifications\n\n### Configuration\n- `SHUTDOWN_TIMEOUT` - Configurable timeout (30s prod, 10s debug)\n- `CHILD` macro - Child specification template\n\n## Dependencies\n\n### Direct Dependencies\n- supervisor: OTP supervisor behavior\n- hb_http_client: HTTP client worker\n\n### Inverse Dependencies\n- Used by HyperBEAM supervision tree\n- Core HTTP client lifecycle management\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Supervision Strategy**\n   ```erlang\n   % One-for-one restart strategy with limits\n   {ok, {{one_for_one, 5, 10}, [\n       % Single HTTP client worker\n       ?CHILD(hb_http_client, worker, Opts)\n   ]}}\n   ```\n\n2. **Child Specification**\n   ```erlang\n   % Child specification macro\n   -define(CHILD(I, Type, Opts), {\n       I,                          % Child ID\n       {I, start_link, Opts},      % Start function\n       permanent,                  % Restart strategy\n       ?SHUTDOWN_TIMEOUT,         % Shutdown timeout\n       Type,                      % Process type\n       [I]                        % Modules\n   }).\n   ```\n\n3. **Environment Awareness**\n   ```erlang\n   % Debug vs Production timeout\n   -ifdef(DEBUG).\n   -define(SHUTDOWN_TIMEOUT, 10000).\n   -else.\n   -define(SHUTDOWN_TIMEOUT, 30000).\n   -endif.\n   ```\n\n### State Management\n\n1. **Supervisor State**\n   - Child specifications\n   - Restart strategy\n   - Process monitoring\n   - Error handling\n\n2. **Child State**\n   - Worker process\n   - Configuration options\n   - Lifecycle management\n   - Error recovery\n\n3. **System State**\n   - Process registration\n   - Resource management\n   - Error handling\n   - State recovery\n\n### Error Handling\n\n1. **Supervisor Errors**\n   - Child process failures\n   - Restart limits\n   - Resource cleanup\n   - State recovery\n\n2. **Child Errors**\n   - Process crashes\n   - Shutdown handling\n   - Resource cleanup\n   - State verification\n\n## Integration Points\n\n1. **Supervision Tree**\n   - Process hierarchy\n   - Lifecycle management\n   - Error propagation\n   - State coordination\n\n2. **HTTP Client**\n   - Process supervision\n   - Configuration management\n   - Error handling\n   - Resource cleanup\n\n3. **System Integration**\n   - Process registration\n   - Resource management\n   - Error handling\n   - State coordination\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Process Management**\n   - Restart strategies\n   - Resource usage\n   - State handling\n   - Error recovery\n\n2. **Configuration Impact**\n   - Timeout settings\n   - Restart limits\n   - Resource allocation\n   - Error handling\n\n### Security Implications\n\n1. **Process Isolation**\n   - Error containment\n   - Resource protection\n   - State isolation\n   - Access control\n\n2. **System Protection**\n   - Resource limits\n   - Error boundaries\n   - State protection\n   - Process isolation\n\n### Best Practices\n\n1. **Supervision Strategy**\n   - Use one_for_one for independent processes\n   - Configure appropriate restart limits\n   - Set proper shutdown timeouts\n   - Handle errors gracefully\n\n2. **Configuration Management**\n   - Use environment-specific settings\n   - Configure appropriate timeouts\n   - Set resource limits\n   - Handle errors properly\n\n3. **Integration**\n   - Follow OTP principles\n   - Use proper process registration\n   - Handle errors appropriately\n   - Manage resources carefully\n\n### Example Usage\n\n```erlang\n% Start supervisor with configuration\n{ok, Pid} = hb_http_client_sup:start_link(#{\n    http_connect_timeout => 5000,\n    http_request_send_timeout => 30000,\n    http_keepalive => 60000\n}),\n\n% Supervisor automatically manages HTTP client:\n% - Starts hb_http_client worker\n% - Monitors process for failures\n% - Restarts on crashes (up to 5 times in 10 seconds)\n% - Ensures proper shutdown with timeout\n% - Maintains process registration\n"},"core/network_http/modules/hb_http_client.md":{"content":"# Module: hb_http_client\n\n## Basic Information\n- **Source File:** hb_http_client.erl\n- **Module Type:** Core Network & HTTP\n- **Purpose:** HTTP client implementation with connection management and metrics\n\n## Purpose\nA sophisticated HTTP client that wraps both Gun and httpc libraries, providing connection pooling, metrics tracking, and robust error handling. Originally from the Arweave project and modified for HyperBEAM, it manages persistent connections and provides detailed monitoring capabilities through Prometheus.\n\n## Interface\n\n### Core Operations\n- `start_link/1` - Start client gen_server\n- `req/2` - Make HTTP request with options\n- `init/1` - Initialize gen_server state\n\n### Connection Management\n- `get_connection/3` - Get or establish connection\n- `open_connection/2` - Create new connection\n- `parse_peer/2` - Parse peer information\n\n### Request Handling\n- `gun_req/3` - Handle Gun-based request\n- `httpc_req/3` - Handle httpc-based request\n- `request/3` - Process request with metrics\n\n## Dependencies\n\n### Direct Dependencies\n- gun: HTTP/2 client\n- httpc: HTTP/1.1 client\n- prometheus: Metrics collection\n- gen_server: OTP behavior\n- ar_rate_limiter: Rate limiting\n\n### Inverse Dependencies\n- Used by hb_http\n- Used by hb_gateway_client\n- Core HTTP client functionality\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Connection Management**\n   ```erlang\n   % Connection state record\n   -record(state, {\n       pid_by_peer = #{},      % Map of peer to connection PID\n       status_by_pid = #{},    % Map of PID to connection status\n       opts = #{}             % Configuration options\n   }).\n   ```\n\n2. **Request Processing**\n   ```erlang\n   % Request handling with metrics\n   gun_req(Args, ReestablishedConnection, Opts) ->\n       StartTime = erlang:monotonic_time(),\n       Response = handle_request(Args, ReestablishedConnection, Opts),\n       EndTime = erlang:monotonic_time(),\n       record_metrics(Method, Path, Response, EndTime - StartTime)\n   ```\n\n3. **Protocol Support**\n   ```erlang\n   % Protocol selection\n   case hb_opts:get(http_client, gun, Opts) of\n       gun -> gun_req(Args, ReestablishedConnection, Opts);\n       httpc -> httpc_req(Args, ReestablishedConnection, Opts)\n   end\n   ```\n\n### State Management\n\n1. **Connection State**\n   - Connection tracking\n   - Status management\n   - Peer mapping\n   - Error handling\n\n2. **Request State**\n   - Request tracking\n   - Response handling\n   - Metrics collection\n   - Error recovery\n\n3. **Protocol State**\n   - Protocol selection\n   - Connection handling\n   - State verification\n   - Error management\n\n### Error Handling\n\n1. **Connection Errors**\n   - Connection failures\n   - Timeout handling\n   - Protocol errors\n   - State recovery\n\n2. **Request Errors**\n   - Response errors\n   - Protocol errors\n   - Timeout handling\n   - State verification\n\n## Integration Points\n\n1. **HTTP Libraries**\n   - Gun integration\n   - httpc integration\n   - Protocol handling\n   - State management\n\n2. **Metrics System**\n   - Prometheus metrics\n   - Request tracking\n   - Performance monitoring\n   - Error tracking\n\n3. **Rate Limiting**\n   - Request throttling\n   - Resource management\n   - Error handling\n   - State tracking\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Connection Management**\n   - Connection pooling\n   - State tracking\n   - Resource usage\n   - Error recovery\n\n2. **Request Handling**\n   - Protocol selection\n   - Response handling\n   - Metrics collection\n   - Resource cleanup\n\n### Security Implications\n\n1. **Connection Security**\n   - Protocol security\n   - State protection\n   - Error isolation\n   - Resource management\n\n2. **Request Security**\n   - Input validation\n   - Response verification\n   - Error handling\n   - State protection\n\n### Best Practices\n\n1. **Connection Usage**\n   - Pool management\n   - Error handling\n   - State tracking\n   - Resource cleanup\n\n2. **Request Handling**\n   - Protocol selection\n   - Error management\n   - Metrics tracking\n   - Resource cleanup\n\n3. **Integration**\n   - Library usage\n   - Protocol support\n   - Error handling\n   - Resource management\n\n### Example Usage\n\n```erlang\n% Start HTTP client\n{ok, _Pid} = hb_http_client:start_link(#{\n    http_connect_timeout => 5000,\n    http_request_send_timeout => 30000,\n    http_keepalive => 60000\n}),\n\n% Make HTTP request with Gun\n{ok, Status, Headers, Body} = hb_http_client:req(#{\n    peer => <<\"http://localhost:8080\">>,\n    path => <<\"/api/data\">>,\n    method => <<\"GET\">>,\n    headers => #{<<\"accept\">> => <<\"application/json\">>}\n}, #{http_client => gun}),\n\n% Make HTTP request with httpc\n{ok, Status, Headers, Body} = hb_http_client:req(#{\n    peer => <<\"http://localhost:8080\">>,\n    path => <<\"/api/data\">>,\n    method => <<\"POST\">>,\n    headers => #{<<\"content-type\">> => <<\"application/json\">>},\n    body => JsonData\n}, #{http_client => httpc})\n"},"core/network_http/modules/hb_http_server.md":{"content":"# Module: hb_http_server\n\n## Basic Information\n- **Source File:** hb_http_server.erl\n- **Module Type:** Core Network & HTTP\n- **Purpose:** HTTP server router that integrates with AO-Core resolver\n\n## Purpose\nProvides a Cowboy-based HTTP server that acts as a router, converting HTTP requests into AO-Core messages and routing them through the resolver. The server supports both HTTP/2 and HTTP/3 protocols, handles CORS, and provides comprehensive configuration options through an Opts message system.\n\n## Interface\n\n### Server Management\n- `start/0,1` - Start HTTP server with optional configuration\n- `start_node/0,1` - Start server in test/development mode\n- `set_opts/1` - Update server configuration\n- `get_opts/1` - Retrieve server configuration\n\n### Request Handling\n- `init/2` - Cowboy request entry point\n- `handle_request/3` - Process non-CORS requests\n- `allowed_methods/2` - Define allowed HTTP methods\n\n### Configuration\n- `set_default_opts/1` - Set default server options\n- `new_server/1` - Create new server instance\n\n## Dependencies\n\n### Direct Dependencies\n- cowboy: HTTP server framework\n- ranch: Connection handling\n- quicer: HTTP/3 support\n- prometheus: Metrics (optional)\n- hb_http: HTTP request/response handling\n- dev_meta: Request processing\n- hb_tracer: Request tracing\n\n### Inverse Dependencies\n- Used by HyperBEAM node system\n- Core HTTP entry point\n- Message routing system\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Server Configuration**\n   ```erlang\n   % Server initialization with options\n   start(Opts) ->\n       % Ensure required applications\n       application:ensure_all_started([\n           kernel, stdlib, inets, ssl,\n           ranch, cowboy, gun, os_mon\n       ]),\n       % Initialize server\n       BaseOpts = set_default_opts(Opts),\n       {ok, Listener, _Port} = new_server(BaseOpts)\n   ```\n\n2. **Protocol Support**\n   ```erlang\n   % Protocol selection logic\n   case Protocol = hb_opts:get(protocol, DefaultProto, NodeMsg) of\n       http3 -> start_http3(ServerID, ProtoOpts, NodeMsg);\n       Pro when Pro =:= http2; Pro =:= http1 ->\n           start_http2(ServerID, ProtoOpts, NodeMsg)\n   end\n   ```\n\n3. **Request Processing**\n   ```erlang\n   % Convert HTTP to AO-Core message\n   ReqSingleton = hb_http:req_to_tabm_singleton(Req, Body, NodeMsg),\n   % Process through meta device\n   {ok, Res} = dev_meta:handle(NodeMsg, ReqSingleton),\n   % Convert response back to HTTP\n   hb_http:reply(Req, ReqSingleton, Res, NodeMsg)\n   ```\n\n### State Management\n\n1. **Server State**\n   - Configuration options\n   - Protocol selection\n   - Connection handling\n   - Resource management\n\n2. **Request State**\n   - Message conversion\n   - Request tracing\n   - Error handling\n   - Response generation\n\n3. **Protocol State**\n   - HTTP/2 support\n   - HTTP/3 support\n   - CORS handling\n   - Connection management\n\n### Error Handling\n\n1. **Server Errors**\n   - Startup failures\n   - Configuration errors\n   - Protocol errors\n   - Resource errors\n\n2. **Request Errors**\n   - Processing failures\n   - Conversion errors\n   - Tracing errors\n   - Response errors\n\n## Integration Points\n\n1. **HTTP Framework**\n   - Cowboy integration\n   - Protocol handling\n   - Connection management\n   - Request routing\n\n2. **Message System**\n   - Request conversion\n   - Response handling\n   - State management\n   - Error handling\n\n3. **Monitoring System**\n   - Prometheus metrics\n   - Request tracing\n   - Error tracking\n   - Performance monitoring\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Protocol Selection**\n   - HTTP/2 vs HTTP/3\n   - Connection handling\n   - Resource usage\n   - State management\n\n2. **Request Processing**\n   - Message conversion\n   - State tracking\n   - Error handling\n   - Resource cleanup\n\n### Security Implications\n\n1. **Server Security**\n   - Protocol security\n   - Connection handling\n   - State protection\n   - Error isolation\n\n2. **Request Security**\n   - Input validation\n   - State verification\n   - Error handling\n   - Resource protection\n\n### Best Practices\n\n1. **Server Configuration**\n   - Protocol selection\n   - Resource limits\n   - Error handling\n   - State management\n\n2. **Request Handling**\n   - Message validation\n   - State tracking\n   - Error handling\n   - Resource cleanup\n\n3. **Integration**\n   - Framework usage\n   - Protocol support\n   - Error handling\n   - Resource management\n\n### Example Usage\n\n```erlang\n% Start server with default configuration\n{ok, _Listener} = hb_http_server:start(),\n\n% Start with custom configuration\n{ok, _Listener} = hb_http_server:start(#{\n    port => 8080,\n    protocol => http2,\n    prometheus => true,\n    force_signed => true\n}),\n\n% Update server configuration\nhb_http_server:set_opts(#{\n    idle_timeout => 60000,\n    max_connections => 1000\n}),\n\n% Start development node\nURL = hb_http_server:start_node(#{\n    port => 8734,\n    store => #{\n        <<\"store-module\">> => hb_store_fs,\n        <<\"prefix\">> => <<\"cache-dev\">>\n    }\n})\n"},"core/network_http/modules/hb_http.md":{"content":"# Module: hb_http\n\n## Basic Information\n- **Source File:** hb_http.erl\n- **Module Type:** Core Network & HTTP\n- **Purpose:** Core HTTP request/reply functionality for HyperBEAM\n\n## Purpose\nProvides fundamental HTTP communication capabilities for HyperBEAM, handling message-based requests and responses. The module converts between HTTP and HyperBEAM's internal message formats, manages content negotiation, and handles protocol-specific features like CORS and message signing.\n\n## Interface\n\n### Core Operations\n- `get/2,3` - HTTP GET request with message response\n- `post/3,4` - HTTP POST request with message response\n- `request/2,4,5` - Generic HTTP request handling\n- `reply/4` - Generate HTTP response from message\n\n### Protocol Support\n- `accept_to_codec/2` - Content negotiation\n- `req_to_tabm_singleton/3` - Convert HTTP to TABM format\n- `encode_reply/3` - Generate HTTP response format\n\n### Codec Management\n- `mime_to_codec/2` - Convert MIME types to codecs\n- `codec_to_content_type/2` - Get content type for codec\n- `default_codec/1` - Get default codec for options\n\n## Dependencies\n\n### Direct Dependencies\n- httpc: HTTP client operations\n- cowboy: HTTP server handling\n- hb_message: Message processing\n- hb_ao: Core operations\n- dev_codec_httpsig: HTTPSig codec\n- dev_codec_httpsig_conv: HTTPSig conversion\n- ar_bundles: ANS-104 bundle handling\n\n### Inverse Dependencies\n- Used by hb_http_client\n- Used by hb_http_server\n- Used by hb_gateway_client\n- Core HTTP functionality provider\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Message-Based Communication**\n   ```erlang\n   % HTTP GET with message response\n   get(Node, Message, Opts) ->\n       request(<<\"GET\">>, Node, Path, Message, Opts)\n   \n   % HTTP POST with message handling\n   post(Node, Message, Opts) ->\n       request(<<\"POST\">>, Node, Path, Message, Opts)\n   ```\n\n2. **Content Negotiation**\n   ```erlang\n   % Codec selection priority:\n   % 1. accept-codec in message\n   % 2. accept header in request\n   % 3. default codec\n   accept_to_codec(TABMReq, Opts) ->\n       AcceptCodec = maps:get(\n           <<\"accept-codec\">>,\n           TABMReq,\n           mime_to_codec(maps:get(<<\"accept\">>, TABMReq, <<\"*/*\">>), Opts)\n       )\n   ```\n\n3. **Protocol Conversion**\n   ```erlang\n   % Convert HTTP request to TABM format\n   req_to_tabm_singleton(Req, Body, Opts) ->\n       case cowboy_req:header(<<\"codec-device\">>, Req) of\n           <<\"httpsig@1.0\">> -> \n               httpsig_to_tabm_singleton(Req, Body, Opts);\n           <<\"ans104@1.0\">> ->\n               ans104_to_tabm_singleton(Body, Opts)\n       end\n   ```\n\n### State Management\n\n1. **Request State**\n   - Method handling\n   - Path resolution\n   - Header management\n   - Body processing\n\n2. **Response State**\n   - Status codes\n   - Header generation\n   - Body encoding\n   - CORS handling\n\n3. **Protocol State**\n   - Codec selection\n   - Format conversion\n   - Message signing\n   - State verification\n\n### Error Handling\n\n1. **HTTP Errors**\n   - Status codes\n   - Error responses\n   - Protocol errors\n   - State validation\n\n2. **Protocol Errors**\n   - Codec failures\n   - Format errors\n   - Signature validation\n   - State verification\n\n## Integration Points\n\n1. **HTTP Client**\n   - Request handling\n   - Response processing\n   - State management\n   - Error handling\n\n2. **HTTP Server**\n   - Request processing\n   - Response generation\n   - Protocol handling\n   - State management\n\n3. **Message System**\n   - Format conversion\n   - State tracking\n   - Protocol handling\n   - Error management\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Request Handling**\n   - Efficient conversion\n   - State management\n   - Resource usage\n   - Error handling\n\n2. **Response Generation**\n   - Format optimization\n   - Header management\n   - Body encoding\n   - Resource usage\n\n### Security Implications\n\n1. **Message Validation**\n   - Signature verification\n   - Format validation\n   - State verification\n   - Error handling\n\n2. **Protocol Security**\n   - CORS handling\n   - Header validation\n   - State protection\n   - Error isolation\n\n### Best Practices\n\n1. **Request Handling**\n   - Validate inputs\n   - Handle errors\n   - Manage state\n   - Clean resources\n\n2. **Response Generation**\n   - Set proper headers\n   - Handle CORS\n   - Validate state\n   - Clean resources\n\n3. **Protocol Usage**\n   - Use appropriate codecs\n   - Handle signatures\n   - Validate formats\n   - Manage state\n\n### Example Usage\n\n```erlang\n% Basic GET request\n{ok, Response} = hb_http:get(Node, #{\n    <<\"path\">> => <<\"/api/data\">>,\n    <<\"accept\">> => <<\"application/json\">>\n}, Opts),\n\n% POST with message\n{ok, Response} = hb_http:post(Node, #{\n    <<\"path\">> => <<\"/api/compute\">>,\n    <<\"body\">> => Data,\n    <<\"codec-device\">> => <<\"httpsig@1.0\">>\n}, Opts),\n\n% Handle HTTP response\n{ok, Response} = hb_http:reply(Req, TABMReq, #{\n    <<\"status\">> => 200,\n    <<\"body\">> => Result\n}, Opts)\n"},"core/network_http/observations.md":{"content":"# Network & HTTP System Observations\n\n## Architectural Patterns\n\n### 1. Protocol Layering\nThe network system implements clear protocol layering:\n- HTTP/1.1, HTTP/2, HTTP/3 transport protocols (hb_http_server)\n- Message-based request/response abstraction (hb_http)\n- Connection pooling and management (hb_http_client)\n- GraphQL API integration (hb_gateway_client)\n\n### 2. Component Separation\nStrong separation of concerns across components:\n- Server routing and protocol handling (hb_http_server)\n- Client connection management (hb_http_client)\n- Client supervision (hb_http_client_sup)\n- Gateway integration (hb_gateway_client)\n\n### 3. Message-Based Design\nConsistent message-based communication pattern:\n- HTTP requests/responses converted to messages\n- Messages transformed between formats (httpsig, ans104)\n- Message signing and verification\n- Message-based state tracking\n\n## Implementation Patterns\n\n### 1. Error Handling\nComprehensive error handling approach:\n- Connection failures\n- Protocol errors\n- Format conversion errors\n- State verification errors\n- Resource cleanup\n- Error propagation\n\n### 2. State Management\nSophisticated state tracking:\n- Connection pooling\n- Process supervision\n- Message conversion\n- Protocol negotiation\n- Resource management\n\n### 3. Protocol Support\nFlexible protocol implementation:\n- HTTP/1.1 through httpc\n- HTTP/2 through gun\n- HTTP/3 through quicer\n- Protocol negotiation and fallback\n- CORS handling\n\n## Integration Patterns\n\n### 1. External Systems\nWell-defined integration points:\n- Arweave network (GraphQL, gateway)\n- RocksDB storage\n- File system\n- Remote nodes\n- Prometheus metrics\n\n### 2. Internal Systems\nStrong internal cohesion:\n- Message protocol system\n- Storage & caching system\n- Process management\n- Event system\n- Metrics collection\n\n### 3. Development Support\nComprehensive development tools:\n- Request tracing\n- State visualization\n- Performance monitoring\n- Error tracking\n- Resource monitoring\n\n## Key Insights\n\n### 1. System Design\nThe network system demonstrates several key design principles:\n\n1. **Protocol Independence**\n   - Abstract message format\n   - Protocol negotiation\n   - Format conversion\n   - State management\n\n2. **Fault Tolerance**\n   - Connection pooling\n   - Error recovery\n   - State verification\n   - Resource cleanup\n\n3. **Performance Focus**\n   - Connection reuse\n   - Protocol optimization\n   - State caching\n   - Resource management\n\n### 2. Code Organization\nThe codebase follows consistent organizational patterns:\n\n1. **Module Responsibilities**\n   - Clear single responsibility\n   - Well-defined interfaces\n   - Minimal dependencies\n   - Strong cohesion\n\n2. **Code Structure**\n   - Consistent file organization\n   - Clear function grouping\n   - Comprehensive documentation\n   - Thorough testing\n\n3. **Error Handling**\n   - Consistent error types\n   - Clear error propagation\n   - Proper resource cleanup\n   - State recovery\n\n### 3. Integration Approach\nThe system takes a methodical approach to integration:\n\n1. **External Systems**\n   - Clear boundaries\n   - Protocol adaptation\n   - Error isolation\n   - State management\n\n2. **Internal Systems**\n   - Message-based communication\n   - State coordination\n   - Resource sharing\n   - Error propagation\n\n3. **Development Tools**\n   - Comprehensive monitoring\n   - Detailed logging\n   - State visualization\n   - Performance tracking\n\n## Areas for Improvement\n\n### 1. Protocol Support\n- HTTP/3 support is experimental\n- Protocol fallback could be more robust\n- CORS handling could be more configurable\n- WebSocket support is limited\n\n### 2. Error Handling\n- Error recovery could be more sophisticated\n- State recovery could be more robust\n- Resource cleanup could be more thorough\n- Error reporting could be more detailed\n\n### 3. Development Support\n- Tracing could be more comprehensive\n- Visualization could be more interactive\n- Metrics could be more detailed\n- Documentation could be more extensive\n\n## Future Considerations\n\n### 1. Protocol Evolution\n- Full HTTP/3 support\n- WebSocket integration\n- Protocol extensions\n- Custom protocols\n\n### 2. Integration Enhancement\n- More external systems\n- Better internal coordination\n- Enhanced monitoring\n- Improved visualization\n\n### 3. Development Tools\n- Better debugging support\n- More detailed metrics\n- Enhanced visualization\n- Improved documentation\n\n## Impact Analysis\n\n### 1. System Benefits\nThe network system provides several key benefits:\n\n1. **Flexibility**\n   - Multiple protocols\n   - Various backends\n   - Different formats\n   - Custom extensions\n\n2. **Reliability**\n   - Error handling\n   - State management\n   - Resource cleanup\n   - Performance monitoring\n\n3. **Maintainability**\n   - Clear organization\n   - Good documentation\n   - Strong testing\n   - Easy debugging\n\n### 2. System Limitations\nSome limitations to consider:\n\n1. **Protocol Support**\n   - Limited HTTP/3\n   - Basic WebSocket\n   - Simple CORS\n   - Basic protocols\n\n2. **Development Tools**\n   - Basic tracing\n   - Simple visualization\n   - Limited metrics\n   - Basic documentation\n\n3. **Integration Scope**\n   - Few external systems\n   - Basic coordination\n   - Simple monitoring\n   - Limited visualization\n\n### 3. Future Opportunities\nAreas for potential improvement:\n\n1. **Protocol Enhancement**\n   - Full HTTP/3\n   - Better WebSocket\n   - Enhanced CORS\n   - Custom protocols\n\n2. **Tool Development**\n   - Better tracing\n   - Enhanced visualization\n   - More metrics\n   - Better documentation\n\n3. **Integration Expansion**\n   - More systems\n   - Better coordination\n   - Enhanced monitoring\n   - Improved visualization\n"}}