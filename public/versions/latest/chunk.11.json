{"devices/message_protocol_handling/modules/dev_codec_json.md":{"content":"# Module: dev_codec_json\n\n## Basic Information\n- **Source File:** dev_codec_json.erl\n- **Module Type:** Message Protocol Codec\n- **Purpose:** Provides JSON encoding/decoding capabilities for HyperBEAM's Tagged Attribute-Based Messages (TABMs), with integrated support for message signing through the httpsig codec.\n\n## Core Functionality\n\n### 1. Message Conversion Flow\n```mermaid\ngraph TD\n    A[TABM] -->|to/1| B[JSON String]\n    B -->|from/1| A\n    C[JSON Payload] -->|deserialize/3| D[Message]\n    E[Message] -->|serialize/3| F[JSON Response]\n```\n\n### 2. Content Type\n```erlang\ncontent_type(_) -> {ok, <<\"application/json\">>}\n```\n\n## Implementation Details\n\n### 1. Message Encoding\n\n#### TABM to JSON\n```erlang\nto(Msg) when is_binary(Msg) -> \n    iolist_to_binary(json:encode(Msg));\nto(Msg) -> \n    iolist_to_binary(\n        json:encode(hb_private:reset(Msg))\n    )\n```\n\n#### JSON to TABM\n```erlang\nfrom(Map) when is_map(Map) -> Map;\nfrom(Json) -> json:decode(Json)\n```\n\n### 2. Serialization Support\n\n#### Deserialization\n```erlang\ndeserialize(Base, Req, Opts) ->\n    % Extract payload from target path\n    Payload = hb_ao:get(\n        Target = hb_ao:get(\n            <<\"target\">>,\n            Req,\n            <<\"body\">>,\n            Opts\n        ),\n        Base,\n        Opts\n    ),\n    \n    % Handle payload extraction\n    case Payload of\n        not_found -> \n            {error, #{\n                <<\"status\">> => 404,\n                <<\"body\">> => error_message(Target)\n            }};\n        _ ->\n            {ok, from(Payload)}\n    end\n```\n\n#### Serialization\n```erlang\nserialize(Base, _Msg, _Opts) ->\n    {ok, #{\n        <<\"content-type\">> => <<\"application/json\">>,\n        <<\"body\">> => to(Base)\n    }}\n```\n\n## Key Features\n\n### 1. Message Handling\n- JSON encoding/decoding\n- Private field handling\n- Binary passthrough\n- Error handling\n\n### 2. Integration Support\n- HTTPSIG commitment delegation\n- Content type specification\n- Target path resolution\n- Response formatting\n\n### 3. Commitment Support\n- Message signing\n- Signature verification\n- Commitment tracking\n- HTTPSIG integration\n\n### 4. Integration Points\n- JSON system\n- TABM protocol\n- HTTPSIG codec\n- Message system\n\n## Function Reference\n\n### 1. Core Functions\n\n#### Message Conversion\n```erlang\n% Convert TABM to JSON string\nto(Message) -> JsonString\n\n% Convert JSON to TABM\nfrom(JsonString) -> Message\n```\n\n#### Commitment Operations\n```erlang\n% Sign message (delegates to httpsig)\ncommit(Message, Request, Options) -> \n    dev_codec_httpsig:commit(Message, Request, Options)\n\n% Verify signature (delegates to httpsig)\nverify(Message, Request, Options) ->\n    dev_codec_httpsig:verify(Message, Request, Options)\n```\n\n### 2. Serialization Functions\n\n#### Payload Processing\n```erlang\n% Deserialize JSON from target path\ndeserialize(Base, Request, Options) ->\n    {ok, Message} | {error, ErrorDetails}\n\n% Serialize message to JSON response\nserialize(Base, Message, Options) ->\n    {ok, #{\n        <<\"content-type\">> => <<\"application/json\">>,\n        <<\"body\">> => JsonString\n    }}\n```\n\n## Best Practices\n\n### 1. Message Handling\n- Reset private fields\n- Handle binary data\n- Validate inputs\n- Format responses\n\n### 2. Error Handling\n- Check payloads\n- Validate paths\n- Format errors\n- Provide context\n\n### 3. Integration\n- Follow protocols\n- Handle errors\n- Log operations\n- Maintain compatibility\n\n## Error Handling\n\n### 1. Common Errors\n```erlang\n% Missing payload\n{error, #{\n    <<\"status\">> => 404,\n    <<\"body\">> => <<\"JSON payload not found...\">>\n}}\n\n% Invalid JSON\n{error, json_decode_error}\n\n% Missing target\n{error, target_not_found}\n```\n\n### 2. Error Prevention\n- Validate inputs\n- Check paths\n- Handle edge cases\n- Format errors\n\n## Usage Examples\n\n### 1. Basic Conversion\n```erlang\n% Convert TABM to JSON\nJsonString = dev_codec_json:to(TABMessage)\n\n% Convert JSON to TABM\nMessage = dev_codec_json:from(JsonString)\n```\n\n### 2. Message Signing\n```erlang\n% Sign message using HTTPSIG\n{ok, SignedMsg} = dev_codec_json:commit(\n    Message,\n    Request,\n    Options\n)\n\n% Verify signature\n{ok, true} = dev_codec_json:verify(\n    SignedMsg,\n    Request,\n    Options\n)\n```\n\n### 3. Serialization\n```erlang\n% Deserialize JSON payload\n{ok, Message} = dev_codec_json:deserialize(\n    BaseMessage,\n    #{<<\"target\">> => <<\"body\">>},\n    Options\n)\n\n% Serialize to JSON response\n{ok, Response} = dev_codec_json:serialize(\n    Message,\n    Request,\n    Options\n)\n```\n\n## Integration Notes\n\n### 1. HTTPSIG Integration\n- Delegates commitment operations\n- Maintains signature compatibility\n- Preserves verification flow\n- Handles commitment tracking\n\n### 2. Message System\n- Handles TABM conversion\n- Preserves message structure\n- Manages private fields\n- Supports binary data\n\n### 3. Response Format\n- Content type specification\n- Body encapsulation\n- Error formatting\n- Status handling\n"},"devices/message_protocol_handling/modules/dev_codec_structured.md":{"content":"# Module: dev_codec_structured\n\n## Basic Information\n- **Source File:** dev_codec_structured.erl\n- **Module Type:** Message Protocol Codec\n- **Purpose:** Implements HTTP Structured Fields (RFC-9651) encoding/decoding for HyperBEAM's internal richly typed message format, with support for TABM (Type-Annotated-Binary-Message) conversion.\n\n## Core Functionality\n\n### 1. Message Conversion Flow\n```mermaid\ngraph TD\n    A[Rich Message] -->|from/1| B[TABM]\n    B -->|to/1| A\n    C[Types] -->|encode_value| D[Binary]\n    D -->|decode_value| C\n```\n\n### 2. Type Handling\n```mermaid\ngraph TD\n    A[Value] --> B{Type?}\n    B -->|Integer| C[Structured Item]\n    B -->|Float| D[Binary]\n    B -->|Atom| E[String Item]\n    B -->|List| F[Structured List]\n    B -->|Binary| G[Direct Value]\n    B -->|Map| H[Recursive Encode]\n```\n\n## Implementation Details\n\n### 1. Message Encoding\n\n#### TABM Generation\n```erlang\nfrom(Msg) when is_map(Msg) ->\n    % Normalize keys and split into types and values\n    {Types, Values} = process_message_parts(Msg),\n    \n    % Add ao-types field if types exist\n    case Types of\n        [] -> Values;\n        T -> [{<<\"ao-types\">>, encode_types(T)} | Values]\n    end\n```\n\n#### Value Encoding\n```erlang\nencode_value(Value) when is_integer(Value) ->\n    {<<\"integer\">>, encode_structured_item(Value)};\nencode_value(Value) when is_atom(Value) ->\n    {<<\"atom\">>, encode_atom_to_string(Value)};\nencode_value(Values) when is_list(Values) ->\n    {<<\"list\">>, encode_list_items(Values)};\nencode_value(Value) when is_binary(Value) ->\n    {<<\"binary\">>, Value}\n```\n\n### 2. Message Decoding\n\n#### Type Processing\n```erlang\ndecode_value(Type, Value) ->\n    case Type of\n        integer -> parse_structured_integer(Value);\n        atom -> parse_structured_atom(Value);\n        list -> parse_structured_list(Value);\n        map -> parse_structured_dictionary(Value)\n    end\n```\n\n#### Empty Value Handling\n```erlang\nhandle_empty_values(Types, TABM) ->\n    maps:fold(\n        fun\n            (Key, <<\"empty-binary\">>, Acc) -> \n                Acc#{Key => <<>>};\n            (Key, <<\"empty-list\">>, Acc) -> \n                Acc#{Key => []};\n            (Key, <<\"empty-message\">>, Acc) -> \n                Acc#{Key => #{}}\n        end,\n        #{},\n        Types\n    )\n```\n\n## Key Features\n\n### 1. Type System\n- Integer encoding\n- Atom conversion\n- List handling\n- Binary passthrough\n- Map recursion\n- Empty value support\n\n### 2. Structured Fields\n- RFC-9651 compliance\n- Dictionary encoding\n- List serialization\n- Item formatting\n- Type preservation\n\n### 3. Message Processing\n- Key normalization\n- Type annotation\n- Value encoding\n- Recursive handling\n- Function serialization\n\n### 4. Integration Points\n- HTTPSIG codec\n- TABM format\n- Message system\n- Type system\n\n## Function Reference\n\n### 1. Core Functions\n\n#### Message Conversion\n```erlang\n% Convert rich message to TABM\nfrom(Message) -> TABM\n\n% Convert TABM to rich message\nto(TABM) -> Message\n```\n\n#### Value Processing\n```erlang\n% Encode value with type information\nencode_value(Value) -> {Type, EncodedValue}\n\n% Decode value based on type\ndecode_value(Type, Value) -> DecodedValue\n```\n\n### 2. Helper Functions\n\n#### Type Management\n```erlang\n% Parse ao-types field\nparse_ao_types(Binary) -> TypeMap\n\n% Find implicit keys in message\nimplicit_keys(Message) -> [Keys]\n```\n\n## Best Practices\n\n### 1. Type Handling\n- Validate types\n- Handle edge cases\n- Preserve structure\n- Maintain encoding\n\n### 2. Message Processing\n- Normalize keys\n- Track types\n- Handle empties\n- Preserve order\n\n### 3. Integration\n- Follow RFC specs\n- Handle errors\n- Log operations\n- Maintain compatibility\n\n## Error Handling\n\n### 1. Common Errors\n```erlang\n% Unexpected type\n{unexpected_type, Type, Value}\n\n% Invalid format\n{invalid_format, Details}\n\n% Parse error\n{parse_error, Reason}\n```\n\n### 2. Error Prevention\n- Validate types\n- Check formats\n- Handle edge cases\n- Log issues\n\n## Usage Examples\n\n### 1. Basic Conversion\n```erlang\n% Convert rich message to TABM\nTABM = dev_codec_structured:from(#{\n    <<\"key\">> => <<\"value\">>,\n    <<\"number\">> => 42,\n    <<\"list\">> => [1, 2, 3]\n})\n\n% Convert TABM back to rich message\nMessage = dev_codec_structured:to(TABM)\n```\n\n### 2. Value Processing\n```erlang\n% Encode value with type\n{Type, Encoded} = encode_value([1, 2, 3])\n\n% Decode value using type\nDecoded = decode_value(Type, Encoded)\n```\n\n### 3. Type Management\n```erlang\n% Handle empty values\nEmptyMap = #{<<\"key\">> => <<>>}\nTABM = from(EmptyMap)\nTypes = parse_ao_types(TABM)\n```\n\n## Testing Coverage\n\n### 1. List Encoding\n```erlang\nlist_encoding_test() ->\n    % Test integer list\n    {<<\"list\">>, Encoded1} = encode_value([1, 2, 3]),\n    [1, 2, 3] = decode_value(list, Encoded1),\n    \n    % Test binary list\n    {<<\"list\">>, Encoded2} = encode_value([<<\"1\">>, <<\"2\">>]),\n    [<<\"1\">>, <<\"2\">>] = decode_value(list, Encoded2),\n    \n    % Test mixed list\n    {<<\"list\">>, Encoded3} = encode_value([1, <<\"2\">>, 3]),\n    [1, <<\"2\">>, 3] = decode_value(list, Encoded3)\n```\n\n## RFC-9651 Compliance\n\n### 1. Structured Fields\n- Dictionary format\n- List encoding\n- Item structure\n- Parameter handling\n\n### 2. Type System\n- Integer encoding\n- String formatting\n- List structure\n- Binary handling\n\n### 3. Message Format\n- Field structure\n- Value encoding\n- Type preservation\n- Format validation\n"},"devices/message_protocol_handling/modules/dev_message.md":{"content":"# Module: dev_message\n\n## Basic Information\n- **Source File:** dev_message.erl\n- **Module Type:** Message Protocol Handler\n- **Purpose:** Identity device that handles basic message operations and commitment management, serving as the foundation for message manipulation in the system.\n\n## Core Functionality\n\n### 1. Message Operations\n```mermaid\ngraph TD\n    A[Message] --> B{Operation}\n    B -->|Get| C[Retrieve Value]\n    B -->|Set| D[Update Value]\n    B -->|Remove| E[Delete Key]\n    B -->|Keys| F[List Keys]\n    \n    C --> G[Case-Sensitive]\n    C --> H[Case-Insensitive]\n    \n    D --> I[Deep Merge]\n    D --> J[Commitment Check]\n```\n\n### 2. Reserved Keys\n```erlang\n-define(DEVICE_KEYS, [\n    <<\"id\">>,\n    <<\"commitments\">>,\n    <<\"committers\">>,\n    <<\"keys\">>,\n    <<\"path\">>,\n    <<\"set\">>,\n    <<\"remove\">>,\n    <<\"verify\">>\n]).\n```\n\n## Implementation Details\n\n### 1. Message Access\n\n#### Key Retrieval\n```erlang\nget(Key, Msg) ->\n    case hb_private:is_private(Key) of\n        true -> {error, not_found}\n        false ->\n            case maps:get(Key, Msg, not_found) of\n                not_found -> case_insensitive_get(Key, Msg)\n                Value -> {ok, Value}\n            end\n    end\n```\n\n#### Case-Insensitive Lookup\n```erlang\ncase_insensitive_get(Key, Msg) ->\n    NormKey = hb_ao:normalize_key(Key)\n    NormMsg = hb_ao:normalize_keys(Msg)\n    case maps:get(NormKey, NormMsg, not_found) of\n        not_found -> {error, not_found}\n        Value -> {ok, Value}\n    end\n```\n\n### 2. Message Modification\n\n#### Setting Values\n```mermaid\ngraph TD\n    A[Set Request] --> B[Filter Reserved Keys]\n    B --> C[Check Conflicts]\n    C --> D[Check Commitments]\n    D --> E[Deep Merge]\n    E --> F[Update Message]\n```\n\n#### Value Removal\n```erlang\nremove(Message1, #{ <<\"items\">> := Keys }) ->\n    {ok, maps:without(Keys, Message1)}\n```\n\n### 3. Commitment Management\n\n#### Commitment Flow\n```mermaid\nsequenceDiagram\n    participant M as Message\n    participant C as Commitment System\n    participant V as Verification\n    \n    M->>C: Request Commit\n    C->>C: Calculate ID\n    C->>C: Add Commitment\n    C-->>M: Updated Message\n    \n    M->>V: Request Verify\n    V->>V: Check Commitments\n    V->>V: Verify Each\n    V-->>M: Verification Result\n```\n\n#### Commitment Verification\n```erlang\nverify(Self, Req, Opts) ->\n    {ok, Base} = hb_message:find_target(Self, Req, Opts)\n    Commitments = maps:get(<<\"commitments\">>, Base, #{})\n    IDsToVerify = commitment_ids_from_request(Base, Req, Opts)\n    \n    % Verify each commitment\n    Result = lists:all(\n        fun(CommitmentID) ->\n            verify_commitment(Base, CommitmentID, Commitments)\n        end,\n        IDsToVerify\n    )\n```\n\n## Key Features\n\n### 1. Message Handling\n- Case-insensitive key access\n- Private key protection\n- Deep merging support\n- Key removal capabilities\n\n### 2. Commitment System\n- Multiple commitment support\n- Commitment verification\n- Committer management\n- ID calculation\n\n### 3. Security Features\n- Private key filtering\n- Commitment validation\n- Authorization checks\n- Data protection\n\n### 4. Integration Points\n- Message system\n- Commitment devices\n- Verification system\n- Storage system\n\n## Testing Coverage\n\n### 1. Key Operations\n```erlang\ncase_insensitive_get_test() ->\n    % Tests case-insensitive key access\n    ?assertEqual({ok, 1}, case_insensitive_get(<<\"a\">>, #{ <<\"A\">> => 1 }))\n```\n\n### 2. Privacy Controls\n```erlang\nprivate_keys_are_filtered_test() ->\n    % Tests private key filtering\n    ?assertEqual(\n        {ok, [<<\"a\">>]},\n        hb_ao:resolve(#{ <<\"a\">> => 1, <<\"private\">> => 2 }, keys, #{})\n    )\n```\n\n### 3. Commitment Handling\n```erlang\nverify_test() ->\n    % Tests commitment verification\n    Unsigned = #{ <<\"a\">> => <<\"b\">> }\n    Signed = hb_message:commit(Unsigned, hb:wallet())\n    ?assertEqual({ok, true}, verify(Signed))\n```\n\n## Best Practices\n\n### 1. Message Operations\n- Validate inputs\n- Handle case sensitivity\n- Protect private data\n- Maintain consistency\n\n### 2. Commitment Management\n- Verify all commitments\n- Track commitment history\n- Handle multiple signers\n- Maintain integrity\n\n### 3. Integration\n- Follow protocols\n- Handle errors\n- Log operations\n- Maintain security\n\n## Error Handling\n\n### 1. Common Errors\n```erlang\n% Key not found\n{error, not_found}\n\n% Invalid commitment\n{error, {multiple_id_devices, Devices}}\n\n% Missing commitments\n{error, {requested_committers_not_found, Missing}}\n```\n\n### 2. Error Prevention\n- Input validation\n- Type checking\n- Boundary validation\n- State verification\n\n## Usage Examples\n\n### 1. Basic Operations\n```erlang\n% Get value\n{ok, Value} = get(Key, Message)\n\n% Set value\n{ok, NewMessage} = set(Message, #{<<\"key\">> => <<\"value\">>}, Opts)\n\n% Remove key\n{ok, UpdatedMessage} = remove(Message, #{<<\"items\">> => [Key]})\n```\n\n### 2. Commitment Operations\n```erlang\n% Create commitment\n{ok, SignedMsg} = commit(Message, Request, Options)\n\n% Verify commitment\n{ok, true} = verify(SignedMsg, Request, Options)\n\n% Get committers\n{ok, Committers} = committers(Message)\n```\n\n### 3. Key Management\n```erlang\n% List public keys\n{ok, Keys} = keys(Message)\n\n% Case-insensitive access\n{ok, Value} = case_insensitive_get(<<\"Key\">>, #{<<\"key\">> => Value})\n"},"devices/message_protocol_handling/modules/dev_meta.md":{"content":"# Module: dev_meta\n\n## Basic Information\n- **Source File:** dev_meta.erl\n- **Module Type:** Message Protocol Handler\n- **Purpose:** Default entry point for all messages processed by the machine, providing message preprocessing, routing, and postprocessing capabilities.\n\n## Core Functionality\n\n### 1. Message Processing Pipeline\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant P as Preprocessor\n    participant R as AO-Core Resolver\n    participant S as Postprocessor\n    \n    C->>P: Raw Request\n    P->>P: Normalize & Validate\n    P-->>R: Preprocessed Request\n    R->>R: Resolve Request\n    R-->>S: Resolution Result\n    S->>S: Post-process\n    S-->>C: Final Response\n```\n\n### 2. Request Handling Flow\n```erlang\nhandle(NodeMsg, RawRequest) ->\n    % 1. Normalize request\n    NormRequest = hb_singleton:from(RawRequest)\n\n    % 2. Check initialization\n    case initialized? of\n        false -> handle_initialize()\n        true -> handle_resolve()\n    end\n\n    % 3. Process request\n    handle_resolve(RawRequest, NormRequest, NodeMsg) ->\n        % Apply preprocessor\n        case preprocess(Request) of\n            {ok, PreProcessed} -> \n                % Resolve request\n                Result = resolve(PreProcessed)\n                % Apply postprocessor\n                postprocess(Result)\n            Error -> Error\n        end\n```\n\n## Implementation Details\n\n### 1. Node Message Management\n\n#### Configuration Access\n```erlang\ninfo(_, Request, NodeMsg) ->\n    case Method of\n        <<\"GET\">> -> \n            % Return filtered node message\n            {ok, filter_node_msg(add_dynamic_keys(NodeMsg))}\n        <<\"POST\">> -> \n            % Update node message if authorized\n            update_node_message(Request, NodeMsg)\n    end\n```\n\n#### Authorization Control\n```erlang\nis_operator(Request, NodeMsg) ->\n    RequestSigners = hb_message:signers(Request)\n    Operator = get_operator(NodeMsg)\n    EncOperator = encode_operator(Operator)\n    EncOperator == unclaimed orelse \n    lists:member(EncOperator, RequestSigners)\n```\n\n### 2. Message Processing\n\n#### Preprocessing\n```mermaid\ngraph TD\n    A[Raw Request] --> B[Normalize]\n    B --> C{Initialized?}\n    C -->|No| D[Initialize Handler]\n    C -->|Yes| E[Preprocessor]\n    E --> F{Success?}\n    F -->|Yes| G[Continue Processing]\n    F -->|No| H[Return Error]\n```\n\n#### Postprocessing\n```mermaid\ngraph TD\n    A[Resolution Result] --> B[Apply Postprocessor]\n    B --> C[Embed Status]\n    C --> D{Sign Required?}\n    D -->|Yes| E[Sign Response]\n    D -->|No| F[Return Response]\n```\n\n### 3. Status Handling\n\n#### Status Code Resolution\n```erlang\nstatus_code({ErlStatus, Msg}) ->\n    case message_to_status(Msg) of\n        default -> status_code(ErlStatus)\n        RawStatus -> RawStatus\n    end\n\nstatus_code(ok) -> 200\nstatus_code(error) -> 400\nstatus_code(created) -> 201\nstatus_code(not_found) -> 404\nstatus_code(unavailable) -> 503\n```\n\n## Key Features\n\n### 1. Node Configuration\n- Dynamic configuration management\n- Secure configuration updates\n- Configuration persistence\n- Access control\n\n### 2. Message Processing\n- Request normalization\n- Multi-stage processing\n- Flexible routing\n- Error handling\n\n### 3. Security Features\n- Authorization checks\n- Message signing\n- Private data filtering\n- Access control\n\n### 4. Integration Points\n- AO-Core resolver\n- HTTP server\n- Message system\n- Node management\n\n## Testing Coverage\n\n### 1. Configuration Management\n```erlang\nconfig_test() ->\n    % Tests basic configuration access\n    Node = start_node(#{ test_config_item => <<\"test\">> })\n    {ok, Res} = get_info(Node)\n    assert_config_value(Res)\n```\n\n### 2. Security Controls\n```erlang\nunauthorized_set_node_msg_fails_test() ->\n    % Tests unauthorized access prevention\n    Node = start_node(#{ priv_wallet => new_wallet() })\n    {error, _} = attempt_unauthorized_update(Node)\n    verify_unchanged_state(Node)\n```\n\n### 3. Node Initialization\n```erlang\nuninitialized_node_test() ->\n    % Tests initialization requirements\n    Node = start_node(#{ initialized => false })\n    {error, Res} = attempt_computation(Node)\n    assert_initialization_error(Res)\n```\n\n## Best Practices\n\n### 1. Request Processing\n- Validate all inputs\n- Apply security checks\n- Handle errors gracefully\n- Maintain state consistency\n\n### 2. Configuration Management\n- Verify authorization\n- Filter sensitive data\n- Track configuration history\n- Ensure atomic updates\n\n### 3. Integration\n- Follow protocol standards\n- Handle edge cases\n- Log important events\n- Maintain compatibility\n\n## Error Handling\n\n### 1. Common Errors\n- Unauthorized access\n- Invalid configuration\n- Processing failures\n- State inconsistencies\n\n### 2. Error Responses\n```erlang\n% Authorization failure\n{error, <<\"Unauthorized\">>}\n\n% Initialization required\n{error, <<\"Node must be initialized before use.\">>}\n\n% Configuration locked\n{error, <<\"Node message is already permanent.\">>}\n```\n\n## Usage Examples\n\n### 1. Basic Configuration\n```erlang\n% Get node configuration\nGET /~meta@1.0/info\n\n% Update configuration (authorized)\nPOST /~meta@1.0/info\n{\n    \"config_key\": \"new_value\",\n    \"signatures\": [\"authorized_signer\"]\n}\n```\n\n### 2. Message Processing\n```erlang\n% Process message with preprocessing\nhandle(NodeMsg, RawRequest) ->\n    PreProcessed = preprocess(RawRequest)\n    Result = resolve(PreProcessed)\n    postprocess(Result)\n```\n\n### 3. Security Controls\n```erlang\n% Verify authorization\nis_operator(Request, NodeMsg) ->\n    verify_signatures(Request) andalso\n    check_permissions(Request, NodeMsg)\n"},"devices/message_protocol_handling/observations.md":{"content":"# Message Protocol Handling: In-Depth Analysis & Observations\n\n## Architectural Foundations & Design Philosophy\n\n### 1. Multi-Codec Architecture\n```mermaid\ngraph TD\n    A[Base Codec Interface] -->|implements| B[ANS.1 Codec]\n    A -->|implements| C[Flat Codec]\n    A -->|implements| D[HTTP Signature Codec]\n    A -->|implements| E[JSON Codec]\n    A -->|implements| F[Structured Fields Codec]\n    D -->|uses| G[HTTP Signature Converter]\n```\n\nThe system employs a sophisticated multi-codec architecture that demonstrates several key design principles:\n\n1. **Interface Standardization**\n   - Each codec implements a common interface (to/from)\n   - Enables consistent message handling across formats\n   - Facilitates easy addition of new codecs\n   - Maintains system extensibility\n\n2. **Format Specialization**\n   - Each codec optimizes for specific use cases\n   - Preserves format-specific features\n   - Handles unique encoding requirements\n   - Maintains format integrity\n\n3. **Integration Strategy**\n   - Codecs work together seamlessly\n   - Share common type system\n   - Handle format conversion\n   - Maintain message consistency\n\n### 2. Message Processing Pipeline\n```mermaid\ngraph LR\n    A[Raw Message] -->|\"1. Parse\"| B[Initial Structure]\n    B -->|\"2. Validate\"| C[Verified Message]\n    C -->|\"3. Transform\"| D[Encoded Format]\n    D -->|\"4. Sign\"| E[Final Message]\n    E -->|\"5. Verify\"| F[Validated Message]\n```\n\nThe message processing pipeline demonstrates sophisticated handling:\n\n1. **Initial Processing**\n   - Parses raw message content\n   - Validates basic structure\n   - Prepares for transformation\n   - Handles encoding selection\n\n2. **Transformation Flow**\n   - Converts between formats\n   - Preserves message integrity\n   - Maintains type information\n   - Optimizes representation\n\n3. **Security Integration**\n   - Handles message signing\n   - Verifies signatures\n   - Tracks commitments\n   - Ensures message integrity\n\n## Core System Components & Their Interactions\n\n### 1. Type System Architecture\nThe type system demonstrates remarkable sophistication in handling various data types:\n\n#### Type Management Strategy\n1. **Basic Types**\n   - Integer handling with range validation\n   - Binary data with optimized storage\n   - String processing with encoding awareness\n   - Boolean values with state preservation\n\n2. **Complex Types**\n   - Nested structure support\n   - List handling with type preservation\n   - Map processing with key normalization\n   - Custom type definition capabilities\n\n3. **Special Cases**\n   - Null value representation\n   - Empty container handling\n   - Default value management\n   - Type conversion rules\n\n### 2. Protocol Implementation\nThe protocol layer shows careful attention to detail:\n\n#### Protocol Features\n1. **Message Structure**\n   - Header organization\n   - Body handling\n   - Attachment support\n   - Metadata management\n\n2. **Format Handling**\n   - Content type detection\n   - Encoding selection\n   - Format validation\n   - Conversion rules\n\n3. **Security Measures**\n   - Signature generation\n   - Verification process\n   - Key management\n   - Security policy enforcement\n\n## Implementation Patterns & Best Practices\n\n### 1. Code Organization\nThe codebase demonstrates several sophisticated patterns:\n\n#### Module Structure\n1. **Core Components**\n   - Clear separation of concerns\n   - Modular design principles\n   - Interface-based communication\n   - Dependency management\n\n2. **Support Systems**\n   - Utility functions\n   - Helper modules\n   - Shared resources\n   - Common interfaces\n\n3. **Testing Framework**\n   - Unit test coverage\n   - Integration testing\n   - Performance benchmarks\n   - Security validation\n\n### 2. Error Handling\nError management shows comprehensive coverage:\n\n#### Error Strategies\n1. **Detection Methods**\n   - Early validation\n   - Type checking\n   - Format verification\n   - Protocol compliance\n\n2. **Recovery Procedures**\n   - Graceful degradation\n   - Fallback options\n   - State recovery\n   - Error reporting\n\n3. **Prevention Measures**\n   - Input validation\n   - Type safety\n   - Format checking\n   - Security verification\n\n## Performance Considerations & Optimizations\n\n### 1. Processing Efficiency\nThe system implements various optimization techniques:\n\n#### Optimization Strategies\n1. **Memory Management**\n   - Buffer pooling\n   - Resource reuse\n   - Cache utilization\n   - Memory mapping\n\n2. **CPU Utilization**\n   - Batch processing\n   - Parallel execution\n   - Load distribution\n   - Process optimization\n\n3. **I/O Handling**\n   - Asynchronous operations\n   - Buffered I/O\n   - Stream processing\n   - Connection pooling\n\n### 2. Format Optimization\nFormat handling shows careful optimization:\n\n#### Optimization Techniques\n1. **Data Representation**\n   - Compact encoding\n   - Efficient serialization\n   - Binary optimization\n   - Structure compression\n\n2. **Processing Flow**\n   - Streamlined conversion\n   - Minimal copying\n   - Direct processing\n   - Efficient routing\n\n## Security Implementation & Verification\n\n### 1. Signature System\nThe signature system demonstrates robust security:\n\n#### Security Features\n1. **Signature Generation**\n   - Key management\n   - Algorithm selection\n   - Parameter handling\n   - Format compliance\n\n2. **Verification Process**\n   - Signature validation\n   - Key verification\n   - Parameter checking\n   - Format validation\n\n### 2. Message Protection\nMessage security shows comprehensive coverage:\n\n#### Protection Measures\n1. **Content Security**\n   - Data encryption\n   - Integrity checking\n   - Access control\n   - Audit logging\n\n2. **Transport Security**\n   - Channel encryption\n   - Protocol security\n   - Connection validation\n   - Session management\n\n## Future Development & Enhancement Opportunities\n\n### 1. System Evolution\nSeveral areas show potential for enhancement:\n\n#### Development Areas\n1. **Format Support**\n   - New codec addition\n   - Format extension\n   - Protocol updates\n   - Conversion improvements\n\n2. **Performance Enhancement**\n   - Processing optimization\n   - Memory efficiency\n   - CPU utilization\n   - I/O improvement\n\n### 2. Feature Extension\nPotential feature additions include:\n\n#### New Capabilities\n1. **Protocol Extensions**\n   - Enhanced security\n   - Better performance\n   - More formats\n   - Better integration\n\n2. **Tool Development**\n   - Debug support\n   - Analysis tools\n   - Monitoring systems\n   - Development aids\n\n## Documentation & Maintenance\n\n### 1. Documentation Strategy\nDocumentation shows systematic organization:\n\n#### Documentation Areas\n1. **Technical Documentation**\n   - API references\n   - Implementation details\n   - Protocol specifications\n   - Security guidelines\n\n2. **User Documentation**\n   - Usage guides\n   - Best practices\n   - Example code\n   - Troubleshooting\n\n### 2. Maintenance Procedures\nMaintenance processes demonstrate good practices:\n\n#### Maintenance Areas\n1. **Code Maintenance**\n   - Regular updates\n   - Bug fixing\n   - Performance tuning\n   - Security patches\n\n2. **System Evolution**\n   - Feature addition\n   - Protocol updates\n   - Security enhancement\n   - Performance optimization\n"},"devices/message_protocol_handling/OVERVIEW.md":{"content":"# Message Protocol Handling System: Comprehensive Overview\n\n## System Architecture & Core Components\n\n### 1. Architectural Foundation\n```mermaid\ngraph TD\n    A[Message Protocol System] --> B[Meta Handler]\n    A --> C[Message Handler]\n    A --> D[Codec System]\n    D --> E[ANS.1 Codec]\n    D --> F[Flat Codec]\n    D --> G[HTTP Signature Codec]\n    D --> H[JSON Codec]\n    D --> I[Structured Fields Codec]\n    G --> J[HTTP Signature Converter]\n    \n    B --> K[Protocol Metadata]\n    B --> L[System Information]\n    B --> M[Configuration]\n    \n    C --> N[Message Creation]\n    C --> O[Format Validation]\n    C --> P[Type Management]\n```\n\nThe Message Protocol Handling System serves as the foundational layer for all message-based communication within HyperBEAM. It implements a sophisticated multi-codec architecture that enables seamless conversion between different message formats while preserving type information and ensuring message integrity through cryptographic signatures.\n\n### 2. Message Flow & Processing\n```mermaid\nsequenceDiagram\n    participant App as Application Layer\n    participant Meta as Meta Handler\n    participant Msg as Message Handler\n    participant Codec as Codec System\n    participant Sign as Signature System\n    \n    App->>Meta: Request Protocol Info\n    Meta-->>App: Protocol Configuration\n    App->>Msg: Create Message\n    Msg->>Meta: Validate Format\n    Msg->>Codec: Select Codec\n    Codec->>Sign: Generate Signature\n    Sign-->>Codec: Return Signature\n    Codec-->>Msg: Return Encoded\n    Msg-->>App: Final Message\n```\n\nThe system implements a carefully orchestrated message flow that ensures proper handling at each stage:\n1. Initial protocol validation through the Meta Handler\n2. Message creation and format verification\n3. Codec selection based on target format\n4. Optional signature generation and verification\n5. Final message assembly and delivery\n\n## Core Subsystems: Detailed Analysis\n\n### 1. Meta Handler (dev_meta)\nThe Meta Handler serves as the system's configuration and metadata management center, responsible for:\n\n#### Protocol Management\n- **Version Control**: Maintains protocol versioning and compatibility\n- **Feature Tracking**: Maps available protocol features and capabilities\n- **Configuration**: Handles protocol-specific configuration settings\n- **Validation Rules**: Defines and enforces protocol validation rules\n\n#### System Information\n- **Runtime Data**: Tracks system state and runtime information\n- **Resource Usage**: Monitors protocol-related resource utilization\n- **Performance Metrics**: Collects and manages performance statistics\n- **Error Tracking**: Handles protocol-level error reporting\n\n### 2. Message Handler (dev_message)\nThe Message Handler orchestrates the core message processing functionality:\n\n#### Message Creation\n- **Format Selection**: Chooses appropriate message formats\n- **Type Assignment**: Handles initial type assignment and validation\n- **Structure Building**: Constructs message structure hierarchies\n- **Validation**: Ensures message integrity and completeness\n\n#### Processing Pipeline\n- **Pre-processing**: Prepares messages for codec processing\n- **Transformation**: Handles message structure transformations\n- **Post-processing**: Finalizes messages after codec operations\n- **Error Handling**: Manages processing errors and recovery\n\n### 3. Codec System\nThe Codec System provides a comprehensive suite of encoders/decoders:\n\n#### ANS.1 Codec\nImplements ASN.1 encoding with:\n- **Binary Efficiency**: Optimized binary format encoding\n- **Type Preservation**: Strong type system maintenance\n- **Schema Support**: ASN.1 schema validation and handling\n- **Performance Focus**: High-performance processing paths\n\n#### Flat Codec\nProvides simplified message encoding:\n- **Key Flattening**: Hierarchical structure flattening\n- **Value Preservation**: Direct value representation\n- **Debug Support**: Enhanced debugging capabilities\n- **Simple Interface**: Straightforward API design\n\n#### HTTP Signature Codec (RFC-9421)\nImplements cryptographic message signing:\n- **Signature Generation**: Creates cryptographic signatures\n- **Verification Flow**: Validates message signatures\n- **Commitment Tracking**: Manages signature commitments\n- **Security Features**: Implements security protocols\n\n#### JSON Codec\nHandles JSON format conversion:\n- **Type Mapping**: Maps between JSON and internal types\n- **Structure Preservation**: Maintains message structure\n- **Web Integration**: Supports web-based protocols\n- **Format Validation**: Ensures JSON compliance\n\n#### Structured Fields Codec (RFC-9651)\nManages structured field encoding:\n- **Field Organization**: Handles complex field structures\n- **Type System**: Implements rich type support\n- **Format Compliance**: Ensures RFC-9651 compliance\n- **Optimization**: Optimizes field representations\n\n## Integration & Interaction Patterns\n\n### 1. System Integration\nThe protocol handling system integrates with other components through:\n\n#### Core System Interface\n- **Message Routing**: Directs messages through the system\n- **Type Management**: Coordinates type system integration\n- **Error Handling**: Manages system-wide error flows\n- **Resource Control**: Handles resource allocation\n\n#### Network Layer Connection\n- **Protocol Bridging**: Connects different protocol layers\n- **Format Translation**: Handles format conversions\n- **Performance Optimization**: Optimizes network usage\n- **Security Integration**: Implements security measures\n\n### 2. Data Flow Patterns\nThe system implements sophisticated data flow patterns:\n\n#### Message Processing Flow\n```mermaid\ngraph LR\n    A[Raw Data] -->|Parse| B[Initial Message]\n    B -->|Validate| C[Validated Message]\n    C -->|Transform| D[Encoded Message]\n    D -->|Sign| E[Final Message]\n```\n\n#### Type Handling Flow\n```mermaid\ngraph TD\n    A[Input Type] -->|Analyze| B[Type System]\n    B -->|Map| C[Target Format]\n    C -->|Validate| D[Type Check]\n    D -->|Convert| E[Final Type]\n```\n\n## Advanced Features & Capabilities\n\n### 1. Type System\nThe type system provides comprehensive type handling:\n\n#### Type Management\n- **Rich Types**: Support for complex type structures\n- **Type Preservation**: Maintains type information\n- **Conversion Rules**: Defines type conversion logic\n- **Validation System**: Implements type validation\n\n#### Empty Value Handling\n- **Null Representation**: Handles null values properly\n- **Empty Containers**: Manages empty collections\n- **Default Values**: Implements default value logic\n- **Type Safety**: Ensures type-safe operations\n\n### 2. Security Features\nImplements robust security measures:\n\n#### Signature System\n- **Cryptographic Operations**: Handles crypto functions\n- **Key Management**: Manages cryptographic keys\n- **Verification Flow**: Implements signature verification\n- **Security Policies**: Enforces security rules\n\n#### Message Protection\n- **Integrity Checks**: Ensures message integrity\n- **Encryption Support**: Handles message encryption\n- **Access Control**: Implements access restrictions\n- **Audit Trail**: Maintains security logging\n\n## Performance & Optimization\n\n### 1. Processing Optimization\nImplements various optimization strategies:\n\n#### Memory Management\n- **Buffer Handling**: Optimizes buffer usage\n- **Resource Pooling**: Implements resource pools\n- **Cache Strategy**: Utilizes caching systems\n- **Memory Efficiency**: Optimizes memory use\n\n#### CPU Utilization\n- **Processing Paths**: Optimizes processing flows\n- **Batch Operations**: Implements batch processing\n- **Parallel Processing**: Uses parallel execution\n- **Load Balancing**: Manages processing load\n\n### 2. Format Optimization\nOptimizes format handling:\n\n#### Binary Optimization\n- **Compression**: Implements data compression\n- **Format Efficiency**: Optimizes format storage\n- **Transfer Optimization**: Improves data transfer\n- **Size Reduction**: Minimizes message size\n\n#### Structure Optimization\n- **Field Organization**: Optimizes field layout\n- **Index Management**: Implements efficient indexing\n- **Access Patterns**: Optimizes access paths\n- **Cache Efficiency**: Improves cache usage\n\n## Future Development & Evolution\n\n### 1. Planned Enhancements\nFuture development focuses on:\n\n#### Protocol Extensions\n- **New Formats**: Additional format support\n- **Enhanced Features**: Extended capabilities\n- **Better Integration**: Improved system integration\n- **Performance Updates**: Enhanced performance\n\n#### Security Improvements\n- **Advanced Signing**: Enhanced signature systems\n- **Better Verification**: Improved verification\n- **Security Features**: Additional security measures\n- **Protection Methods**: Enhanced protection\n\n### 2. System Evolution\nLong-term evolution plans include:\n\n#### Architecture Updates\n- **Component Refinement**: Enhanced components\n- **Better Integration**: Improved integration\n- **System Expansion**: Extended functionality\n- **Performance Evolution**: Continuous optimization\n\n#### Feature Development\n- **New Capabilities**: Additional features\n- **Enhanced Support**: Improved support\n- **Better Tools**: Advanced tooling\n- **Extended Functionality**: New functions\n"},"devices/name_identity/modules/dev_local_name.md":{"content":"# Module: dev_local_name\n\n## Basic Information\n- **Source File:** dev_local_name.erl\n- **Module Type:** Name Registration Device\n- **Purpose:** Manages local name registration and lookup functionality, providing a persistent naming system with caching capabilities.\n\n## Core Functionality\n\n### 1. Name Management Architecture\n```mermaid\ngraph TD\n    A[Local Name Device] --> B[Registration]\n    A --> C[Lookup]\n    A --> D[Cache Management]\n    \n    B --> E[Authorization Check]\n    B --> F[Name Storage]\n    B --> G[Cache Update]\n    \n    C --> H[Cache Lookup]\n    C --> I[Store Lookup]\n    C --> J[Value Resolution]\n    \n    D --> K[Cache Loading]\n    D --> L[Cache Updates]\n    D --> M[Persistence]\n```\n\n### 2. Registration System\n```erlang\n% Registration handler with authorization\nregister(_, Req, Opts) ->\n    case dev_meta:is_operator(Req, Opts) of\n        false ->\n            {error,\n                #{\n                    <<\"status\">> => 403,\n                    <<\"message\">> => <<\"Unauthorized.\">>\n                }\n            };\n        true ->\n            direct_register(Req, Opts)\n    end.\n\n% Direct registration implementation\ndirect_register(Req, Opts) ->\n    case hb_cache:write(Value = hb_ao:get(<<\"value\">>, Req, Opts), Opts) of\n        {ok, MsgPath} ->\n            % Link name to value\n            hb_cache:link(\n                MsgPath,\n                LinkPath = [?DEV_CACHE, Name = hb_ao:get(<<\"key\">>, Req, Opts)],\n                Opts\n            ),\n            % Update cache\n            load_names(Opts),\n            {ok, <<\"Registered.\">>};\n        {error, _} ->\n            not_found\n    end.\n```\n\n### 3. Lookup System\n```erlang\n% Name lookup implementation\nlookup(_, Req, Opts) ->\n    Key = hb_ao:get(<<\"key\">>, Req, no_key_specified, Opts),\n    ?event(local_name, {lookup, Key}),\n    hb_ao:resolve(\n        find_names(Opts),\n        Key,\n        Opts\n    ).\n\n% Default lookup handler\ndefault_lookup(Key, _, Req, Opts) ->\n    lookup(Key, Req#{ <<\"key\">> => Key }, Opts).\n```\n\n## Key Features\n\n### 1. Cache Management\n```erlang\n% Cache loading system\nload_names(Opts) ->\n    LocalNames =\n        maps:from_list(lists:map(\n            fun(Key) ->\n                ?event(local_name, {loading, Key}),\n                case hb_cache:read([?DEV_CACHE, Key], Opts) of\n                    {ok, Value} ->\n                        {Key, Value};\n                    {error, _} ->\n                        {Key, not_found}\n                end\n            end,\n            hb_cache:list(?DEV_CACHE, Opts)\n        )),\n    update_names(LocalNames, Opts).\n```\n\n### 2. Authorization Control\n- Operator verification\n- Access control\n- Permission management\n- Secure registration\n- Protected updates\n\n### 3. Persistence Layer\n- Cache storage\n- Link management\n- Value persistence\n- Name resolution\n- State preservation\n\n## Usage Examples\n\n### 1. Name Registration\n```erlang\n% Register a new name\nregister_example() ->\n    Opts = #{\n        store => [...],\n        priv_wallet => Wallet\n    },\n    register(\n        #{},\n        hb_message:commit(\n            #{\n                <<\"key\">> => <<\"example-name\">>,\n                <<\"value\">> => <<\"example-value\">>\n            },\n            Opts\n        ),\n        Opts\n    ).\n```\n\n### 2. Name Lookup\n```erlang\n% Look up a name\nlookup_example() ->\n    lookup(\n        #{},\n        #{\n            <<\"key\">> => <<\"example-name\">>\n        },\n        #{ local_names => LocalNames }\n    ).\n```\n\n### 3. HTTP Integration\n```erlang\n% HTTP-based operations\nhttp_example() ->\n    % Start node\n    Node = hb_http_server:start_node(Opts),\n    \n    % Register name\n    hb_http:post(\n        Node,\n        <<\"/~local-name@1.0/register\">>,\n        RegisterMessage,\n        Opts\n    ),\n    \n    % Look up name\n    hb_http:get(\n        Node,\n        <<\"/~local-name@1.0/lookup?key=name1\">>,\n        Opts\n    ).\n```\n\n## Integration Points\n\n### 1. System Integration\n```mermaid\ngraph TD\n    A[Local Name Device] --> B[Cache System]\n    A --> C[HTTP Server]\n    A --> D[Authorization]\n    \n    B --> E[Storage Layer]\n    B --> F[Link Management]\n    B --> G[Value Storage]\n    \n    C --> H[REST API]\n    C --> I[Message Handling]\n    C --> J[Response Format]\n    \n    D --> K[Operator Check]\n    D --> L[Access Control]\n    D --> M[Permission Management]\n```\n\n### 2. Dependencies\n- hb_cache: Cache operations\n- hb_ao: Message handling\n- dev_meta: Authorization\n- hb_http: HTTP integration\n- hb_message: Message formatting\n\n### 3. Event System\n- Registration events\n- Lookup events\n- Cache updates\n- Error handling\n- State changes\n\n## Error Handling\n\n### 1. Registration Errors\n- Unauthorized access\n- Invalid values\n- Storage failures\n- Cache errors\n- Link failures\n\n### 2. Lookup Errors\n- Missing names\n- Cache misses\n- Resolution failures\n- Invalid keys\n- System errors\n\n### 3. System Errors\n- Storage errors\n- Cache failures\n- HTTP errors\n- Authorization failures\n- State corruption\n\n## Performance Considerations\n\n### 1. Cache Optimization\n- Efficient loading\n- Quick lookups\n- Memory management\n- Update strategy\n- Cache invalidation\n\n### 2. Storage Efficiency\n- Link management\n- Value storage\n- Name resolution\n- State persistence\n- Resource usage\n\n### 3. Operation Impact\n- Registration overhead\n- Lookup performance\n- Cache updates\n- HTTP handling\n- Error recovery\n\n## Future Enhancements\n\n### 1. Feature Extensions\n- Advanced caching\n- Bulk operations\n- Pattern matching\n- Name validation\n- Value verification\n\n### 2. Integration\n- External systems\n- Monitoring tools\n- Analytics support\n- Backup systems\n- Recovery tools\n\n### 3. Development\n- Testing tools\n- Debug support\n- Documentation\n- Examples\n- Utilities\n\n## Security Considerations\n\n### 1. Access Control\n- Operator verification\n- Permission checks\n- Request validation\n- Resource protection\n- Error handling\n\n### 2. Data Protection\n- Secure storage\n- Safe transmission\n- Value protection\n- Cache security\n- Link integrity\n\n### 3. System Security\n- Authorization flow\n- Error handling\n- Resource limits\n- Input validation\n- State protection\n"}}