{"devices/resource_stack_management/modules/dev_stack.md":{"content":"# Module: dev_stack\n\n## Basic Information\n- **Source File:** dev_stack.erl\n- **Module Type:** Device Stack Manager\n- **Purpose:** Manages execution of device stacks, supporting both fold and map modes for processing messages through multiple devices sequentially or in parallel.\n\n## Core Functionality\n\n### 1. Stack Architecture\n```mermaid\ngraph TD\n    A[Device Stack] --> B[Mode Selection]\n    B --> C[Fold Mode]\n    B --> D[Map Mode]\n    \n    C --> E[Sequential Processing]\n    D --> F[Parallel Processing]\n    \n    E --> G[State Management]\n    E --> H[Pass Control]\n    \n    F --> I[Result Combination]\n    F --> J[Key Mapping]\n```\n\n### 2. Execution Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Stack\n    participant Device1\n    participant Device2\n    participant DeviceN\n    \n    Client->>Stack: Submit Message\n    \n    alt Fold Mode\n        Stack->>Device1: Process Message\n        Device1-->>Stack: Return State\n        Stack->>Device2: Process Updated State\n        Device2-->>Stack: Return State\n        Stack->>DeviceN: Process Final State\n        DeviceN-->>Stack: Return Result\n        Stack-->>Client: Return Final Result\n    else Map Mode\n        Stack->>Device1: Process Message\n        Stack->>Device2: Process Message\n        Stack->>DeviceN: Process Message\n        Device1-->>Stack: Return Result 1\n        Device2-->>Stack: Return Result 2\n        DeviceN-->>Stack: Return Result N\n        Stack-->>Client: Return Combined Results\n    end\n```\n\n## Implementation Details\n\n### 1. Stack Configuration\n```erlang\n% Stack device structure\n#{\n    \"device\" => \"Stack@1.0\",\n    \"device-stack\" => #{\n        \"1\" => Device1,\n        \"2\" => Device2,\n        \"N\" => DeviceN\n    },\n    \"mode\" => \"Fold\" | \"Map\"\n}\n```\n\n### 2. Mode Operations\n\n#### Fold Mode Processing\n```erlang\nresolve_fold(Message1, Message2, DevNum, Opts) ->\n    % Transform message for current device\n    {ok, Message3} = transform(Message1, DevNum, Opts),\n    \n    % Process through current device\n    case process_device(Message3, Message2, Opts) of\n        {ok, Message4} -> \n            % Continue to next device\n            resolve_fold(Message4, Message2, DevNum + 1, Opts);\n        {skip, Message4} ->\n            % Skip remaining devices\n            {ok, Message4};\n        {pass, Message4} ->\n            % Restart from first device\n            resolve_fold(Message4, Message2, 1, Opts)\n    end\n```\n\n#### Map Mode Processing\n```erlang\nresolve_map(Message1, Message2, Opts) ->\n    % Get device stack\n    DeviceStack = get_device_stack(Message1),\n    \n    % Process each device independently\n    Results = maps:map(\n        fun(Key, Device) ->\n            process_device(Device, Message2, Opts)\n        end,\n        DeviceStack\n    ),\n    \n    % Combine results\n    {ok, Results}\n```\n\n## Key Features\n\n### 1. Execution Modes\n\n#### Fold Mode\n- Sequential processing\n- State maintenance\n- Pass control\n- Skip capability\n- Error handling\n\n#### Map Mode\n- Parallel processing\n- Independent execution\n- Result combination\n- Key preservation\n- Error isolation\n\n### 2. State Management\n- Pass tracking\n- Prefix handling\n- Device tracking\n- Error strategies\n- Resource control\n\n### 3. Message Transformation\n- Device selection\n- State preservation\n- Prefix management\n- Path tracking\n- Identity maintenance\n\n## Usage Examples\n\n### 1. Fold Mode Stack\n```erlang\n% Create a fold mode stack\nStack = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"1\">> => DeviceOne,\n        <<\"2\">> => DeviceTwo\n    },\n    <<\"mode\">> => <<\"Fold\">>\n}\n\n% Execute stack\n{ok, Result} = hb_ao:resolve(Stack, Message, #{})\n```\n\n### 2. Map Mode Stack\n```erlang\n% Create a map mode stack\nStack = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"processor1\">> => Processor1,\n        <<\"processor2\">> => Processor2\n    },\n    <<\"mode\">> => <<\"Map\">>\n}\n\n% Execute stack\n{ok, Results} = hb_ao:resolve(Stack, Message, #{})\n```\n\n### 3. Pass Control Example\n```erlang\n% Create a stack with pass control\nStack = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"1\">> => PassingDevice,\n        <<\"2\">> => FinalDevice\n    },\n    <<\"allow-multipass\">> => true\n}\n\n% Execute with pass control\n{ok, Result} = hb_ao:resolve(Stack, Message, #{})\n```\n\n## Error Handling\n\n### 1. Device Errors\n- Error propagation\n- Strategy selection\n- State preservation\n- Recovery options\n- Logging support\n\n### 2. Stack Errors\n- Configuration validation\n- Mode verification\n- Pass control\n- Resource cleanup\n- State recovery\n\n### 3. Transform Errors\n- Device validation\n- Path verification\n- State preservation\n- Identity recovery\n- Resource cleanup\n\n## Performance Considerations\n\n### 1. Execution Efficiency\n- Mode selection\n- State management\n- Resource usage\n- Memory allocation\n- CPU utilization\n\n### 2. Resource Management\n- Connection pooling\n- Memory usage\n- State tracking\n- Device lifecycle\n- Resource cleanup\n\n### 3. Error Impact\n- Recovery speed\n- Resource release\n- State preservation\n- Path correction\n- Identity management\n\n## Future Improvements\n\n### 1. Feature Extensions\n- More execution modes\n- Better error handling\n- Enhanced monitoring\n- Resource optimization\n- Performance tracking\n\n### 2. Performance Optimization\n- Faster processing\n- Better resource use\n- Improved error handling\n- Enhanced monitoring\n- State management\n\n### 3. Integration Enhancement\n- More device types\n- Better coordination\n- Enhanced security\n- Improved monitoring\n- Better integration\n"},"devices/resource_stack_management/observations.md":{"content":"# Resource & Stack Management: System Observations\n\n## Architectural Patterns\n\n### 1. Device Composition\n```mermaid\ngraph TD\n    A[Resource Management] --> B[Stack Management]\n    A --> C[Push System]\n    A --> D[Lookup System]\n    A --> E[Manifest System]\n    \n    B --> F[Device Stacking]\n    B --> G[State Management]\n    \n    C --> H[Message Pushing]\n    C --> I[Process Control]\n    \n    D --> J[Cache Integration]\n    D --> K[Format Handling]\n    \n    E --> L[Path Resolution]\n    E --> M[Fallback Handling]\n```\n\nThe resource and stack management subsystem demonstrates several key architectural patterns:\n\n1. **Layered Device Management**\n   - Stack-based device organization\n   - Hierarchical execution flow\n   - State propagation\n   - Error handling\n   - Resource tracking\n\n2. **Message Flow Control**\n   - Push-based propagation\n   - Synchronous/asynchronous modes\n   - State maintenance\n   - Error recovery\n   - Resource optimization\n\n3. **Resource Resolution**\n   - Cache-based lookup\n   - Format conversion\n   - Path resolution\n   - Fallback mechanisms\n   - Error management\n\n## Component Integration\n\n### 1. Inter-Device Communication\n```mermaid\nsequenceDiagram\n    participant Stack as Stack Device\n    participant Push as Push System\n    participant Lookup as Lookup System\n    participant Manifest as Manifest System\n    participant Cache as Cache System\n    \n    Stack->>Push: Forward Message\n    Push->>Lookup: Resolve Target\n    Lookup->>Cache: Get Data\n    Cache-->>Lookup: Return Data\n    Lookup-->>Push: Return Resolution\n    Push->>Manifest: Check Path\n    Manifest->>Cache: Get Resource\n    Cache-->>Manifest: Return Resource\n    Manifest-->>Push: Return Data\n    Push-->>Stack: Complete Operation\n```\n\nThe components exhibit sophisticated integration patterns:\n\n1. **Stack-Push Integration**\n   - Message forwarding\n   - State tracking\n   - Error propagation\n   - Resource management\n   - Operation coordination\n\n2. **Push-Lookup Integration**\n   - Target resolution\n   - Cache coordination\n   - Format handling\n   - Error recovery\n   - Resource optimization\n\n3. **Manifest-Cache Integration**\n   - Path resolution\n   - Resource retrieval\n   - Fallback handling\n   - Format conversion\n   - Error management\n\n## Key Insights\n\n### 1. Design Patterns\n\n#### Stack Management\n- Flexible device composition\n- State propagation\n- Error handling\n- Resource tracking\n- Operation modes\n\n#### Push System\n- Message propagation\n- Process control\n- State management\n- Error recovery\n- Resource optimization\n\n#### Resource Resolution\n- Cache integration\n- Format handling\n- Path resolution\n- Fallback mechanisms\n- Error management\n\n### 2. System Characteristics\n\n#### Flexibility\n- Multiple operation modes\n- Format adaptability\n- Resource handling\n- Error recovery\n- State management\n\n#### Reliability\n- Error handling\n- State tracking\n- Resource management\n- Operation validation\n- Format verification\n\n#### Performance\n- Cache utilization\n- Resource optimization\n- Operation modes\n- State management\n- Error handling\n\n## Implementation Patterns\n\n### 1. Code Organization\n\n#### Module Structure\n- Clear responsibilities\n- Focused functionality\n- Error handling\n- Resource management\n- State tracking\n\n#### Integration Points\n- Well-defined interfaces\n- Clear dependencies\n- Error propagation\n- Resource sharing\n- State coordination\n\n#### Error Handling\n- Comprehensive coverage\n- Recovery mechanisms\n- State preservation\n- Resource cleanup\n- Operation validation\n\n### 2. Resource Management\n\n#### Cache Utilization\n- Efficient lookup\n- Format handling\n- Path resolution\n- Error recovery\n- State preservation\n\n#### State Management\n- Clear tracking\n- Error handling\n- Resource cleanup\n- Operation validation\n- Format verification\n\n#### Operation Control\n- Multiple modes\n- State tracking\n- Error handling\n- Resource management\n- Format handling\n\n## Future Considerations\n\n### 1. Enhancement Opportunities\n\n#### Stack Management\n- More operation modes\n- Better state tracking\n- Enhanced error handling\n- Improved resource management\n- Better format handling\n\n#### Push System\n- Enhanced propagation\n- Better state management\n- Improved error recovery\n- Resource optimization\n- Format handling\n\n#### Resource Resolution\n- Better cache integration\n- Enhanced format handling\n- Improved path resolution\n- Better fallback mechanisms\n- Enhanced error management\n\n### 2. Integration Improvements\n\n#### Component Coordination\n- Better integration\n- Enhanced state sharing\n- Improved error handling\n- Resource optimization\n- Format handling\n\n#### Resource Optimization\n- Better cache usage\n- Enhanced state management\n- Improved error recovery\n- Format optimization\n- Path resolution\n\n#### Error Handling\n- Better recovery\n- Enhanced state preservation\n- Improved resource cleanup\n- Format validation\n- Operation verification\n"},"devices/resource_stack_management/OVERVIEW.md":{"content":"# Resource & Stack Management: System Overview\n\n## Architectural Foundation\n\n### 1. System Architecture\n```mermaid\ngraph TD\n    A[Resource & Stack Management] --> B[Device Stack System]\n    A --> C[Message Push System]\n    A --> D[Resource Lookup System]\n    A --> E[Manifest Resolution System]\n    \n    B --> F[Stack Composition]\n    B --> G[State Management]\n    B --> H[Mode Control]\n    \n    C --> I[Message Propagation]\n    C --> J[Process Control]\n    C --> K[State Tracking]\n    \n    D --> L[Cache Integration]\n    D --> M[Format Handling]\n    D --> N[Error Recovery]\n    \n    E --> O[Path Resolution]\n    E --> P[Resource Access]\n    E --> Q[Fallback Handling]\n```\n\nThe Resource & Stack Management subsystem represents a sophisticated orchestration layer that manages device composition, message propagation, resource lookup, and manifest resolution. This system demonstrates several key architectural principles:\n\n1. **Layered Architecture**\n   - Clear separation of concerns between stacking, pushing, lookup, and manifest handling\n   - Well-defined interfaces between components\n   - Hierarchical organization of functionality\n   - Consistent error handling patterns\n   - Robust state management\n\n2. **Component Integration**\n   - Seamless interaction between stack and push systems\n   - Coordinated resource lookup and manifest resolution\n   - Unified error handling and recovery\n   - Shared state management\n   - Consistent format handling\n\n3. **Resource Management**\n   - Efficient cache utilization\n   - Optimized lookup patterns\n   - Smart fallback mechanisms\n   - Format conversion capabilities\n   - State preservation strategies\n\n## Core Components\n\n### 1. Device Stack System\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Stack\n    participant Device1\n    participant Device2\n    participant DeviceN\n    \n    Client->>Stack: Submit Request\n    Stack->>Stack: Select Mode\n    \n    alt Fold Mode\n        Stack->>Device1: Process\n        Device1-->>Stack: Return State\n        Stack->>Device2: Process\n        Device2-->>Stack: Return State\n        Stack->>DeviceN: Process\n        DeviceN-->>Stack: Return Result\n    else Map Mode\n        par Parallel Execution\n            Stack->>Device1: Process\n            Stack->>Device2: Process\n            Stack->>DeviceN: Process\n        end\n        Device1-->>Stack: Return Result\n        Device2-->>Stack: Return Result\n        DeviceN-->>Stack: Return Result\n        Stack->>Stack: Combine Results\n    end\n    \n    Stack-->>Client: Return Final Result\n```\n\nThe Device Stack System provides sophisticated device composition capabilities:\n\n1. **Stack Management**\n   - Dynamic device composition\n   - Flexible execution modes\n   - State propagation control\n   - Error handling strategies\n   - Resource optimization\n\n2. **Mode Control**\n   - Fold mode for sequential processing\n   - Map mode for parallel execution\n   - State maintenance mechanisms\n   - Error recovery patterns\n   - Resource management\n\n3. **State Handling**\n   - Consistent state tracking\n   - Error state management\n   - Resource state control\n   - Format state handling\n   - Operation validation\n\n### 2. Message Push System\n```mermaid\nsequenceDiagram\n    participant Source\n    participant Push\n    participant Target\n    participant Cache\n    \n    Source->>Push: Submit Message\n    Push->>Push: Determine Mode\n    \n    alt Synchronous\n        Push->>Target: Forward Message\n        Target-->>Push: Process Response\n        Push-->>Source: Return Result\n    else Asynchronous\n        Push->>Push: Spawn Process\n        Push-->>Source: Return Immediate\n        Push->>Target: Forward Message\n        Target-->>Push: Process Response\n        Push->>Cache: Store Result\n    end\n```\n\nThe Message Push System enables sophisticated message propagation:\n\n1. **Push Operations**\n   - Synchronous/asynchronous modes\n   - Process spawning control\n   - State maintenance\n   - Error handling\n   - Resource management\n\n2. **Process Control**\n   - Mode selection\n   - State tracking\n   - Error recovery\n   - Resource optimization\n   - Format handling\n\n3. **Integration Points**\n   - Stack coordination\n   - Cache integration\n   - Format handling\n   - Error propagation\n   - State sharing\n\n### 3. Resource Lookup System\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Lookup\n    participant Cache\n    participant Format\n    \n    Client->>Lookup: Request Resource\n    Lookup->>Cache: Check Cache\n    \n    alt Cache Hit\n        Cache-->>Lookup: Return Resource\n        Lookup->>Format: Convert Format\n        Format-->>Lookup: Return Formatted\n    else Cache Miss\n        Cache-->>Lookup: Not Found\n        Lookup->>Lookup: Handle Miss\n        Lookup->>Client: Return Error\n    end\n    \n    Lookup-->>Client: Return Result\n```\n\nThe Resource Lookup System provides efficient resource access:\n\n1. **Cache Integration**\n   - Efficient lookup\n   - Format handling\n   - Error recovery\n   - State management\n   - Resource optimization\n\n2. **Format Handling**\n   - Multiple format support\n   - Conversion capabilities\n   - Error handling\n   - State preservation\n   - Resource management\n\n3. **Error Management**\n   - Comprehensive recovery\n   - State preservation\n   - Resource cleanup\n   - Format validation\n   - Operation verification\n\n### 4. Manifest Resolution System\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Manifest\n    participant Path\n    participant Resource\n    \n    Client->>Manifest: Request Path\n    Manifest->>Path: Resolve Path\n    \n    alt Direct Path\n        Path->>Resource: Get Resource\n        Resource-->>Manifest: Return Resource\n    else Index Path\n        Path->>Path: Get Index\n        Path->>Resource: Get Resource\n        Resource-->>Manifest: Return Resource\n    else Not Found\n        Path->>Path: Get Fallback\n        Path->>Resource: Get Fallback\n        Resource-->>Manifest: Return Fallback\n    end\n    \n    Manifest-->>Client: Return Result\n```\n\nThe Manifest Resolution System enables sophisticated path handling:\n\n1. **Path Resolution**\n   - Index path handling\n   - Direct path resolution\n   - Fallback mechanisms\n   - Error recovery\n   - State management\n\n2. **Resource Access**\n   - Efficient retrieval\n   - Format handling\n   - Error recovery\n   - State preservation\n   - Resource optimization\n\n3. **Fallback Handling**\n   - Smart fallback selection\n   - State preservation\n   - Error recovery\n   - Format handling\n   - Resource management\n\n## Integration Patterns\n\n### 1. Component Coordination\n- Stack-Push integration for message propagation\n- Push-Lookup integration for resource access\n- Lookup-Manifest integration for path resolution\n- Manifest-Cache integration for resource retrieval\n- Cache-Format integration for data handling\n\n### 2. State Management\n- Consistent state tracking across components\n- Error state propagation and recovery\n- Resource state maintenance\n- Format state handling\n- Operation state validation\n\n### 3. Error Handling\n- Comprehensive error recovery strategies\n- State preservation during errors\n- Resource cleanup on failures\n- Format validation mechanisms\n- Operation verification patterns\n\n## Future Directions\n\n### 1. Enhancement Opportunities\n- Extended execution modes\n- Enhanced state tracking\n- Improved error handling\n- Better resource management\n- Advanced format handling\n\n### 2. Performance Optimization\n- Faster execution paths\n- Better resource utilization\n- Enhanced state management\n- Improved error recovery\n- Optimized format handling\n\n### 3. Integration Improvements\n- Better component coordination\n- Enhanced state sharing\n- Improved error handling\n- Optimized resource usage\n- Advanced format handling\n"},"devices/scheduling_control/modules/dev_cron.md":{"content":"# Module: dev_cron\n\n## Basic Information\n- **Source File:** dev_cron.erl\n- **Module Type:** Device Scheduling Control\n- **Purpose:** Device that enables processes to schedule self-calling messages without user interaction, supporting both one-time and recurring tasks\n\n## Interface\n\n### Public API\n```erlang\n% Task Management\n-export([once/3, every/3, stop/3]).\n% Information\n-export([info/1, info/3]).\n```\n\n## Core Functionality\n\n### 1. Task Types\n\n#### One-Time Tasks\n```erlang\nonce(_Msg1, Msg2, Opts) ->\n    case hb_ao:get(<<\"cron-path\">>, Msg2, Opts) of\n        not_found -> {error, <<\"No cron path found\">>};\n        CronPath ->\n            ReqMsgID = hb_message:id(Msg2, all),\n            ModifiedMsg2 = prepare_message(Msg2, CronPath),\n            Name = {<<\"cron@1.0\">>, ReqMsgID},\n            Pid = spawn(fun() -> once_worker(CronPath, ModifiedMsg2, Opts) end),\n            hb_name:register(Name, Pid),\n            {ok, ReqMsgID}\n    end\n```\n\n#### Recurring Tasks\n```erlang\nevery(_Msg1, Msg2, Opts) ->\n    case {get_path(Msg2), get_interval(Msg2)} of\n        {CronPath, IntervalString} ->\n            IntervalMillis = parse_time(IntervalString),\n            ReqMsgID = hb_message:id(Msg2, all),\n            ModifiedMsg2 = prepare_message(Msg2),\n            TracePID = hb_tracer:start_trace(),\n            Pid = spawn_worker(CronPath, ModifiedMsg2, Opts, IntervalMillis),\n            register_task(ReqMsgID, Pid),\n            {ok, ReqMsgID}\n    end\n```\n\n### 2. Task Control\n\n#### Task Stopping\n```erlang\nstop(_Msg1, Msg2, Opts) ->\n    case hb_ao:get(<<\"task\">>, Msg2, Opts) of\n        not_found -> {error, <<\"No task ID found\">>};\n        TaskID ->\n            Name = {<<\"cron@1.0\">>, TaskID},\n            case hb_name:lookup(Name) of\n                Pid when is_pid(Pid) ->\n                    exit(Pid, kill),\n                    hb_name:unregister(Name),\n                    success_response(TaskID);\n                undefined ->\n                    {error, <<\"Task not found\">>}\n            end\n    end\n```\n\n### 3. Worker Implementation\n\n#### One-Time Worker\n```erlang\nonce_worker(Path, Req, Opts) ->\n    TracePID = hb_tracer:start_trace(),\n    try\n        dev_meta:handle(Opts#{ trace => TracePID }, \n                       Req#{ <<\"path\">> => Path})\n    catch\n        Class:Reason:Stack ->\n            log_error(Path, Class, Reason, Stack),\n            throw({error, Class, Reason, Stack})\n    end\n```\n\n#### Recurring Worker\n```erlang\nevery_worker_loop(Path, Req, Opts, Interval) ->\n    execute_task(Path, Req, Opts),\n    timer:sleep(Interval),\n    every_worker_loop(Path, Req, Opts, Interval)\n```\n\n## Implementation Details\n\n### 1. Time Parsing\n```erlang\nparse_time(BinString) ->\n    [AmountStr, UnitStr] = binary:split(BinString, <<\"-\">>),\n    Amount = binary_to_integer(AmountStr),\n    case string:lowercase(binary_to_list(UnitStr)) of\n        \"millisecond\" ++ _ -> Amount;\n        \"second\" ++ _ -> Amount * 1000;\n        \"minute\" ++ _ -> Amount * 60 * 1000;\n        \"hour\" ++ _ -> Amount * 60 * 60 * 1000;\n        \"day\" ++ _ -> Amount * 24 * 60 * 60 * 1000;\n        _ -> throw({error, invalid_time_unit, UnitStr})\n    end\n```\n\n### 2. Task Registration Flow\n```mermaid\ngraph TD\n    A[Task Creation Request] --> B{Task Type}\n    B -->|Once| C[Create One-Time Worker]\n    B -->|Every| D[Create Recurring Worker]\n    C --> E[Generate Task ID]\n    D --> E\n    E --> F[Register with Name Service]\n    F --> G[Return Task ID]\n```\n\n### 3. Task Execution Flow\n```mermaid\ngraph TD\n    A[Task Worker] --> B{Task Type}\n    B -->|Once| C[Execute Single Task]\n    B -->|Every| D[Execute Recurring Task]\n    C --> E[Complete]\n    D --> F[Sleep]\n    F --> D\n```\n\n## Event Logging\n\n### 1. Task Management\n```erlang\n?event({cron_stopping_task, {task_id, TaskID}, {pid, Pid}})\n?event({cron_stop_lookup_error, {task_id, TaskID}, {error, Error}})\n```\n\n### 2. Task Execution\n```erlang\n?event({cron_every_worker_executing, {path, Path}, {req_id, ReqID}})\n?event({cron_every_worker_executed, {path, Path}, {result, Result}})\n?event({cron_every_worker_error, {path, Path}, {error, Error}})\n```\n\n## Testing Coverage\n\n### 1. One-Time Tasks\n```erlang\nonce_executed_test() ->\n    % Tests:\n    % - Task creation\n    % - Worker execution\n    % - State verification\n    % - Task completion\n```\n\n### 2. Recurring Tasks\n```erlang\nevery_worker_loop_test() ->\n    % Tests:\n    % - Task creation\n    % - Periodic execution\n    % - State updates\n    % - Interval timing\n```\n\n### 3. Task Control\n```erlang\nstop_once_test() ->\n    % Tests:\n    % - Task stopping\n    % - Process termination\n    % - Name unregistration\n    % - Error handling\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_name: Task registration\n- dev_meta: Task execution\n- hb_tracer: Execution tracing\n- hb_ao: Message handling\n- hb_message: Message operations\n\n### Usage Context\n- Called by scheduler system\n- Integrates with meta device\n- Manages task lifecycle\n- Handles message routing\n\n## Key Features\n\n### 1. Task Management\n- One-time execution\n- Recurring execution\n- Task identification\n- Task termination\n\n### 2. Time Handling\n- Interval parsing\n- Time unit conversion\n- Schedule management\n- Execution timing\n\n### 3. Error Handling\n- Task validation\n- Execution recovery\n- Error logging\n- State preservation\n\n### 4. Process Control\n- Worker spawning\n- Task registration\n- Process monitoring\n- Resource cleanup\n\n## Best Practices\n\n### 1. Task Creation\n- Validate parameters\n- Generate unique IDs\n- Register processes\n- Handle errors\n\n### 2. Task Execution\n- Monitor workers\n- Handle failures\n- Maintain state\n- Clean up resources\n\n### 3. Integration\n- Follow protocols\n- Handle timeouts\n- Log operations\n- Manage resources\n"},"devices/scheduling_control/modules/dev_multipass.md":{"content":"# Module: dev_multipass\n\n## Basic Information\n- **Source File:** dev_multipass.erl\n- **Module Type:** Device Scheduling Control\n- **Purpose:** Device that manages sequential execution passes across devices by triggering repass events until a specified counter is reached\n\n## Interface\n\n### Public API\n```erlang\n-export([info/1]).\n```\n\n## Core Functionality\n\n### 1. Device Information\n```erlang\ninfo(_M1) ->\n    #{\n        handler => fun handle/4\n    }\n```\n\n### 2. Message Handling\n\n#### Operation Types\n```erlang\nhandle(<<\"keys\">>, M1, _M2, _Opts) ->\n    % Forward key operations to message device\n    dev_message:keys(M1);\n\nhandle(<<\"set\">>, M1, M2, Opts) ->\n    % Forward set operations to message device\n    dev_message:set(M1, M2, Opts);\n\nhandle(_Key, M1, _M2, Opts) ->\n    % Handle pass control for other operations\n    Passes = hb_ao:get(<<\"passes\">>, {as, dev_message, M1}, 1, Opts),\n    Pass = hb_ao:get(<<\"pass\">>, {as, dev_message, M1}, 1, Opts),\n    case Pass < Passes of\n        true -> {pass, M1};  % Continue to next pass\n        false -> {ok, M1}    % All passes complete\n    end\n```\n\n## Implementation Details\n\n### 1. Pass Control Flow\n```mermaid\ngraph TD\n    A[Message Received] --> B{Operation Type?}\n    B -->|keys| C[Forward to Message Device]\n    B -->|set| D[Forward to Message Device]\n    B -->|other| E[Check Pass Count]\n    E --> F{Current < Total?}\n    F -->|Yes| G[Return pass]\n    F -->|No| H[Return ok]\n```\n\n### 2. Message Structure\n```erlang\n#{\n    <<\"device\">> => <<\"Multipass@1.0\">>,\n    <<\"passes\">> => TotalPasses,    % Total passes required\n    <<\"pass\">> => CurrentPass      % Current pass number\n}\n```\n\n### 3. Pass Progression\n```mermaid\nsequenceDiagram\n    participant D as Device\n    participant M as Multipass\n    participant S as Stack\n    \n    D->>M: Message (pass=1)\n    M-->>S: {pass, Message}\n    Note over S: Process pass 1\n    D->>M: Message (pass=2)\n    M-->>S: {ok, Message}\n    Note over S: Complete processing\n```\n\n## Testing Coverage\n\n### 1. Basic Operation\n```erlang\nbasic_multipass_test() ->\n    % Test message with 2 passes\n    Msg1 = #{\n        <<\"device\">> => <<\"Multipass@1.0\">>,\n        <<\"passes\">> => 2,\n        <<\"pass\">> => 1\n    },\n    % First pass should continue\n    ?assertMatch({pass, _}, hb_ao:resolve(Msg1, <<\"Compute\">>, #{})),\n    \n    % Second pass should complete\n    Msg2 = Msg1#{ <<\"pass\">> => 2 },\n    ?assertMatch({ok, _}, hb_ao:resolve(Msg2, <<\"Compute\">>, #{}))\n```\n\n## Integration Points\n\n### Direct Dependencies\n- dev_message: Message operations\n- hb_ao: Message access\n- hb_util: Utility functions\n\n### Usage Context\n- Used by stack devices\n- Integrates with message system\n- Controls execution flow\n- Manages pass progression\n\n## Key Features\n\n### 1. Pass Management\n- Multiple pass support\n- Pass counting\n- Progress tracking\n- Completion detection\n\n### 2. Message Handling\n- Operation forwarding\n- State maintenance\n- Pass control\n- Flow management\n\n### 3. Integration\n- Device compatibility\n- Stack coordination\n- Message routing\n- State tracking\n\n### 4. Control Flow\n- Sequential execution\n- Pass progression\n- Operation routing\n- State management\n\n## Best Practices\n\n### 1. Pass Configuration\n- Set appropriate pass count\n- Track pass numbers\n- Handle completion\n- Manage state\n\n### 2. Message Structure\n- Include device info\n- Set pass parameters\n- Track progress\n- Maintain state\n\n### 3. Integration\n- Forward operations\n- Handle responses\n- Manage flow\n- Track state\n\n## Use Cases\n\n### 1. Sequential Processing\n```erlang\n% Example: Three-pass processing\nMessage = #{\n    <<\"device\">> => <<\"Multipass@1.0\">>,\n    <<\"passes\">> => 3,\n    <<\"pass\">> => 1,\n    <<\"data\">> => Data\n}\n% Pass 1: Initial processing\n% Pass 2: Refinement\n% Pass 3: Finalization\n```\n\n### 2. Stack Coordination\n```erlang\n% Example: Multi-device stack\nStack = [\n    #{<<\"device\">> => <<\"Multipass@1.0\">>, <<\"passes\">> => 2},\n    #{<<\"device\">> => <<\"ProcessorA@1.0\">>},\n    #{<<\"device\">> => <<\"ProcessorB@1.0\">>}\n]\n% Pass 1: ProcessorA then ProcessorB\n% Pass 2: ProcessorA then ProcessorB again\n```\n\n### 3. Flow Control\n```erlang\n% Example: Conditional processing\nMessage = #{\n    <<\"device\">> => <<\"Multipass@1.0\">>,\n    <<\"passes\">> => PassCount,\n    <<\"pass\">> => CurrentPass,\n    <<\"condition\">> => Condition\n}\n% Process until condition met or passes complete\n"},"devices/scheduling_control/modules/dev_scheduler_cache.md":{"content":"# Module: dev_scheduler_cache\n\n## Basic Information\n- **Source File:** dev_scheduler_cache.erl\n- **Module Type:** Device Scheduling Control\n- **Purpose:** Manages caching of process assignments and scheduler locations with symlink-based organization\n\n## Interface\n\n### Public API\n```erlang\n% Assignment operations\n-export([write/2, read/3, list/2, latest/2]).\n% Location operations\n-export([read_location/2, write_location/2]).\n```\n\n## Core Functionality\n\n### 1. Assignment Management\n\n#### Writing Assignments\n```erlang\nwrite(Assignment, Opts) ->\n    Store = hb_opts:get(store, no_viable_store, Opts),\n    ProcID = hb_ao:get(<<\"process\">>, Assignment),\n    Slot = hb_ao:get(<<\"slot\">>, Assignment),\n    \n    % Write to main cache\n    case hb_cache:write(Assignment, Opts) of\n        {ok, RootPath} ->\n            % Create symlink for process-specific access\n            hb_store:make_link(\n                Store,\n                RootPath,\n                hb_store:path(Store, [\n                    <<\"assignments\">>,\n                    hb_util:human_id(ProcID),\n                    hb_ao:normalize_key(Slot)\n                ])\n            ),\n            ok;\n        {error, Reason} -> {error, Reason}\n    end\n```\n\n#### Reading Assignments\n```erlang\nread(ProcID, Slot, Opts) ->\n    Store = hb_opts:get(store, no_viable_store, Opts),\n    ResolvedPath = hb_store:resolve(\n        Store,\n        hb_store:path(Store, [\n            \"assignments\",\n            hb_util:human_id(ProcID),\n            Slot\n        ])\n    ),\n    \n    case hb_cache:read(ResolvedPath, Opts) of\n        {ok, Assignment} ->\n            % Handle AOS2 format conversion if needed\n            case hb_ao:get(<<\"slot\">>, Assignment, Opts) of\n                not_found ->\n                    {ok, dev_scheduler_formats:aos2_normalize_types(Assignment)};\n                _ ->\n                    {ok, Assignment}\n            end;\n        not_found -> not_found\n    end\n```\n\n### 2. Location Management\n\n#### Writing Locations\n```erlang\nwrite_location(LocationMsg, Opts) ->\n    case hb_cache:write(LocationMsg, Opts) of\n        {ok, RootPath} ->\n            % Create symlinks for each signer\n            lists:foreach(\n                fun(Signer) ->\n                    hb_store:make_link(\n                        Store,\n                        RootPath,\n                        hb_store:path(Store, [\n                            \"scheduler-locations\",\n                            hb_util:human_id(Signer)\n                        ])\n                    )\n                end,\n                hb_message:signers(LocationMsg)\n            ),\n            ok;\n        {error, Reason} -> {error, Reason}\n    end\n```\n\n#### Reading Locations\n```erlang\nread_location(Address, Opts) ->\n    hb_cache:read(\n        hb_store:path(Store, [\n            \"scheduler-locations\",\n            hb_util:human_id(Address)\n        ]),\n        Opts\n    )\n```\n\n## Implementation Details\n\n### 1. Storage Structure\n\n#### Assignment Storage\n```\nassignments/\n  ├── {process_id}/\n  │   ├── 1  -> {root_path}/assignment1\n  │   ├── 2  -> {root_path}/assignment2\n  │   └── ...\n  └── ...\n```\n\n#### Location Storage\n```\nscheduler-locations/\n  ├── {signer1} -> {root_path}/location1\n  ├── {signer2} -> {root_path}/location2\n  └── ...\n```\n\n### 2. Assignment Listing\n\n```erlang\nlist(ProcID, Opts) ->\n    hb_cache:list_numbered(\n        hb_store:path(Store, [\n            \"assignments\",\n            hb_util:human_id(ProcID)\n        ]),\n        Opts\n    )\n```\n\n### 3. Latest Assignment Retrieval\n\n```erlang\nlatest(ProcID, Opts) ->\n    case list(ProcID, Opts) of\n        [] -> not_found;\n        Assignments ->\n            AssignmentNum = lists:max(Assignments),\n            {ok, Assignment} = read(ProcID, AssignmentNum, Opts),\n            {\n                AssignmentNum,\n                hb_ao:get(<<\"hash-chain\">>, Assignment, #{hashpath => ignore})\n            }\n    end\n```\n\n## Event Logging\n\n### 1. Assignment Operations\n```erlang\n?event({writing_assignment, {proc_id, ProcID}, {slot, Slot}, {assignment, Assignment}})\n?event(error, {failed_to_write_assignment, {reason, Reason}})\n?event({getting_assignments_from_cache, {proc_id, ProcID}, {opts, Opts}})\n?event({no_assignments_in_cache, {proc_id, ProcID}})\n```\n\n### 2. Location Operations\n```erlang\n?event({read_location_msg, {address, Address}, {res, Res}})\n?event({writing_location_msg, {signers, Signers}, {location_msg, LocationMsg}})\n?event(warning, {failed_to_cache_location_msg, {reason, Reason}})\n```\n\n### 3. Path Resolution\n```erlang\n?event({resolved_path, {p1, P1}, {p2, P2}, {resolved, ResolvedPath}})\n?event(debug_sched, {read_assignment, {res, not_found}})\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_cache: Core caching functionality\n- hb_store: Storage abstraction\n- hb_ao: Message operations\n- hb_message: Message handling\n- dev_scheduler_formats: Format conversion\n\n### Usage Context\n- Called by dev_scheduler_server\n- Integrates with storage system\n- Manages assignment persistence\n- Handles location caching\n\n## Key Features\n\n### 1. Storage Organization\n- Symlink-based structure\n- Process-specific paths\n- Slot-based organization\n- Signer-based location access\n\n### 2. Format Handling\n- AOS2 format support\n- Type normalization\n- Path resolution\n- Key normalization\n\n### 3. Performance\n- Efficient lookups\n- Quick latest retrieval\n- Optimized listing\n- Cached access\n\n### 4. Reliability\n- Error handling\n- Path validation\n- Format verification\n- State consistency\n\n## Best Practices\n\n### 1. Storage Management\n- Use proper paths\n- Handle symlinks\n- Validate formats\n- Clean up resources\n\n### 2. Error Handling\n- Check store availability\n- Validate paths\n- Handle format errors\n- Log failures\n\n### 3. Integration\n- Verify message format\n- Handle conversions\n- Maintain consistency\n- Monitor operations\n"},"devices/scheduling_control/modules/dev_scheduler_formats.md":{"content":"# Module: dev_scheduler_formats\n\n## Basic Information\n- **Source File:** dev_scheduler_formats.erl\n- **Module Type:** Device Scheduling Control\n- **Purpose:** Handles format conversion and compatibility between different AO client formats for scheduler responses\n\n## Interface\n\n### Public API\n```erlang\n% Format conversion\n-export([assignments_to_bundle/4, assignments_to_aos2/4]).\n-export([aos2_to_assignments/3, aos2_to_assignment/2]).\n% Type normalization\n-export([aos2_normalize_types/1]).\n```\n\n## Core Functionality\n\n### 1. Format Types\n\n#### HTTP Bundle Format\n```erlang\nassignments_to_bundle(ProcID, Assignments, More, Opts) ->\n    {Timestamp, Height, Hash} = ar_timestamp:get(),\n    {ok, #{\n        <<\"type\">> => <<\"schedule\">>,\n        <<\"process\">> => ProcID,\n        <<\"continues\">> => More,\n        <<\"timestamp\">> => Timestamp,\n        <<\"block-height\">> => Height,\n        <<\"block-hash\">> => Hash,\n        <<\"assignments\">> => AssignmentMap\n    }}\n```\n\n#### AOS2 JSON Format\n```erlang\nassignments_to_aos2(ProcID, Assignments, More, Opts) ->\n    {ok, #{\n        <<\"content-type\">> => <<\"application/json\">>,\n        <<\"body\">> => #{\n            <<\"page_info\">> => #{\n                <<\"process\">> => ProcID,\n                <<\"has_next_page\">> => More,\n                <<\"timestamp\">> => Timestamp,\n                <<\"block-height\">> => Height,\n                <<\"block-hash\">> => Hash\n            },\n            <<\"edges\">> => AssignmentEdges\n        }\n    }}\n```\n\n### 2. Format Conversion\n\n#### Bundle to AOS2\n```erlang\nassignment_to_aos2(Assignment, Opts) ->\n    Message = hb_ao:get(<<\"body\">>, Assignment, Opts),\n    AssignmentWithoutBody = maps:without([<<\"body\">>], Assignment),\n    #{\n        <<\"message\">> => dev_json_iface:message_to_json_struct(Message),\n        <<\"assignment\">> => dev_json_iface:message_to_json_struct(AssignmentWithoutBody)\n    }\n```\n\n#### AOS2 to Bundle\n```erlang\naos2_to_assignments(ProcID, Body, Opts) ->\n    % Extract assignments from edges\n    Assignments = maps:get(<<\"edges\">>, Body),\n    ParsedAssignments = lists:map(\n        fun(A) -> aos2_to_assignment(A, Opts) end,\n        Assignments\n    ),\n    \n    % Get time info from last assignment or use defaults\n    TimeInfo = get_time_info(ParsedAssignments),\n    \n    % Convert to bundle format\n    assignments_to_bundle(ProcID, ParsedAssignments, false, TimeInfo, Opts)\n```\n\n### 3. Type Normalization\n\n```erlang\naos2_normalize_types(Msg) ->\n    % Convert timestamp from binary to integer\n    normalize_timestamp(Msg),\n    \n    % Convert nonce to slot if needed\n    normalize_nonce(Msg),\n    \n    % Convert epoch from binary to integer\n    normalize_epoch(Msg),\n    \n    % Convert slot from binary to integer\n    normalize_slot(Msg),\n    \n    % Ensure block hash exists\n    ensure_block_hash(Msg)\n```\n\n## Implementation Details\n\n### 1. Format Options\n```erlang\nformat_opts(Opts) ->\n    Opts#{\n        hashpath => ignore,\n        cache_control => [<<\"no-cache\">>, <<\"no-store\">>],\n        await_inprogress => false\n    }\n```\n\n### 2. Cursor Generation\n```erlang\ncursor(Assignment, Opts) ->\n    % Use slot number for ao.N.1\n    % Use assignment ID for ao.TN.1\n    hb_ao:get(<<\"slot\">>, Assignment, Opts)\n```\n\n### 3. Data Normalization\n```erlang\naos2_normalize_data(JSONStruct) ->\n    % Ensure data field exists\n    case JSONStruct of\n        #{<<\"data\">> := _} -> JSONStruct;\n        _ -> JSONStruct#{ <<\"data\">> => <<>> }\n    end\n```\n\n## Event Logging\n\n### 1. Format Conversion\n```erlang\n?event({body_struct, BodyStruct})\n?event({encoded, {explicit, Encoded}})\n?event({raw_assignments, Assignments})\n?event({parsed_assignments, ParsedAssignments})\n```\n\n### 2. Error Handling\n```erlang\n?event(error, {scheduler_did_not_provide_message, MessageID})\n?event({missing_block_hash, Msg})\n```\n\n### 3. Type Normalization\n```erlang\n?event({aos2_normalized_types, {msg, Msg}, {anchor, Anchor}})\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_ao: Message operations\n- hb_json: JSON encoding/decoding\n- hb_gateway_client: Message conversion\n- dev_json_iface: JSON structure conversion\n- ar_timestamp: Block information\n\n### Usage Context\n- Called by dev_scheduler\n- Used by dev_scheduler_cache\n- Integrates with gateway client\n- Handles format compatibility\n\n## Key Features\n\n### 1. Format Support\n- HTTP bundle format\n- AOS2 JSON format\n- Legacy compatibility\n- Format conversion\n\n### 2. Type Handling\n- Binary to integer conversion\n- Field normalization\n- Type verification\n- Default values\n\n### 3. Performance\n- Efficient conversion\n- Minimal copying\n- Cached options\n- Optimized structures\n\n### 4. Compatibility\n- Legacy support\n- Format detection\n- Type coercion\n- Field mapping\n\n## Best Practices\n\n### 1. Format Conversion\n- Validate input format\n- Preserve data integrity\n- Handle missing fields\n- Maintain compatibility\n\n### 2. Type Normalization\n- Check field types\n- Convert consistently\n- Handle edge cases\n- Provide defaults\n\n### 3. Integration\n- Follow format specs\n- Handle errors gracefully\n- Log conversions\n- Maintain compatibility\n"},"devices/scheduling_control/modules/dev_scheduler_registry.md":{"content":"# Module: dev_scheduler_registry\n\n## Basic Information\n- **Source File:** dev_scheduler_registry.erl\n- **Module Type:** Device Scheduling Control\n- **Purpose:** Simple registry for local AO services using process groups, currently focused on scheduler unit (SU) processes\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([start/0, find/1, find/2, find/3]).\n% Information retrieval\n-export([get_wallet/0, get_processes/0]).\n```\n\n## Core Functionality\n\n### 1. Registry Management\n\n#### Initialization\n```erlang\nstart() ->\n    hb_name:start(),\n    ok\n```\n\n#### Process Lookup\n```erlang\nfind(ProcID) -> find(ProcID, false).\nfind(ProcID, GenIfNotHosted) ->\n    find(ProcID, GenIfNotHosted, #{ priv_wallet => hb:wallet() }).\nfind(ProcID, GenIfNotHosted, Opts) ->\n    case hb_name:lookup({dev_scheduler, ProcID}) of\n        undefined -> maybe_new_proc(ProcID, GenIfNotHosted, Opts);\n        Pid -> Pid\n    end\n```\n\n### 2. Process Creation\n\n#### Conditional Creation\n```erlang\nmaybe_new_proc(_ProcID, false, _Opts) -> \n    not_found;\nmaybe_new_proc(ProcID, _GenIfNotHosted, Opts) -> \n    dev_scheduler_server:start(ProcID, Opts)\n```\n\n### 3. Information Retrieval\n\n#### Wallet Access\n```erlang\nget_wallet() ->\n    % TODO: Future support for multiple wallets per SU\n    hb:wallet()\n```\n\n#### Process Listing\n```erlang\nget_processes() ->\n    [ ProcID || {{dev_scheduler, ProcID}, _} <- hb_name:all() ]\n```\n\n## Implementation Details\n\n### 1. Process Registration\n- Uses hb_name for process registration\n- Stores processes under {dev_scheduler, ProcID} key\n- Maintains unique PIDs per process ID\n\n### 2. Process Creation Flow\n```mermaid\ngraph TD\n    A[Find Request] --> B{Process Exists?}\n    B -->|Yes| C[Return PID]\n    B -->|No| D{Generate If Not Hosted?}\n    D -->|Yes| E[Start New Server]\n    D -->|No| F[Return not_found]\n    E --> G[Return New PID]\n```\n\n### 3. Process Lookup Flow\n```mermaid\ngraph TD\n    A[Lookup Request] --> B[Check hb_name]\n    B --> C{Found?}\n    C -->|Yes| D[Return PID]\n    C -->|No| E[Check Generation Flag]\n    E -->|True| F[Create New]\n    E -->|False| G[Return not_found]\n```\n\n## Event Logging\n\n### 1. Process Management\n```erlang\n?event({getting_processes, hb_name:all()})\n?event({processes, Processes})\n```\n\n## Testing Coverage\n\n### 1. Basic Operations\n```erlang\nfind_non_existent_process_test() ->\n    % Tests lookup of non-existent process\n    % Verifies not_found return\n\ncreate_and_find_process_test() ->\n    % Tests process creation\n    % Verifies PID return\n    % Confirms consistent lookup\n```\n\n### 2. Multiple Processes\n```erlang\ncreate_multiple_processes_test() ->\n    % Tests multiple process creation\n    % Verifies unique PIDs\n    % Confirms consistent lookups\n```\n\n### 3. Process Listing\n```erlang\nget_all_processes_test() ->\n    % Tests process listing\n    % Verifies list contents\n    % Confirms process inclusion\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_name: Process registration\n- dev_scheduler_server: Server creation\n- hb: Wallet management\n- pg: Process groups\n\n### Usage Context\n- Called by dev_scheduler\n- Used by scheduler servers\n- Integrates with name service\n- Manages process lifecycle\n\n## Key Features\n\n### 1. Process Management\n- Unique process IDs\n- Conditional creation\n- PID lookup\n- Process listing\n\n### 2. Registration\n- Name-based registration\n- Process group integration\n- Lookup services\n- Creation control\n\n### 3. Configuration\n- Wallet management\n- Server options\n- Creation flags\n- Process tracking\n\n### 4. Reliability\n- Process verification\n- Unique registration\n- Lookup consistency\n- State management\n\n## Best Practices\n\n### 1. Process Management\n- Verify process existence\n- Handle creation flags\n- Track registrations\n- Clean up resources\n\n### 2. Error Handling\n- Check registration status\n- Validate process IDs\n- Handle lookup failures\n- Manage creation errors\n\n### 3. Integration\n- Coordinate with name service\n- Manage server creation\n- Track process state\n- Monitor registrations\n\n## Future Enhancements\n\n### 1. Planned Improvements\n- Multiple wallets per SU\n- Enhanced process tracking\n- Better state management\n- More service types\n\n### 2. Potential Features\n- Process monitoring\n- State persistence\n- Service discovery\n- Load balancing\n"}}