{"core/storage_caching/modules/hb_cache_render.md":{"content":"# Module: hb_cache_render\n\n## Basic Information\n- **Source File:** hb_cache_render.erl\n- **Module Type:** Core Storage & Caching\n- **Purpose:** Visualization tool for cache key graphs\n\n## Purpose\nProvides functionality to render cache key graphs into DOT and SVG formats, enabling visual inspection of cache structure and relationships. This module helps developers understand and debug cache hierarchies by generating visual representations of the cache's internal organization.\n\n## Interface\n\n### Core Operations\n- `render/1,2` - Render key graph to SVG and display\n- `cache_path_to_dot/2,3` - Convert cache path to DOT format\n- `dot_to_svg/1` - Convert DOT graph to SVG format\n\n### Test Data Generation\n- `prepare_unsigned_data/0` - Create test unsigned data\n- `prepare_signed_data/0` - Create test signed data\n- `prepare_deeply_nested_complex_message/0` - Create complex test data\n\n## Dependencies\n\n### Direct Dependencies\n- hb_store: Storage access\n- hb_util: Utility functions\n- hb_message: Message handling\n- file: File operations\n- os: System commands\n\n### Inverse Dependencies\n- Used by debugging tools\n- Cache visualization\n- Development utilities\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Graph Generation**\n   ```erlang\n   % Convert cache structure to graph\n   cache_path_to_graph(ToRender, GraphOpts, Store) ->\n       % Collect nodes and arcs recursively\n       traverse_store(Store, Key, Parent, Graph)\n   ```\n\n2. **Node Types**\n   ```erlang\n   % Simple nodes (leaf nodes)\n   process_simple_node(Store, Key, Parent, Path, Graph)\n   \n   % Composite nodes (directories)\n   process_composite_node(Store, Key, Parent, Path, Graph)\n   ```\n\n3. **Graph Visualization**\n   ```erlang\n   % Generate DOT format\n   graph_to_dot(Graph) ->\n       % Create nodes and arcs\n       [Header, Nodes, Arcs, Footer]\n   ```\n\n### State Management\n\n1. **Graph Building**\n   - Node tracking\n   - Arc management\n   - Cycle detection\n   - Path resolution\n\n2. **Visualization State**\n   - DOT generation\n   - SVG conversion\n   - File handling\n   - Display management\n\n3. **Test Data**\n   - Message creation\n   - Data structure\n   - Store population\n   - State verification\n\n### Error Handling\n\n1. **Graph Generation**\n   - Cycle detection\n   - Invalid paths\n   - Missing nodes\n   - State validation\n\n2. **Visualization**\n   - DOT errors\n   - SVG conversion\n   - File operations\n   - Display failures\n\n## Integration Points\n\n1. **Storage System**\n   - Path resolution\n   - Type detection\n   - Content access\n   - State tracking\n\n2. **Visualization System**\n   - DOT generation\n   - SVG conversion\n   - File handling\n   - Display management\n\n3. **Test System**\n   - Data generation\n   - Structure creation\n   - State population\n   - Verification\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Graph Generation**\n   - Cycle avoidance\n   - Path optimization\n   - State tracking\n   - Memory management\n\n2. **Visualization**\n   - DOT efficiency\n   - SVG conversion\n   - File handling\n   - Display speed\n\n### Security Implications\n\n1. **File Operations**\n   - Path validation\n   - File permissions\n   - Command execution\n   - State protection\n\n2. **Data Access**\n   - Store access\n   - Path validation\n   - Content protection\n   - State isolation\n\n### Best Practices\n\n1. **Graph Generation**\n   - Handle cycles\n   - Validate paths\n   - Track state\n   - Manage memory\n\n2. **Visualization**\n   - Use appropriate formats\n   - Handle errors\n   - Validate output\n   - Clean up files\n\n3. **Testing**\n   - Create varied data\n   - Validate structures\n   - Check output\n   - Clean up state\n\n### Example Usage\n\n```erlang\n% Basic rendering of all cache paths\nhb_cache_render:render(Store),\n\n% Render specific path\nhb_cache_render:render(<<\"specific/path\">>, Store),\n\n% Generate DOT without rendering\nDot = hb_cache_render:cache_path_to_dot(Path, Store),\n\n% Custom rendering options\nOpts = #{render_data => false},\nhb_cache_render:cache_path_to_dot(Path, Opts, Store),\n\n% Test data generation\nhb_cache_render:prepare_deeply_nested_complex_message(),\nhb_cache_render:render(Store)  % View the complex structure\n"},"core/storage_caching/modules/hb_cache.md":{"content":"# Module: hb_cache\n\n## Basic Information\n- **Source File:** hb_cache.erl\n- **Module Type:** Core Storage & Caching\n- **Purpose:** Cache management for AO-Core protocol messages and compute results\n\n## Purpose\nProvides a sophisticated caching system for HyperBEAM that manages three layers of data representation:\n1. Raw binary data stored at content hashes for deduplication\n2. Hashpath-graph linking content through hashpaths and keys\n3. Message storage with both committed and uncommitted IDs\n\n## Interface\n\n### Core Operations\n- `read/2` - Read message from cache\n- `write/2` - Write message to cache\n- `read_resolved/3` - Read computation output\n- `list/2` - List items under path\n\n### Data Operations\n- `write_binary/3` - Write raw binary data\n- `write_hashpath/2` - Write message with hashpath\n- `link/3` - Create link between paths\n- `list_numbered/2` - List numbered items\n\n## Dependencies\n\n### Direct Dependencies\n- hb_store: Storage abstraction\n- hb_message: Message handling\n- hb_path: Path manipulation\n- dev_message: Message operations\n- dev_codec_structured: Format conversion\n\n### Inverse Dependencies\n- Used by compute system\n- Core caching component\n- Message persistence layer\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Data Layers**\n   ```erlang\n   % Layer 1: Raw binary at content hash\n   write_binary(HashPath, Data, Store)\n   \n   % Layer 2: Hashpath graph links\n   write_hashpath(HashPath, Message, Store)\n   \n   % Layer 3: Message IDs and commitments\n   write(Message, #{store => Store})\n   ```\n\n2. **Message Storage**\n   ```erlang\n   % Write message with commitments\n   AllIDs = calculate_all_ids(Message, Opts),\n   {ok, UncommittedID} = do_write_message(Message, AllIDs, Store)\n   ```\n\n3. **Type-Annotated Binary Messages (TABM)**\n   ```erlang\n   % Convert to TABM before storage\n   Tabm = hb_message:convert(Msg, tabm, <<\"structured@1.0\">>, Opts)\n   ```\n\n### State Management\n\n1. **Content Storage**\n   - Hash-based deduplication\n   - Binary content storage\n   - Path management\n   - Link resolution\n\n2. **Message State**\n   - Commitment tracking\n   - ID management\n   - Path resolution\n   - Cache invalidation\n\n3. **Hashpath Graph**\n   - Path linking\n   - Graph traversal\n   - State tracking\n   - Cycle detection\n\n### Error Handling\n\n1. **Storage Errors**\n   - Missing content\n   - Invalid paths\n   - Broken links\n   - Circular references\n\n2. **Message Validation**\n   - Format checking\n   - Type validation\n   - Path verification\n   - State consistency\n\n## Integration Points\n\n1. **Storage System**\n   - Multiple backends\n   - Path resolution\n   - Content storage\n   - Link management\n\n2. **Message System**\n   - Format conversion\n   - State tracking\n   - ID management\n   - Commitment handling\n\n3. **Compute System**\n   - Result caching\n   - State persistence\n   - Path resolution\n   - Output management\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Content Storage**\n   - Deduplication\n   - Path optimization\n   - Link efficiency\n   - Cache utilization\n\n2. **Message Handling**\n   - Format conversion\n   - State tracking\n   - Path resolution\n   - Graph traversal\n\n### Security Implications\n\n1. **Content Validation**\n   - Path verification\n   - Link checking\n   - Type validation\n   - State consistency\n\n2. **Message Protection**\n   - Commitment validation\n   - ID verification\n   - Path security\n   - State isolation\n\n### Best Practices\n\n1. **Cache Usage**\n   - Enable deduplication\n   - Manage paths\n   - Handle links\n   - Track state\n\n2. **Message Handling**\n   - Validate formats\n   - Check types\n   - Resolve paths\n   - Manage commitments\n\n3. **Error Management**\n   - Check paths\n   - Validate links\n   - Handle cycles\n   - Maintain state\n\n### Example Usage\n\n```erlang\n% Write binary content\n{ok, Path} = hb_cache:write_binary(HashPath, Data, Opts),\n\n% Write message with commitments\n{ok, ID} = hb_cache:write(Message, #{\n    store => Store,\n    wallet => Wallet\n}),\n\n% Read message by ID\n{ok, StoredMsg} = hb_cache:read(ID, Opts),\n\n% Read computation result\n{ok, Result} = hb_cache:read_resolved(Msg1ID, Msg2ID, Opts)\n"},"core/storage_caching/modules/hb_persistent.md":{"content":"# Module: hb_persistent\n\n## Basic Information\n- **Source File:** hb_persistent.erl\n- **Module Type:** Core Storage & Caching\n- **Purpose:** Management of long-lived AO-Core resolution processes\n\n## Purpose\nCreates and manages persistent processes for AO-Core resolution, particularly useful for large messages that are expensive to serialize/deserialize or when executions need to be serialized to avoid parallel computation. Uses Erlang's `pg` module for distributed process group management.\n\n## Interface\n\n### Process Management\n- `start_monitor/0,1` - Start process group monitor\n- `stop_monitor/1` - Stop process group monitor\n- `start_worker/2,3` - Start persistent worker process\n\n### Registration Operations\n- `find_or_register/3` - Find or register as execution leader\n- `unregister_notify/4` - Unregister and notify waiters\n- `await/4` - Wait for execution result\n- `notify/4` - Notify waiting processes\n\n### Group Operations\n- `group/3` - Calculate group name for messages\n- `forward_work/2` - Forward requests to new process\n- `default_grouper/3` - Default group name calculator\n- `default_worker/3` - Default worker implementation\n\n## Dependencies\n\n### Direct Dependencies\n- pg: Process group management\n- hb_name: Name registration\n- hb_ao: Core resolution\n- hb_opts: Options handling\n\n### Inverse Dependencies\n- Used by resolution system\n- Performance optimization\n- State management\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Process Groups**\n   ```erlang\n   % Register process in group\n   register_groupname(GroupName, Opts) ->\n       hb_name:register(GroupName)\n   \n   % Find existing process\n   find_execution(GroupName, _Opts) ->\n       hb_name:lookup(GroupName)\n   ```\n\n2. **Worker Management**\n   ```erlang\n   % Start worker process\n   start_worker(GroupName, Msg, Opts) ->\n       spawn(fun() ->\n           register_groupname(GroupName, Opts),\n           WorkerFun(GroupName, Msg, Opts)\n       end)\n   ```\n\n3. **Message Resolution**\n   ```erlang\n   % Default worker behavior\n   default_worker(GroupName, Msg1, Opts) ->\n       receive\n           {resolve, Listener, GroupName, Msg2, ListenerOpts} ->\n               Res = hb_ao:resolve(Msg1, Msg2, Opts),\n               send_response(Listener, GroupName, Msg2, Res)\n       end\n   ```\n\n### State Management\n\n1. **Process State**\n   - Group registration\n   - Worker lifecycle\n   - Message handling\n   - Timeout management\n\n2. **Group State**\n   - Process tracking\n   - Name resolution\n   - State persistence\n   - Error handling\n\n3. **Message State**\n   - Resolution tracking\n   - Result caching\n   - State updates\n   - Error recovery\n\n### Error Handling\n\n1. **Process Errors**\n   - Worker crashes\n   - Timeout handling\n   - State recovery\n   - Group cleanup\n\n2. **Resolution Errors**\n   - Message validation\n   - State verification\n   - Error propagation\n   - Recovery strategies\n\n## Integration Points\n\n1. **Process System**\n   - Group management\n   - Worker lifecycle\n   - Message passing\n   - State tracking\n\n2. **Resolution System**\n   - Message handling\n   - State management\n   - Result caching\n   - Error handling\n\n3. **Name System**\n   - Process registration\n   - Group management\n   - Name resolution\n   - State tracking\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Process Management**\n   - Group efficiency\n   - Worker lifecycle\n   - Message passing\n   - State handling\n\n2. **Resolution Optimization**\n   - Result caching\n   - State persistence\n   - Message deduplication\n   - Resource management\n\n### Security Implications\n\n1. **Process Safety**\n   - Group isolation\n   - Message validation\n   - State protection\n   - Error handling\n\n2. **State Protection**\n   - Process isolation\n   - Group security\n   - Message validation\n   - Error containment\n\n### Best Practices\n\n1. **Worker Management**\n   - Handle timeouts\n   - Validate messages\n   - Track state\n   - Clean up resources\n\n2. **Group Handling**\n   - Manage registration\n   - Handle errors\n   - Track processes\n   - Clean up state\n\n3. **Error Management**\n   - Handle crashes\n   - Recover state\n   - Propagate errors\n   - Clean up resources\n\n### Example Usage\n\n```erlang\n% Start a persistent worker\nMsg1 = #{<<\"device\">> => Device},\nWorkerPid = hb_persistent:start_worker(Msg1, #{\n    static_worker => true,\n    worker_timeout => 10000\n}),\n\n% Find or register for execution\ncase hb_persistent:find_or_register(Msg1, Msg2, Opts) of\n    {leader, GroupName} ->\n        % Handle execution\n        Result = handle_execution(Msg1, Msg2),\n        hb_persistent:unregister_notify(GroupName, Msg2, Result, Opts);\n    {wait, Leader} ->\n        % Wait for result\n        hb_persistent:await(Leader, Msg1, Msg2, Opts)\nend\n"},"core/storage_caching/modules/hb_store_fs.md":{"content":"# Module: hb_store_fs\n\n## Basic Information\n- **Source File:** hb_store_fs.erl\n- **Module Type:** Core Storage & Caching\n- **Behavior:** hb_store\n\n## Purpose\nProvides a filesystem-based implementation of the hb_store behavior. This module serves as the default storage backend, implementing key-value store operations using the local filesystem with support for directories (groups) and symbolic links.\n\n## Interface\n\n### Core Operations\n- `start/1` - Initialize filesystem store with data directory\n- `stop/1` - Stop filesystem store (no-op)\n- `reset/1` - Clear store by removing and recreating directory\n- `scope/1` - Return store scope (always 'local')\n\n### Storage Operations\n- `read/2` - Read key from store, following symlinks\n- `write/3` - Write value to path in store\n- `list/2` - List contents of directory\n- `type/2` - Get type of key (simple/composite)\n\n### Path Operations\n- `make_group/2` - Create directory in store\n- `make_link/3` - Create symbolic link\n- `resolve/2` - Resolve path through symlinks\n- `add_prefix/2` - Add directory prefix to path\n- `remove_prefix/2` - Remove directory prefix from path\n\n## Dependencies\n\n### Direct Dependencies\n- file: Filesystem operations\n- filelib: Directory utilities\n- hb_store: Store behavior\n- hb_path: Path manipulation\n- hb_util: Utility functions\n\n### Inverse Dependencies\n- Used by modules needing local storage\n- Default store implementation\n- Core component for persistence\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Path Resolution**\n   ```erlang\n   % Example path resolution:\n   /a/b/c: \"Not the right data\"\n   /a/b -> /a/alt-b\n   /a/alt-b/c: \"Correct data\"\n   \n   % Resolving \"a/b/c\" follows links:\n   a/b -> a/alt-b\n   a/alt-b/c -> \"Correct data\"\n   ```\n\n2. **Store Configuration**\n   ```erlang\n   Store = #{\n       <<\"prefix\">> => DataDir  % Base directory for storage\n   }\n   ```\n\n3. **File Types**\n   - simple: Regular files\n   - composite: Directories\n   - link: Symbolic links\n\n### State Management\n\n1. **Directory Structure**\n   - Uses filesystem hierarchy\n   - Maintains symlinks\n   - Handles nested paths\n   - Preserves structure\n\n2. **Error Handling**\n   - Directory creation\n   - Link resolution\n   - File operations\n   - Path validation\n\n3. **Path Management**\n   - Prefix handling\n   - Link resolution\n   - Path normalization\n   - Directory creation\n\n### Error Handling\n\n1. **File Operations**\n   - Handles missing files\n   - Manages broken links\n   - Creates directories\n   - Validates paths\n\n2. **Link Resolution**\n   - Follows symlinks\n   - Handles cycles\n   - Validates targets\n   - Reports errors\n\n## Integration Points\n\n1. **Storage System**\n   - Implements hb_store behavior\n   - Provides filesystem backend\n   - Manages local storage\n   - Handles persistence\n\n2. **Path System**\n   - Path manipulation\n   - Link resolution\n   - Directory structure\n   - Prefix handling\n\n3. **Error System**\n   - Operation validation\n   - Error reporting\n   - State recovery\n   - Path verification\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **File Operations**\n   - Efficient link following\n   - Directory caching\n   - Path resolution\n   - Operation batching\n\n2. **Path Resolution**\n   - Link caching\n   - Path normalization\n   - Prefix handling\n   - Directory structure\n\n### Security Implications\n\n1. **File Access**\n   - Path validation\n   - Link verification\n   - Directory permissions\n   - Access control\n\n2. **Data Protection**\n   - File permissions\n   - Directory structure\n   - Link validation\n   - Path sanitization\n\n### Best Practices\n\n1. **Store Usage**\n   - Validate paths\n   - Handle errors\n   - Follow links\n   - Check permissions\n\n2. **Path Handling**\n   - Normalize paths\n   - Validate links\n   - Check existence\n   - Handle prefixes\n\n3. **Error Management**\n   - Check operations\n   - Handle failures\n   - Validate state\n   - Report errors\n"},"core/storage_caching/modules/hb_store_gateway.md":{"content":"# Module: hb_store_gateway\n\n## Basic Information\n- **Source File:** hb_store_gateway.erl\n- **Module Type:** Core Storage & Caching\n- **Behavior:** hb_store\n\n## Purpose\nProvides a gateway-based implementation of the hb_store behavior that reads data from Arweave gateway and GraphQL routes. Acts as a bridge between local storage and remote Arweave network data, with optional local caching capabilities.\n\n## Interface\n\n### Core Operations\n- `scope/1` - Return store scope (always 'remote')\n- `resolve/2` - Resolve path (identity function)\n- `read/2` - Read data from gateway\n- `type/2` - Get type of data at key\n\n### Data Operations\n- `list/2` - List keys in a message\n- `maybe_cache/2` - Cache data if enabled\n\n## Dependencies\n\n### Direct Dependencies\n- hb_gateway_client: Gateway communication\n- hb_message: Message handling\n- hb_private: Private data management\n- hb_path: Path manipulation\n- hb_cache: Cache operations\n\n### Inverse Dependencies\n- Used by modules needing remote data\n- Core component for Arweave access\n- Essential for distributed storage\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Gateway Configuration**\n   ```erlang\n   Store = #{\n       <<\"store-module\">> => hb_store_gateway,\n       <<\"store\">> => LocalStore,  % Optional local cache\n       <<\"routes\">> => Routes      % Optional route list\n   }\n   ```\n\n2. **Caching Strategy**\n   ```erlang\n   % Cache data in local store if enabled\n   maybe_cache(StoreOpts, Data) ->\n       case get_store_option(StoreOpts) of\n           false -> do_nothing;\n           Store -> hb_cache:write(Data, #{store => Store})\n       end\n   ```\n\n3. **Type Detection**\n   ```erlang\n   % Determine if data is simple or composite\n   IsFlat = lists:all(\n       fun({_, Value}) -> not is_map(Value) end,\n       maps:to_list(CleanData)\n   ),\n   Type = if IsFlat -> simple; true -> composite end\n   ```\n\n### State Management\n\n1. **Remote Data**\n   - Gateway access\n   - GraphQL queries\n   - Response handling\n   - Error management\n\n2. **Local Cache**\n   - Optional caching\n   - Cache invalidation\n   - Store selection\n   - Data persistence\n\n3. **Type System**\n   - Simple values\n   - Composite data\n   - Type inference\n   - Cache optimization\n\n### Error Handling\n\n1. **Gateway Errors**\n   - Connection failures\n   - Invalid responses\n   - Timeout handling\n   - Cache fallback\n\n2. **Data Validation**\n   - Message format\n   - Type checking\n   - Path validation\n   - Cache consistency\n\n## Integration Points\n\n1. **Gateway System**\n   - Arweave gateway\n   - GraphQL endpoints\n   - HTTP communication\n   - Response parsing\n\n2. **Cache System**\n   - Local storage\n   - Cache policies\n   - Data persistence\n   - Store selection\n\n3. **Message System**\n   - Data formatting\n   - Type handling\n   - Path resolution\n   - State management\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Gateway Access**\n   - Connection pooling\n   - Response caching\n   - Request batching\n   - Error recovery\n\n2. **Cache Strategy**\n   - Selective caching\n   - Cache invalidation\n   - Store optimization\n   - Memory management\n\n### Security Implications\n\n1. **Remote Access**\n   - Gateway validation\n   - Route restrictions\n   - Data verification\n   - Access control\n\n2. **Cache Security**\n   - Data isolation\n   - Store permissions\n   - Cache validation\n   - State protection\n\n### Best Practices\n\n1. **Gateway Usage**\n   - Configure routes\n   - Handle timeouts\n   - Validate responses\n   - Manage connections\n\n2. **Cache Management**\n   - Enable when needed\n   - Configure stores\n   - Handle failures\n   - Validate data\n\n3. **Error Handling**\n   - Check responses\n   - Handle timeouts\n   - Validate data\n   - Manage state\n\n### Example Usage\n\n```erlang\n% Basic gateway store setup\nGateway = #{\n    <<\"store-module\">> => hb_store_gateway,\n    <<\"store\">> => false  % No local cache\n},\n\n% Read data from gateway\n{ok, Data} = hb_store:read(Gateway, <<\"transaction-id\">>),\n\n% Gateway with local cache\nCachedGateway = #{\n    <<\"store-module\">> => hb_store_gateway,\n    <<\"store\">> => LocalStore,  % Enable local cache\n    <<\"routes\">> => [<<\"graphql\">>, <<\"gateway\">>]\n},\n\n% Data will be cached locally after read\n{ok, CachedData} = hb_store:read(CachedGateway, <<\"transaction-id\">>)\n"},"core/storage_caching/modules/hb_store_remote_node.md":{"content":"# Module: hb_store_remote_node\n\n## Basic Information\n- **Source File:** hb_store_remote_node.erl\n- **Module Type:** Core Storage & Caching\n- **Behavior:** hb_store\n\n## Purpose\nProvides a store implementation that reads data from another AO node over HTTP. Currently implements primarily the read side of the store interface, with basic write and link capabilities that could be extended to include Arweave bundler integration for persistence.\n\n## Interface\n\n### Core Operations\n- `scope/1` - Return store scope (always 'remote')\n- `resolve/2` - Resolve key path (identity function)\n- `type/2` - Get type of data at key\n- `read/2` - Read data from remote node\n\n### Write Operations\n- `write/3` - Write data to remote node\n- `make_link/3` - Create link between keys\n\n## Dependencies\n\n### Direct Dependencies\n- hb_http: HTTP communication\n- hb_message: Message handling\n- hb_ao: Core operations\n- hb_cache: Cache operations\n\n### Inverse Dependencies\n- Used by distributed systems\n- Core component for node federation\n- Essential for remote data access\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Remote Node Configuration**\n   ```erlang\n   Store = #{\n       <<\"store-module\">> => hb_store_remote_node,\n       <<\"node\">> => NodeURL  % Remote node endpoint\n   }\n   ```\n\n2. **HTTP Endpoints**\n   ```erlang\n   % Read endpoint\n   \"/~cache@1.0/read\"\n   % Write endpoint\n   \"/~cache@1.0/write\"\n   % Link endpoint\n   \"/~cache@1.0/link\"\n   ```\n\n3. **Message Signing**\n   ```erlang\n   % Sign write/link messages if wallet provided\n   SignedMsg = hb_message:commit(WriteMsg, Opts)\n   ```\n\n### State Management\n\n1. **Remote State**\n   - HTTP communication\n   - Message signing\n   - Response handling\n   - Error management\n\n2. **Data Types**\n   - Simple values only\n   - Committed messages\n   - Signed requests\n   - Response validation\n\n3. **Error Handling**\n   - Connection failures\n   - Invalid responses\n   - Status codes\n   - Timeout handling\n\n### Error Handling\n\n1. **HTTP Errors**\n   - Connection failures\n   - Invalid responses\n   - Status codes\n   - Timeout handling\n\n2. **Data Validation**\n   - Message format\n   - Response codes\n   - Signature checks\n   - State verification\n\n## Integration Points\n\n1. **HTTP System**\n   - Remote communication\n   - Request formatting\n   - Response handling\n   - Error management\n\n2. **Message System**\n   - Message signing\n   - Commitment handling\n   - Format validation\n   - State management\n\n3. **Cache System**\n   - Remote access\n   - Data validation\n   - State persistence\n   - Error handling\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Network Operations**\n   - Connection pooling\n   - Request batching\n   - Response caching\n   - Error recovery\n\n2. **Data Management**\n   - Message validation\n   - State handling\n   - Cache utilization\n   - Error recovery\n\n### Security Implications\n\n1. **Remote Access**\n   - Message signing\n   - Request validation\n   - Response verification\n   - Access control\n\n2. **Data Protection**\n   - State validation\n   - Signature checking\n   - Error handling\n   - Access control\n\n### Best Practices\n\n1. **Remote Operations**\n   - Handle timeouts\n   - Validate responses\n   - Check signatures\n   - Manage errors\n\n2. **Data Handling**\n   - Validate messages\n   - Check states\n   - Handle errors\n   - Maintain consistency\n\n### Example Usage\n\n```erlang\n% Configure remote node store\nRemoteStore = #{\n    <<\"store-module\">> => hb_store_remote_node,\n    <<\"node\">> => \"http://remote-node:8080\"\n},\n\n% Read data from remote node\n{ok, Data} = hb_store:read(RemoteStore, <<\"key-id\">>),\n\n% Write data with signing\nWriteOpts = #{<<\"wallet\">> => Wallet},\nok = hb_store:write(RemoteStore, <<\"key-id\">>, Data, WriteOpts),\n\n% Create link between keys\nok = hb_store:make_link(RemoteStore, <<\"source\">>, <<\"dest\">>)\n"},"core/storage_caching/modules/hb_store_rocksdb.md":{"content":"# Module: hb_store_rocksdb\n\n## Basic Information\n- **Source File:** hb_store_rocksdb.erl\n- **Module Type:** Core Storage & Caching\n- **Behaviors:** hb_store, gen_server\n\n## Purpose\nProvides a RocksDB-based implementation of the hb_store behavior, wrapping RocksDB storage in a process. Replicates functionality of hb_store_fs while using RocksDB as the backend storage engine. Uses prefixes to encode item types and supports hierarchical storage with links and groups.\n\n## Interface\n\n### Core Operations\n- `start/1, start_link/1` - Initialize RocksDB store\n- `stop/1` - Stop RocksDB store\n- `reset/1` - Clear store data\n- `enabled/0` - Check if RocksDB support is enabled\n\n### Storage Operations\n- `read/2` - Read key from store, following links\n- `write/3` - Write value to store\n- `list/2` - List contents of directory\n- `type/2` - Get type of key (simple/composite)\n\n### Path Operations\n- `make_group/2` - Create directory in store\n- `make_link/3` - Create symbolic link\n- `resolve/2` - Resolve path through links\n- `add_path/3` - Combine path components\n- `path/2` - Create path from components\n\n## Dependencies\n\n### Direct Dependencies\n- rocksdb: Storage engine\n- gen_server: Process behavior\n- hb_store: Store behavior\n- hb_path: Path manipulation\n- filelib: Directory utilities\n\n### Inverse Dependencies\n- Alternative store implementation\n- Used when RocksDB is enabled\n- Performance-focused storage\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Value Types**\n   ```erlang\n   % Value encoding with type prefixes\n   encode_value(link, Value)  -> <<1, Value/binary>>\n   encode_value(raw, Value)   -> <<2, Value/binary>>\n   encode_value(group, Value) -> <<3, (term_to_binary(Value))/binary>>\n   ```\n\n2. **Store Configuration**\n   ```erlang\n   Store = #{\n       <<\"store-module\">> => hb_store_rocksdb,\n       <<\"prefix\">> => DataDir  % Base directory\n   }\n   ```\n\n3. **Directory Structure**\n   ```erlang\n   % Groups store member sets\n   {group, MemberSet} = decode_value(GroupValue)\n   % Links point to other paths\n   {link, Target} = decode_value(LinkValue)\n   % Raw values store actual data\n   {raw, Data} = decode_value(RawValue)\n   ```\n\n### State Management\n\n1. **Process State**\n   - RocksDB handle\n   - Base directory\n   - Connection status\n   - Operation timeout\n\n2. **Directory State**\n   - Member sets\n   - Path hierarchy\n   - Link tracking\n   - Type encoding\n\n3. **Error Handling**\n   - Connection failures\n   - Invalid paths\n   - Broken links\n   - Timeout handling\n\n### Error Handling\n\n1. **Database Operations**\n   - Handle connection loss\n   - Manage timeouts\n   - Validate operations\n   - Report errors\n\n2. **Path Resolution**\n   - Handle missing paths\n   - Follow valid links\n   - Check permissions\n   - Validate types\n\n## Integration Points\n\n1. **Storage System**\n   - Implements hb_store\n   - Uses RocksDB backend\n   - Manages persistence\n   - Handles encoding\n\n2. **Process System**\n   - gen_server behavior\n   - State management\n   - Message handling\n   - Error recovery\n\n3. **Path System**\n   - Path resolution\n   - Link handling\n   - Group management\n   - Type validation\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Database Operations**\n   - Efficient encoding\n   - Batch operations\n   - Connection pooling\n   - Cache utilization\n\n2. **Path Resolution**\n   - Link caching\n   - Group optimization\n   - Type inference\n   - Prefix handling\n\n### Security Implications\n\n1. **Data Access**\n   - Path validation\n   - Type checking\n   - Link verification\n   - Group permissions\n\n2. **Process Safety**\n   - State isolation\n   - Error handling\n   - Recovery procedures\n   - Connection management\n\n### Best Practices\n\n1. **Store Usage**\n   - Check RocksDB status\n   - Handle timeouts\n   - Validate paths\n   - Manage connections\n\n2. **Path Handling**\n   - Validate types\n   - Check links\n   - Manage groups\n   - Handle errors\n\n3. **Error Management**\n   - Handle timeouts\n   - Recover state\n   - Report errors\n   - Maintain consistency\n"},"core/storage_caching/modules/hb_store.md":{"content":"# Module: hb_store\n\n## Basic Information\n- **Source File:** hb_store.erl\n- **Module Type:** Core Storage & Caching\n- **Behavior:** Yes (defines behavior_info/1)\n\n## Purpose\nProvides an abstraction layer for key-value store operations in HyperBEAM. This module allows swapping underlying store implementations by defining a common interface and behavior that store modules must implement. It manages store operations through a chain of responsibility pattern, trying each configured store module until one succeeds.\n\n## Interface\n\n### Core Operations\n- `start/1` - Start store modules\n- `stop/1` - Stop store modules\n- `reset/1` - Delete all keys in store\n- `read/2` - Read key from store\n- `write/3` - Write key-value to store\n- `list/2` - List keys in a group\n\n### Path Operations\n- `path/1,2` - Create path from components\n- `add_path/2,3` - Combine path components\n- `join/1` - Join path components\n- `make_group/2` - Create namespace/directory\n- `make_link/3` - Create link between paths\n- `resolve/2` - Resolve path through links\n\n### Store Management\n- `filter/2` - Filter stores by criteria\n- `scope/2` - Limit store scope\n- `sort/2` - Order stores by preference\n- `type/2` - Get element type\n\n## Dependencies\n\n### Direct Dependencies\n- hb_path: Path manipulation\n- hb_opts: Options handling\n- hb_store_fs: Filesystem store\n- hb_store_rocksdb: RocksDB store (optional)\n\n### Inverse Dependencies\n- Used by modules needing storage\n- Core component for caching\n- Essential for persistence\n\n## Implementation Details\n\n### Key Concepts\n\n1. **Store Behavior**\n   ```erlang\n   behavior_info(callbacks) -> [\n       {start, 1}, {stop, 1}, {reset, 1},\n       {make_group, 2}, {make_link, 3},\n       {type, 2}, {read, 2}, {write, 3},\n       {list, 2}, {path, 2}, {add_path, 3}\n   ]\n   ```\n\n2. **Store Configuration**\n   ```erlang\n   Store = #{\n       <<\"store-module\">> => ModuleName,\n       <<\"prefix\">> => PathPrefix,\n       % Other store-specific options\n   }\n   ```\n\n3. **Path Resolution**\n   ```erlang\n   % Example link resolution:\n   write(Store, \"file\", \"data\")\n   make_link(Store, \"file\", \"link\")\n   read(Store, \"link\") % Returns \"data\"\n   ```\n\n### State Management\n\n1. **Store State**\n   - Module-specific state\n   - Scoped operations\n   - Path management\n   - Link resolution\n\n2. **Error Handling**\n   - Store fallbacks\n   - Operation retries\n   - Error propagation\n   - State recovery\n\n3. **Path Management**\n   - Path normalization\n   - Link resolution\n   - Group handling\n   - Scope isolation\n\n### Error Handling\n\n1. **Store Failures**\n   - Tries next store on failure\n   - Reports store errors\n   - Maintains consistency\n   - Handles timeouts\n\n2. **Path Errors**\n   - Validates paths\n   - Checks permissions\n   - Handles missing links\n   - Reports failures\n\n## Integration Points\n\n1. **Storage System**\n   - Multiple store types\n   - Pluggable interface\n   - Common operations\n   - State management\n\n2. **Cache System**\n   - Store selection\n   - Path resolution\n   - Link handling\n   - State persistence\n\n3. **Path System**\n   - Path manipulation\n   - Link resolution\n   - Group management\n   - Scope handling\n\n## Analysis Insights\n\n### Performance Considerations\n\n1. **Store Selection**\n   - Efficient filtering\n   - Smart sorting\n   - Quick fallbacks\n   - Minimal overhead\n\n2. **Path Resolution**\n   - Fast link resolution\n   - Efficient grouping\n   - Path caching\n   - Minimal recursion\n\n### Security Implications\n\n1. **Store Access**\n   - Scope isolation\n   - Path validation\n   - Link verification\n   - Access control\n\n2. **Data Protection**\n   - State isolation\n   - Error handling\n   - Safe fallbacks\n   - Consistent state\n\n### Best Practices\n\n1. **Store Implementation**\n   - Follow behavior spec\n   - Handle errors gracefully\n   - Maintain consistency\n   - Document limitations\n\n2. **Store Usage**\n   - Use appropriate stores\n   - Handle failures\n   - Validate paths\n   - Check scopes\n\n3. **Path Handling**\n   - Normalize paths\n   - Resolve links\n   - Manage groups\n   - Validate access\n"},"core/storage_caching/observations.md":{"content":"# Storage & Caching System Observations\n\n## System Overview\nThe Storage & Caching system in HyperBEAM provides a sophisticated multi-layered approach to data persistence and caching, with several key components working together to provide flexible, efficient, and reliable storage capabilities.\n\n## Key Components\n\n### 1. Storage Abstraction Layer (hb_store)\n- Provides pluggable storage backend system\n- Supports multiple storage implementations\n- Handles path resolution and linking\n- Manages store operations through chain of responsibility\n\n### 2. Storage Implementations\n- **Filesystem (hb_store_fs)**\n  - Default storage backend\n  - Uses filesystem hierarchy\n  - Supports symbolic links\n  - Path-based organization\n\n- **RocksDB (hb_store_rocksdb)**\n  - High-performance key-value store\n  - Process-wrapped storage\n  - Type-annotated values\n  - Group management\n\n- **Gateway (hb_store_gateway)**\n  - Remote data access\n  - Arweave integration\n  - GraphQL support\n  - Optional local caching\n\n- **Remote Node (hb_store_remote_node)**\n  - Node-to-node communication\n  - HTTP-based protocol\n  - Message signing\n  - Commitment handling\n\n### 3. Cache Management\n- **Core Cache (hb_cache)**\n  - Three-layer data representation\n  - Content deduplication\n  - Hashpath graph management\n  - Message state tracking\n\n- **Cache Control (hb_cache_control)**\n  - HTTP-style cache directives\n  - Policy enforcement\n  - Setting resolution\n  - Performance optimization\n\n- **Cache Visualization (hb_cache_render)**\n  - Graph visualization\n  - DOT/SVG generation\n  - Debug tooling\n  - Structure analysis\n\n- **Persistent Cache (hb_persistent)**\n  - Long-lived processes\n  - Message deduplication\n  - State management\n  - Process coordination\n\n## Design Patterns\n\n### 1. Abstraction Layers\n- Clear separation between interface and implementation\n- Pluggable backend system\n- Consistent API across stores\n- Flexible configuration\n\n### 2. Chain of Responsibility\n- Multiple store fallback\n- Prioritized store selection\n- Error handling chain\n- Operation delegation\n\n### 3. State Management\n- Process-based state\n- Message persistence\n- Cache coordination\n- Error recovery\n\n### 4. Path Resolution\n- Hierarchical organization\n- Link traversal\n- Group management\n- Type detection\n\n## Integration Points\n\n### 1. Storage System\n- Multiple backends\n- Consistent interface\n- Path management\n- State persistence\n\n### 2. Cache System\n- Policy enforcement\n- State tracking\n- Performance optimization\n- Resource management\n\n### 3. Message System\n- Format conversion\n- State persistence\n- ID management\n- Commitment tracking\n\n## Key Insights\n\n### 1. Performance Optimization\n- Content deduplication\n- Path optimization\n- Cache strategies\n- Process management\n\n### 2. Reliability\n- Error handling\n- State recovery\n- Path validation\n- Operation verification\n\n### 3. Flexibility\n- Pluggable backends\n- Configuration options\n- Policy control\n- Extension points\n\n### 4. Security\n- Path validation\n- State isolation\n- Access control\n- Error containment\n\n## Best Practices\n\n### 1. Storage Operations\n- Validate paths\n- Handle errors\n- Check permissions\n- Manage state\n\n### 2. Cache Usage\n- Use appropriate policies\n- Handle timeouts\n- Validate data\n- Clean up resources\n\n### 3. Process Management\n- Monitor state\n- Handle crashes\n- Coordinate processes\n- Manage resources\n\n## Areas for Improvement\n\n### 1. Documentation\n- More examples needed\n- Performance guidelines\n- Security considerations\n- Integration patterns\n\n### 2. Testing\n- More edge cases\n- Performance testing\n- Security testing\n- Integration testing\n\n### 3. Monitoring\n- Better metrics\n- State tracking\n- Resource usage\n- Error patterns\n\n### 4. Security\n- Path validation\n- Access control\n- State protection\n- Error handling\n\n## Future Considerations\n\n### 1. Performance\n- More efficient backends\n- Better caching\n- Process optimization\n- Resource management\n\n### 2. Features\n- More storage backends\n- Better monitoring\n- Enhanced security\n- Improved tooling\n\n### 3. Integration\n- Better coordination\n- Enhanced monitoring\n- Improved debugging\n- Extended tooling\n\n### 4. Security\n- Enhanced validation\n- Better isolation\n- Improved controls\n- Extended auditing\n"}}