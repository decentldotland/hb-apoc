{"devices/caching_optimization/modules/dev_cache.md":{"content":"# Module: dev_cache\n\n## Basic Information\n- **Source File:** dev_cache.erl\n- **Module Type:** Cache Management Device\n- **Purpose:** Manages a secure caching system with trusted writer verification, format handling, and support for both single and batch operations.\n\n## Core Functionality\n\n### 1. Cache Architecture\n```mermaid\ngraph TD\n    A[Cache Device] --> B[Read Operations]\n    A --> C[Write Operations]\n    A --> D[Link Operations]\n    \n    B --> E[Cache Lookup]\n    B --> F[Format Handling]\n    B --> G[Store Fallback]\n    \n    C --> H[Writer Verification]\n    C --> I[Operation Types]\n    C --> J[Data Storage]\n    \n    D --> K[Source Resolution]\n    D --> L[Destination Resolution]\n    D --> M[Link Creation]\n```\n\n### 2. Operation Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Cache\n    participant Writer\n    participant Store\n    participant Format\n    \n    Client->>Cache: Request Operation\n    \n    alt Read Operation\n        Cache->>Store: Lookup Data\n        Store-->>Cache: Return Data\n        Cache->>Format: Handle Format\n        Format-->>Cache: Formatted Data\n        Cache-->>Client: Return Result\n    else Write Operation\n        Cache->>Writer: Verify Trust\n        Writer-->>Cache: Confirm Trust\n        Cache->>Store: Store Data\n        Store-->>Cache: Confirm Storage\n        Cache-->>Client: Return Path\n    else Link Operation\n        Cache->>Writer: Verify Trust\n        Writer-->>Cache: Confirm Trust\n        Cache->>Store: Create Link\n        Store-->>Cache: Confirm Link\n        Cache-->>Client: Return Status\n    end\n```\n\n## Implementation Details\n\n### 1. Read Operation\n```erlang\nread(_M1, M2, Opts) ->\n    % Extract target location\n    Location = hb_ao:get(<<\"target\">>, M2, Opts),\n    \n    % Attempt cache lookup\n    case hb_cache:read(Location, Opts) of\n        {ok, Res} ->\n            % Handle format conversion if needed\n            case hb_ao:get(<<\"accept\">>, M2, Opts) of\n                <<\"application/aos-2\">> ->\n                    convert_to_json(Res);\n                _ ->\n                    {ok, Res}\n            end;\n        not_found ->\n            % Try store fallback\n            Store = hb_opts:get(store, [], Opts),\n            hb_store:read(Store, Location)\n    end\n```\n\n### 2. Write Operation\n```erlang\nwrite(_M1, M2, Opts) ->\n    % Verify trusted writer\n    case is_trusted_writer(M2, Opts) of\n        true ->\n            % Handle write type\n            case hb_ao:get(<<\"type\">>, M2, <<\"single\">>, Opts) of\n                <<\"single\">> ->\n                    write_single(M2, Opts);\n                <<\"batch\">> ->\n                    write_batch(M2, Opts);\n                _ ->\n                    {error, invalid_type}\n            end;\n        false ->\n            {error, not_authorized}\n    end\n```\n\n### 3. Link Operation\n```erlang\nlink(_Base, Req, Opts) ->\n    % Verify trusted writer\n    case is_trusted_writer(Req, Opts) of\n        true ->\n            % Extract source and destination\n            Source = hb_ao:get(<<\"source\">>, Req, Opts),\n            Destination = hb_ao:get(<<\"destination\">>, Req, Opts),\n            \n            % Create link\n            write_single(#{\n                <<\"operation\">> => <<\"link\">>,\n                <<\"source\">> => Source,\n                <<\"destination\">> => Destination\n            }, Opts);\n        false ->\n            {error, not_authorized}\n    end\n```\n\n## Key Features\n\n### 1. Security\n- Trusted writer verification\n- Signature validation\n- Access control\n- Operation authorization\n- Error handling\n\n### 2. Format Handling\n- Multiple format support\n- JSON conversion\n- Binary handling\n- Message formatting\n- Type validation\n\n### 3. Operation Types\n- Single writes\n- Batch operations\n- Link creation\n- Format conversion\n- Error recovery\n\n## Usage Examples\n\n### 1. Reading Data\n```erlang\n% Basic read\n{ok, Result} = dev_cache:read(\n    #{},\n    #{\n        <<\"target\">> => DataID\n    },\n    #{}\n)\n\n% Read with format conversion\n{ok, Result} = dev_cache:read(\n    #{},\n    #{\n        <<\"target\">> => DataID,\n        <<\"accept\">> => <<\"application/aos-2\">>\n    },\n    #{}\n)\n```\n\n### 2. Writing Data\n```erlang\n% Single write\n{ok, Result} = dev_cache:write(\n    #{},\n    #{\n        <<\"type\">> => <<\"single\">>,\n        <<\"body\">> => Data\n    },\n    #{\n        cache_writers => [TrustedAddress]\n    }\n)\n\n% Batch write\n{ok, Result} = dev_cache:write(\n    #{},\n    #{\n        <<\"type\">> => <<\"batch\">>,\n        <<\"body\">> => #{\n            <<\"item1\">> => Data1,\n            <<\"item2\">> => Data2\n        }\n    },\n    #{\n        cache_writers => [TrustedAddress]\n    }\n)\n```\n\n### 3. Creating Links\n```erlang\n% Link creation\n{ok, Result} = dev_cache:link(\n    #{},\n    #{\n        <<\"source\">> => SourceID,\n        <<\"destination\">> => DestID\n    },\n    #{\n        cache_writers => [TrustedAddress]\n    }\n)\n```\n\n## Error Handling\n\n### 1. Security Errors\n- Unauthorized writers\n- Invalid signatures\n- Missing permissions\n- Trust verification\n- Access control\n\n### 2. Operation Errors\n- Invalid types\n- Missing data\n- Format errors\n- Link failures\n- Storage issues\n\n### 3. Format Errors\n- Conversion failures\n- Invalid formats\n- Type mismatches\n- Data corruption\n- Validation errors\n\n## Performance Considerations\n\n### 1. Cache Efficiency\n- Quick lookups\n- Format caching\n- Link resolution\n- Error handling\n- Resource management\n\n### 2. Operation Speed\n- Batch processing\n- Link creation\n- Format conversion\n- Error recovery\n- Resource cleanup\n\n### 3. Resource Usage\n- Memory allocation\n- Storage optimization\n- Link management\n- Format handling\n- Error tracking\n\n## Future Improvements\n\n### 1. Feature Extensions\n- More formats\n- Better batching\n- Enhanced linking\n- Format detection\n- Error recovery\n\n### 2. Performance Optimization\n- Faster lookups\n- Better caching\n- Improved linking\n- Enhanced formats\n- Error handling\n\n### 3. Security Enhancements\n- Better verification\n- Enhanced trust\n- Improved access\n- Format validation\n- Error prevention\n"},"devices/caching_optimization/modules/dev_dedup.md":{"content":"# Module: dev_dedup\n\n## Basic Information\n- **Source File:** dev_dedup.erl\n- **Module Type:** Message Deduplication Device\n- **Purpose:** Deduplicates messages sent to a process by tracking and filtering duplicate messages during the first pass of stack execution.\n\n## Core Functionality\n\n### 1. Deduplication Architecture\n```mermaid\ngraph TD\n    A[Message Received] --> B[Pass Check]\n    B --> C[First Pass]\n    B --> D[Other Passes]\n    \n    C --> E[Message ID Check]\n    E --> F[Already Seen]\n    E --> G[Not Seen]\n    \n    F --> H[Skip Message]\n    G --> I[Update Seen List]\n    I --> J[Forward Message]\n    \n    D --> K[Forward Message]\n```\n\n### 2. Message Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Dedup\n    participant Stack\n    participant Cache\n    \n    Client->>Dedup: Send Message\n    Dedup->>Dedup: Check Pass Number\n    \n    alt First Pass\n        Dedup->>Dedup: Generate Message ID\n        Dedup->>Cache: Check Seen List\n        \n        alt Already Seen\n            Cache-->>Dedup: Found\n            Dedup-->>Client: Skip Message\n        else Not Seen\n            Cache-->>Dedup: Not Found\n            Dedup->>Cache: Update Seen List\n            Dedup->>Stack: Forward Message\n            Stack-->>Client: Return Result\n        end\n    else Other Pass\n        Dedup->>Stack: Forward Message\n        Stack-->>Client: Return Result\n    end\n```\n\n## Implementation Details\n\n### 1. Handler Configuration\n```erlang\ninfo(_M1) ->\n    #{\n        handler => fun handle/4\n    }\n```\n\n### 2. Message Handling\n```erlang\nhandle(Key, M1, M2, Opts) ->\n    % Check pass number\n    case hb_ao:get(<<\"pass\">>, {as, dev_message, M1}, 1, Opts) of\n        1 ->\n            % Generate message ID\n            Msg2ID = hb_message:id(M2, all),\n            % Get existing dedup list\n            Dedup = hb_ao:get(<<\"dedup\">>, {as, dev_message, M1}, [], Opts),\n            \n            % Check if message seen before\n            case lists:member(Msg2ID, Dedup) of\n                true ->\n                    {skip, M1};\n                false ->\n                    % Update dedup list\n                    M3 = hb_ao:set(\n                        M1,\n                        #{ <<\"dedup\">> => [Msg2ID|Dedup] }\n                    ),\n                    {ok, M3}\n            end;\n        Pass ->\n            % Skip dedup on other passes\n            {ok, M1}\n    end\n```\n\n## Key Features\n\n### 1. Message Tracking\n- Unique ID generation\n- Seen list maintenance\n- First pass tracking\n- State management\n- Memory optimization\n\n### 2. Pass Control\n- First pass handling\n- Pass number tracking\n- Multi-pass support\n- State preservation\n- Operation control\n\n### 3. Stack Integration\n- Message forwarding\n- State propagation\n- Error handling\n- Resource management\n- Operation coordination\n\n## Usage Examples\n\n### 1. Basic Deduplication\n```erlang\n% Create stack with dedup device\nMsg = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"1\">> => <<\"Dedup@1.0\">>,\n        <<\"2\">> => OtherDevice\n    }\n}\n\n% Send same message twice\n{ok, Msg2} = hb_ao:resolve(Msg, Message1, Opts),\n{ok, Msg3} = hb_ao:resolve(Msg2, Message1, Opts)\n% Second message will be skipped\n```\n\n### 2. Multi-pass Operation\n```erlang\n% Create stack with dedup and multipass\nMsg = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"1\">> => <<\"Dedup@1.0\">>,\n        <<\"2\">> => OtherDevice,\n        <<\"3\">> => <<\"Multipass@1.0\">>\n    },\n    <<\"passes\">> => 2\n}\n\n% Dedup only affects first pass\n{ok, Result} = hb_ao:resolve(Msg, Message, Opts)\n```\n\n### 3. Stack Integration\n```erlang\n% Create stack with dedup and append devices\nMsg = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"1\">> => <<\"Dedup@1.0\">>,\n        <<\"2\">> => AppendDevice1,\n        <<\"3\">> => AppendDevice2\n    },\n    <<\"result\">> => <<\"INIT\">>\n}\n```\n\n## Error Handling\n\n### 1. Message Errors\n- Invalid messages\n- Missing IDs\n- Format errors\n- State corruption\n- Resource issues\n\n### 2. Pass Errors\n- Invalid pass numbers\n- State corruption\n- Resource issues\n- Format errors\n- Operation failures\n\n### 3. Stack Errors\n- Integration issues\n- State corruption\n- Resource problems\n- Format conflicts\n- Operation failures\n\n## Performance Considerations\n\n### 1. Memory Usage\n- Seen list size\n- State management\n- Resource allocation\n- Cache utilization\n- Operation efficiency\n\n### 2. Processing Speed\n- ID generation\n- List operations\n- State updates\n- Pass checking\n- Error handling\n\n### 3. Stack Impact\n- Message flow\n- State propagation\n- Resource usage\n- Operation timing\n- Error recovery\n\n## Future Improvements\n\n### 1. Storage Enhancement\n- Cache integration\n- Better state management\n- Resource optimization\n- Format handling\n- Error recovery\n\n### 2. Performance Optimization\n- Faster lookups\n- Better state handling\n- Improved caching\n- Enhanced validation\n- Error management\n\n### 3. Stack Integration\n- Better coordination\n- Enhanced state sharing\n- Improved resource usage\n- Format optimization\n- Error handling\n"},"devices/caching_optimization/observations.md":{"content":"# Caching & Optimization: System Observations\n\n## Architectural Patterns\n\n### 1. System Architecture\n```mermaid\ngraph TD\n    A[Caching & Optimization] --> B[Cache System]\n    A --> C[Deduplication System]\n    \n    B --> D[Data Storage]\n    B --> E[Format Handling]\n    B --> F[Writer Control]\n    \n    C --> G[Message Tracking]\n    C --> H[Pass Control]\n    C --> I[Stack Integration]\n    \n    D --> J[Local Storage]\n    D --> K[Fallback Handling]\n    \n    E --> L[Format Conversion]\n    E --> M[Type Management]\n    \n    G --> N[ID Generation]\n    G --> O[State Management]\n```\n\n### 2. Component Integration\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Cache\n    participant Dedup\n    participant Stack\n    participant Store\n    \n    Client->>Cache: Write Request\n    Cache->>Cache: Verify Writer\n    Cache->>Store: Store Data\n    Store-->>Cache: Confirm Storage\n    Cache-->>Client: Return Path\n    \n    Client->>Dedup: Process Message\n    Dedup->>Dedup: Check Pass\n    Dedup->>Stack: Forward/Skip\n    Stack-->>Client: Return Result\n```\n\n## Key Insights\n\n### 1. Design Philosophy\n\n#### Caching Strategy\n- Trusted writer model\n- Format flexibility\n- Storage abstraction\n- Error resilience\n- Performance optimization\n\n#### Deduplication Approach\n- First-pass focus\n- Memory-based tracking\n- Stack awareness\n- State preservation\n- Operation efficiency\n\n#### Integration Model\n- Clear boundaries\n- Defined interfaces\n- Error propagation\n- Resource sharing\n- State coordination\n\n### 2. System Characteristics\n\n#### Performance\n- Efficient lookups\n- Smart caching\n- Memory optimization\n- Resource management\n- Operation control\n\n#### Reliability\n- Error handling\n- State tracking\n- Resource cleanup\n- Format validation\n- Operation verification\n\n#### Flexibility\n- Multiple formats\n- Writer control\n- Pass management\n- Stack integration\n- State handling\n\n## Implementation Patterns\n\n### 1. Code Organization\n\n#### Module Structure\n- Clear responsibilities\n- Focused functionality\n- Error handling\n- Resource management\n- State tracking\n\n#### Integration Points\n- Well-defined interfaces\n- Clear dependencies\n- Error propagation\n- Resource sharing\n- State coordination\n\n#### Error Handling\n- Comprehensive coverage\n- Recovery mechanisms\n- State preservation\n- Resource cleanup\n- Operation validation\n\n### 2. Resource Management\n\n#### Cache Control\n- Writer verification\n- Format handling\n- Storage management\n- Error recovery\n- State preservation\n\n#### Memory Usage\n- Efficient tracking\n- State management\n- Resource allocation\n- Operation control\n- Format handling\n\n#### Operation Control\n- Pass management\n- State tracking\n- Error handling\n- Resource cleanup\n- Format validation\n\n## Optimization Techniques\n\n### 1. Cache Optimization\n```mermaid\ngraph TD\n    A[Cache Request] --> B[Writer Check]\n    B --> C[Format Check]\n    C --> D[Storage Operation]\n    D --> E[Response Format]\n    \n    B --> F[Error: Unauthorized]\n    C --> G[Error: Invalid Format]\n    D --> H[Error: Storage Failed]\n```\n\n### 2. Deduplication Strategy\n```mermaid\ngraph TD\n    A[Message] --> B[Pass Check]\n    B --> C[First Pass]\n    B --> D[Other Pass]\n    \n    C --> E[ID Check]\n    E --> F[Seen Before]\n    E --> G[Not Seen]\n    \n    F --> H[Skip]\n    G --> I[Update & Forward]\n    D --> J[Forward]\n```\n\n## Future Considerations\n\n### 1. Enhancement Opportunities\n\n#### Cache System\n- Persistent storage\n- Better formats\n- Enhanced security\n- Performance tuning\n- Error recovery\n\n#### Dedup System\n- Cache integration\n- Better tracking\n- Enhanced validation\n- Format handling\n- Error management\n\n#### Integration\n- Better coordination\n- Enhanced sharing\n- Improved handling\n- Format optimization\n- Error recovery\n\n### 2. Performance Improvements\n\n#### Cache Performance\n- Faster lookups\n- Better storage\n- Enhanced formats\n- Improved validation\n- Error handling\n\n#### Dedup Performance\n- Efficient tracking\n- Better memory\n- Enhanced validation\n- Format handling\n- Error recovery\n\n#### System Performance\n- Better integration\n- Enhanced sharing\n- Improved handling\n- Format optimization\n- Error management\n\n## Architectural Impact\n\n### 1. System Benefits\n\n#### Efficiency Gains\n- Reduced redundancy\n- Better resource use\n- Enhanced performance\n- Format optimization\n- Error reduction\n\n#### Reliability Improvements\n- Better error handling\n- Enhanced tracking\n- Improved validation\n- Format consistency\n- Operation verification\n\n#### Integration Benefits\n- Clear interfaces\n- Better coordination\n- Enhanced sharing\n- Format handling\n- Error management\n\n### 2. Design Influence\n\n#### Pattern Adoption\n- Clear separation\n- Focused modules\n- Error handling\n- Resource management\n- State tracking\n\n#### Implementation Guide\n- Module structure\n- Integration points\n- Error handling\n- Resource control\n- State management\n\n#### Future Direction\n- Enhancement paths\n- Performance goals\n- Integration plans\n- Format evolution\n- Error handling\n"},"devices/caching_optimization/OVERVIEW.md":{"content":"# Caching & Optimization Overview\n\n## System Architecture\n```mermaid\ngraph TD\n    A[Caching & Optimization] --> B[Cache Device]\n    A --> C[Deduplication Device]\n    \n    B --> D[Data Management]\n    B --> E[Access Control]\n    B --> F[Format Handling]\n    \n    C --> G[Message Tracking]\n    C --> H[Pass Control]\n    C --> I[Stack Integration]\n    \n    D --> J[Write Operations]\n    D --> K[Read Operations]\n    D --> L[Link Operations]\n    \n    E --> M[Writer Verification]\n    E --> N[Permission Control]\n    \n    G --> O[ID Generation]\n    G --> P[State Management]\n```\n\n## Core Components\n\n### 1. Cache Device (dev_cache)\n- **Purpose**: Implements a secure caching layer with trusted writer verification and format-aware data handling\n- **Key Features**:\n  - **Trusted Writer Model**: \n    ```erlang\n    % Verify writer through signature validation\n    is_trusted_writer(Req, Opts) ->\n        Signers = hb_message:signers(Req),\n        CacheWriters = hb_opts:get(cache_writers, [], Opts),\n        lists:any(fun(Signer) -> \n            lists:member(Signer, CacheWriters) \n        end, Signers).\n    ```\n  - **Format Conversion**: \n    ```erlang\n    % Convert to AOS-2 format when requested\n    case hb_ao:get(<<\"accept\">>, M2, Opts) of\n        <<\"application/aos-2\">> ->\n            JSONMsg = dev_json_iface:message_to_json_struct(Res),\n            {ok, #{\n                <<\"body\">> => hb_json:encode(JSONMsg),\n                <<\"content-type\">> => <<\"application/aos-2\">>\n            }};\n        _ -> {ok, Res}\n    end.\n    ```\n  - **Storage Integration**: Seamless integration with both `hb_cache` for fast access and `hb_store` for persistence\n  - **Link Operations**: Atomic linking between cache entries with full writer verification\n  - **Event Tracking**: Comprehensive event logging using `?event` macros for debugging and monitoring\n\n### 2. Deduplication Device (dev_dedup)\n- **Purpose**: Optimizes message processing by preventing duplicate executions in stack operations\n- **Key Features**:\n  - **First-pass Isolation**:\n    ```erlang\n    % Only deduplicate on first pass\n    case hb_ao:get(<<\"pass\">>, {as, dev_message, M1}, 1, Opts) of\n        1 -> handle_dedup(M1, M2, Opts);\n        _ -> {ok, M1}  % Pass through on subsequent passes\n    end.\n    ```\n  - **Message Identification**:\n    ```erlang\n    % Generate unique message ID\n    Msg2ID = hb_message:id(M2, all),\n    Dedup = hb_ao:get(<<\"dedup\">>, {as, dev_message, M1}, [], Opts),\n    case lists:member(Msg2ID, Dedup) of\n        true -> {skip, M1};\n        false -> update_dedup_list(M1, Msg2ID, Dedup)\n    end.\n    ```\n  - **State Management**: In-memory tracking with potential for future persistence\n  - **Stack Integration**: Direct integration with device stack for message control\n  - **Pass Awareness**: Special handling for multipass operations to maintain correctness\n\n## Integration Points\n\n### 1. System Integration\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Cache\n    participant Dedup\n    participant Store\n    participant Stack\n    \n    Client->>Cache: Write Request\n    Cache->>Cache: Verify Writer (hb_message:signers)\n    Cache->>Store: Store Data (hb_cache:write)\n    Store-->>Cache: Confirm Storage\n    Cache-->>Client: Return Path\n    \n    Client->>Dedup: Process Message\n    Dedup->>Dedup: Check Pass (hb_ao:get(\"pass\"))\n    alt First Pass\n        Dedup->>Dedup: Check ID (hb_message:id)\n        alt New Message\n            Dedup->>Stack: Forward Message\n            Stack-->>Client: Process\n        else Duplicate\n            Dedup-->>Client: Skip (return {skip, M1})\n        end\n    else Other Pass\n        Dedup->>Stack: Forward (return {ok, M1})\n        Stack-->>Client: Process\n    end\n```\n\n### 2. Data Flow\n```mermaid\ngraph TD\n    A[Client Request] --> B{Cache or Dedup?}\n    \n    B -->|Cache| C[Cache Device]\n    B -->|Dedup| D[Dedup Device]\n    \n    C --> E{Operation Type}\n    E -->|Write| F[Writer Check via hb_message:signers]\n    E -->|Read| G[Format Check via accept header]\n    E -->|Link| H[Permission Check + hb_cache:link]\n    \n    D --> I{Pass Number via hb_ao:get}\n    I -->|First| J[ID Check via hb_message:id]\n    I -->|Other| K[Forward via {ok, M1}]\n    \n    J -->|New| L[Update State via hb_ao:set]\n    J -->|Seen| M[Skip via {skip, M1}]\n```\n\n## Real-World Usage Scenarios\n\n### 1. HTTP API Caching\n```erlang\n% Configure cache device with HTTP settings\nCacheOpts = #{\n    cache_control => [<<\"no-cache\">>, <<\"no-store\">>],\n    store => LocalStore,\n    cache_writers => [TrustedAddress],\n    store_all_signed => false\n},\n\n% Set up HTTP node with cache\nNode = hb_http_server:start_node(CacheOpts),\n\n% Write data to cache via HTTP\nWriteMsg = #{\n    <<\"path\">> => <<\"/~cache@1.0/write\">>,\n    <<\"method\">> => <<\"POST\">>,\n    <<\"body\">> => Data\n},\nSignedMsg = hb_message:commit(WriteMsg, Wallet),\n{ok, WriteResponse} = hb_http:post(Node, SignedMsg, #{}).\n```\n\n### 2. Stack-based Deduplication\n```erlang\n% Create stack with dedup and processing devices\nMsg = #{\n    <<\"device\">> => <<\"Stack@1.0\">>,\n    <<\"device-stack\">> => #{\n        <<\"1\">> => <<\"Dedup@1.0\">>,\n        <<\"2\">> => ProcessingDevice,\n        <<\"3\">> => <<\"Multipass@1.0\">>\n    },\n    <<\"passes\">> => 2\n},\n\n% Process message through stack\n{ok, Result} = hb_ao:resolve(Msg, Message, Opts).\n```\n\n### 3. Format Conversion\n```erlang\n% Read with format conversion\nReadMsg = #{\n    <<\"path\">> => <<\"/~cache@1.0/read\">>,\n    <<\"method\">> => <<\"GET\">>,\n    <<\"target\">> => Path,\n    <<\"accept\">> => <<\"application/aos-2\">>\n},\n{ok, JSONResponse} = hb_http:get(Node, ReadMsg, #{}).\n```\n\n## Implementation Details\n\n### 1. Cache Operations\n```erlang\n% Write operation with verification and type handling\nwrite(_M1, M2, Opts) ->\n    case is_trusted_writer(M2, Opts) of\n        true ->\n            Type = hb_ao:get(<<\"type\">>, M2, <<\"single\">>, Opts),\n            case Type of\n                <<\"single\">> -> write_single(M2, Opts);\n                <<\"batch\">> -> write_batch(M2, Opts);\n                _ -> {error, #{<<\"status\">> => 400}}\n            end;\n        false ->\n            {error, #{<<\"status\">> => 403}}\n    end.\n\n% Read operation with format handling and fallback\nread(_M1, M2, Opts) ->\n    Location = hb_ao:get(<<\"target\">>, M2, Opts),\n    case hb_cache:read(Location, Opts) of\n        {ok, Res} ->\n            handle_format(Res, M2, Opts);\n        not_found ->\n            Store = hb_opts:get(store, [], Opts),\n            hb_store:read(Store, Location)\n    end.\n```\n\n### 2. Dedup Operations\n```erlang\n% First pass deduplication with state management\nhandle(Key, M1, M2, Opts) ->\n    case hb_ao:get(<<\"pass\">>, M1, 1, Opts) of\n        1 -> \n            Msg2ID = hb_message:id(M2, all),\n            Dedup = hb_ao:get(<<\"dedup\">>, M1, [], Opts),\n            case lists:member(Msg2ID, Dedup) of\n                true -> \n                    ?event({already_seen, Msg2ID}),\n                    {skip, M1};\n                false ->\n                    M3 = hb_ao:set(M1, #{\n                        <<\"dedup\">> => [Msg2ID|Dedup]\n                    }),\n                    {ok, M3}\n            end;\n        Pass ->\n            ?event({multipass_detected, Pass}),\n            {ok, M1}\n    end.\n```\n\n### 3. Resource Management\n- **Memory Efficiency**:\n  ```erlang\n  % Direct binary handling for efficiency\n  case Body of\n      Binary when is_binary(Binary) ->\n          {ok, Path} = hb_cache:write(Binary, Opts);\n      _ ->\n          handle_complex_data(Body, Opts)\n  end.\n  ```\n- **State Preservation**:\n  ```erlang\n  % Atomic state updates\n  M3 = hb_ao:set(M1, #{\n      <<\"dedup\">> => [Msg2ID|Dedup],\n      <<\"state\">> => NewState\n  }),\n  ```\n- **Format Handling**:\n  ```erlang\n  % Lazy format conversion\n  case hb_ao:get(<<\"accept\">>, M2, Opts) of\n      <<\"application/aos-2\">> ->\n          convert_to_json(Data);\n      _ ->\n          {ok, Data}\n  end.\n  ```\n\n## Future Considerations\n\n### 1. Cache Enhancements\n- **Persistent Storage**: Integration with RocksDB for durable caching\n- **Enhanced Formats**: Support for more content types and conversion paths\n- **Better Security**: Enhanced signature verification and access control\n- **Performance Tuning**: Optimized lookup paths and cache invalidation\n- **Error Recovery**: Automatic state repair and consistency checking\n\n### 2. Dedup Improvements\n- **Cache Integration**: Shared state between cache and dedup devices\n- **Better Tracking**: More efficient duplicate detection algorithms\n- **Enhanced Validation**: Additional message integrity checks\n- **Format Handling**: Better integration with format conversion\n- **Error Management**: Improved error recovery and state restoration\n\n### 3. Integration Updates\n- **Better Coordination**: Enhanced interaction between devices\n- **Enhanced Sharing**: More efficient resource sharing\n- **Improved Handling**: Better error propagation and recovery\n- **Format Optimization**: More efficient format conversion paths\n- **Error Recovery**: Better handling of partial failures\n"}}