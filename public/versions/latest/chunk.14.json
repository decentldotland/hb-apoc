{"devices/Process & Execution/modules/dev_process.md":{"content":"# Module: dev_process\n\n## Basic Information\n- **Source File:** dev_process.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Device implementation of AO processes in AO-Core\n\n## Purpose\n\nThe dev_process module implements the core functionality for routing requests to different functionality handlers (scheduling, computing, and pushing messages) through device swapping. It manages process state and caching, allowing devices to share state as needed.\n\n## Interface\n\n### Public API\n\n```erlang\n% Core operations\n-export([info/1, compute/3, schedule/3, slot/3, now/3, push/3, snapshot/3]).\n-export([ensure_process_key/2]).\n\n% Public utilities\n-export([as_process/2, process_id/3]).\n\n% Test helpers\n-export([test_aos_process/0, test_aos_process/1, dev_test_process/0, test_wasm_process/1]).\n-export([schedule_aos_call/2, schedule_aos_call/3, init/0]).\n```\n\n### REST API Endpoints\n```\nGET /ID/Schedule                Returns the messages in the schedule\nPOST /ID/Schedule              Adds a message to the schedule\nGET /ID/Compute/[IDorSlotNum]  Returns process state after applying message\nGET /ID/Now                    Returns the `/Results' key of the latest computed message\n```\n\n### Process Definition Example\n```\nDevice: Process/1.0\nScheduler-Device: Scheduler/1.0\nExecution-Device: Stack/1.0\nExecution-Stack: \"Scheduler/1.0\", \"Cron/1.0\", \"WASM/1.0\", \"PoDA/1.0\"\nCron-Frequency: 10-Minutes\nWASM-Image: WASMImageID\nPoDA:\n    Device: PoDA/1.0\n    Authority: A\n    Authority: B\n    Authority: C\n    Quorum: 2\n```\n\n## Runtime Options\n\n- **Cache-Frequency**: Number of assignments computed before full state cache\n- **Cache-Keys**: List of keys to cache for all assignments beyond `/Results`\n- **Default Cache Frequency**: 1 (defined as DEFAULT_CACHE_FREQ)\n\n## Implementation Details\n\n### Key Functions\n\n1. **run_as/4**: Core device swapping mechanism\n```erlang\nrun_as(Key, Msg1, Msg2, Opts) ->\n    BaseDevice = hb_ao:get(<<\"device\">>, {as, dev_message, Msg1}, Opts),\n    {ok, PreparedMsg} = dev_message:set(\n        ensure_process_key(Msg1, Opts),\n        #{\n            <<\"device\">> => DeviceSet,\n            <<\"input-prefix\">> => get_input_prefix(Msg1, Opts),\n            <<\"output-prefixes\">> => get_output_prefixes(Key, Msg1, Opts)\n        },\n        Opts\n    ),\n    {Status, Result} = hb_ao:resolve(PreparedMsg, Msg2, Opts)\n```\n\n2. **compute_slot/5**: Single slot computation\n```erlang\ncompute_slot(ProcID, State, InputMsg, ReqMsg, Opts) ->\n    NextSlot = hb_util:int(hb_ao:get(<<\"slot\">>, InputMsg, Opts)),\n    UnsetResults = hb_ao:set(State, #{ <<\"results\">> => unset }, Opts),\n    case run_as(<<\"execution\">>, UnsetResults, InputMsg, Opts) of\n        {ok, Msg3} ->\n            Msg3SlotAfter = hb_ao:set(Msg3, #{ <<\"at-slot\">> => NextSlot }, Opts),\n            dev_process_worker:notify_compute(ProcID, NextSlot, {ok, Msg3SlotAfter}, Opts),\n            store_result(ProcID, NextSlot, Msg3SlotAfter, ReqMsg, Opts),\n            {ok, Msg3SlotAfter};\n        {error, Error} ->\n            {error, Error}\n    end\n```\n\n3. **store_result/5**: Result caching with snapshots\n```erlang\nstore_result(ProcID, Slot, Msg3, Msg2, Opts) ->\n    Freq = hb_opts:get(process_cache_frequency, ?DEFAULT_CACHE_FREQ, Opts),\n    Msg3MaybeWithSnapshot =\n        case Slot rem Freq of\n            0 ->\n                {ok, Snapshot} = snapshot(Msg3, Msg2, Opts),\n                Msg3#{ <<\"snapshot\">> => Snapshot };\n            _ -> \n                Msg3\n        end,\n    Writer = fun() -> dev_process_cache:write(ProcID, Slot, Msg3MaybeWithSnapshot, Opts) end,\n    case hb_opts:get(process_async_cache, true, Opts) of\n        true -> spawn(Writer);\n        false -> Writer()\n    end\n```\n\n### State Management\n\n1. **Process State**\n   - Computation results stored at each slot\n   - Slot numbers tracked for state transitions\n   - Snapshots taken at configurable intervals\n   - State restored from latest snapshot or initialized\n\n2. **State Loading**\n```erlang\nensure_loaded(Msg1, Msg2, Opts) ->\n    TargetSlot = hb_ao:get(<<\"slot\">>, Msg2, undefined, Opts),\n    ProcID = process_id(Msg1, Msg2, Opts),\n    case hb_ao:get(<<\"initialized\">>, Msg1, Opts) of\n        <<\"true\">> -> {ok, Msg1};\n        _ ->\n            case dev_process_cache:latest(ProcID, [<<\"snapshot\">>], TargetSlot, Opts) of\n                {ok, LoadedSlot, SnapshotMsg} ->\n                    {ok, Normalized} = run_as(<<\"execution\">>, SnapshotMsg, normalize, Opts),\n                    {ok, maps:remove(<<\"snapshot\">>, Normalized)};\n                not_found ->\n                    init(Msg1, Msg2, Opts)\n            end\n    end\n```\n\n## Integration Points\n\n### 1. Device System\n- Execution devices (WASM, Lua) via device swapping\n- Scheduler device for message scheduling\n- Stack device for execution composition\n- Push device for message propagation\n\n### 2. Cache System\n- Result storage through dev_process_cache\n- Snapshot management at configured intervals\n- State restoration from snapshots\n- Async caching support\n\n### 3. Message System\n- Request routing based on path\n- State transitions through message processing\n- Result propagation via notifications\n- Event tracking for operations\n\n## Flow Diagrams\n\n### Computation Flow\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Process\n    participant Device\n    participant Cache\n\n    Client->>Process: Compute Request\n    Process->>Device: Swap Device\n    Device->>Process: Execute\n    Process->>Cache: Store Result\n    Process->>Client: Return State\n```\n\n### State Management\n\n```mermaid\ngraph TD\n    A[Process Request] -->|Load| B[Current State]\n    B -->|Execute| C[New State]\n    C -->|Cache| D[Store Result]\n    C -->|Snapshot| E[Store Snapshot]\n    D -->|Next| A\n```\n\n## Test Coverage\n\nThe module includes comprehensive tests for:\n- Process scheduling\n- State computation\n- Device swapping\n- Cache management\n- Worker persistence\n- AOS integration\n- WASM execution\n- Error handling\n"},"devices/Process & Execution/modules/dev_wasi.md":{"content":"# Module: dev_wasi\n\n## Basic Information\n- **Source File:** dev_wasi.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Virtual filesystem device implementing WASI-preview-1 standard\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([init/3, compute/1, stdout/1]).\n\n% WASI-preview-1 functions\n-export([path_open/3, fd_write/3, fd_read/3, clock_time_get/3]).\n```\n\n### Include Files\n```erlang\n-include(\"include/hb.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n```\n\n## Virtual Filesystem Structure\n\n### Initial VFS Setup\n```erlang\n-define(INIT_VFS,\n    #{\n        <<\"dev\">> => #{\n            <<\"stdin\">> => <<>>,\n            <<\"stdout\">> => <<>>,\n            <<\"stderr\">> => <<>>\n        }\n    }\n).\n```\n\n### Initial File Descriptors\n```erlang\n-define(INIT_FDS,\n    #{\n        <<\"0\">> => #{\n            <<\"filename\">> => <<\"/dev/stdin\">>,\n            <<\"offset\">> => 0\n        },\n        <<\"1\">> => #{\n            <<\"filename\">> => <<\"/dev/stdout\">>,\n            <<\"offset\">> => 0\n        },\n        <<\"2\">> => #{\n            <<\"filename\">> => <<\"/dev/stderr\">>,\n            <<\"offset\">> => 0\n        }\n    }\n).\n```\n\n## Implementation Details\n\n### 1. Initialization\n```erlang\ninit(M1, _M2, Opts) ->\n    % Set up WASI stdlib\n    MsgWithLib = hb_ao:set(M1, #{\n        <<\"wasm/stdlib/wasi_snapshot_preview1\">> =>\n            #{ <<\"device\">> => <<\"WASI@1.0\">>}\n    }, Opts),\n    \n    % Initialize file descriptors\n    MsgWithFDs = hb_ao:set(MsgWithLib,\n        <<\"file-descriptors\">>, ?INIT_FDS, Opts),\n    \n    % Initialize virtual filesystem\n    CompleteMsg = hb_ao:set(MsgWithFDs,\n        <<\"vfs\">>, ?INIT_VFS, Opts),\n    \n    {ok, CompleteMsg}\n```\n\n### 2. File Operations\n\n#### Path Opening\n```erlang\npath_open(Msg1, Msg2, Opts) ->\n    % Extract WASI arguments\n    Instance = hb_private:get(<<\"instance\">>, Msg1, Opts),\n    [FDPtr, LookupFlag, PathPtr|_] = hb_ao:get(<<\"args\">>, Msg2, Opts),\n    \n    % Get path from WASM memory\n    Path = hb_beamr_io:read_string(Instance, PathPtr),\n    \n    % Create or get file descriptor\n    FD = #{\n        <<\"index\">> := Index\n    } = case hb_ao:get(<<\"vfs/\", Path/binary>>, Msg1, Opts) of\n        not_found -> #{\n            <<\"index\">> => length(hb_ao:keys(FDs)) + 1,\n            <<\"filename\">> => Path,\n            <<\"offset\">> => 0\n        };\n        F -> F\n    end,\n    \n    % Return file descriptor\n    {ok, #{\n        <<\"state\">> => hb_ao:set(Msg1, <<\"vfs/\", Path/binary>>, FD),\n        <<\"results\">> => [0, Index]\n    }}\n```\n\n#### File Reading\n```erlang\nfd_read(S, Instance, [FDNum, VecsPtr, NumVecs, RetPtr], BytesRead, Opts) ->\n    % Get file info\n    FDNumStr = integer_to_binary(FDNum),\n    Filename = hb_ao:get(\n        <<\"file-descriptors/\", FDNumStr/binary, \"/filename\">>,\n        S, Opts),\n    \n    % Parse iovec\n    {VecPtr, Len} = parse_iovec(Instance, VecsPtr),\n    \n    % Read data\n    Data = hb_ao:get(<<\"vfs/\", Filename/binary>>, S, Opts),\n    Offset = hb_ao:get(\n        <<\"file-descriptors/\", FDNumStr/binary, \"/offset\">>,\n        S, Opts),\n    ReadSize = min(Len, byte_size(Data) - Offset),\n    Bin = binary:part(Data, Offset, ReadSize),\n    \n    % Write to WASM memory\n    ok = hb_beamr_io:write(Instance, VecPtr, Bin),\n    \n    % Update offset and continue\n    fd_read(\n        hb_ao:set(S,\n            <<\"file-descriptors/\", FDNumStr/binary, \"/offset\">>,\n            Offset + ReadSize, Opts),\n        Instance,\n        [FDNum, VecsPtr + 16, NumVecs - 1, RetPtr],\n        BytesRead + ReadSize,\n        Opts\n    )\n```\n\n#### File Writing\n```erlang\nfd_write(S, Instance, [FDnum, Ptr, Vecs, RetPtr], BytesWritten, Opts) ->\n    % Get file info\n    FDNumStr = integer_to_binary(FDnum),\n    FD = hb_ao:get(<<\"file-descriptors/\", FDNumStr/binary>>, S, Opts),\n    Filename = hb_ao:get(<<\"filename\">>, FD, Opts),\n    StartOffset = hb_ao:get(<<\"offset\">>, FD, Opts),\n    \n    % Read data from WASM memory\n    {VecPtr, Len} = parse_iovec(Instance, Ptr),\n    {ok, Data} = hb_beamr_io:read(Instance, VecPtr, Len),\n    \n    % Update file content\n    Before = binary:part(OrigData, 0, StartOffset),\n    After = binary:part(OrigData, StartOffset,\n                       byte_size(OrigData) - StartOffset),\n    \n    % Update state and continue\n    S1 = hb_ao:set(S,\n        <<\"file-descriptors/\", FDNumStr/binary, \"/offset\">>,\n        StartOffset + byte_size(Data), Opts),\n    S2 = hb_ao:set(S1,\n        <<\"vfs/\", Filename/binary>>,\n        <<Before/binary, Data/binary, After/binary>>, Opts),\n    \n    fd_write(S2, Instance,\n        [FD, Ptr + 16, Vecs - 1, RetPtr],\n        BytesWritten + byte_size(Data), Opts)\n```\n\n### 3. WASI Support Functions\n\n```erlang\n% Parse WASI iovec structure\nparse_iovec(Instance, Ptr) ->\n    {ok, VecStruct} = hb_beamr_io:read(Instance, Ptr, 16),\n    <<BinPtr:64/little-unsigned-integer,\n      Len:64/little-unsigned-integer>> = VecStruct,\n    {BinPtr, Len}\n\n% Get stdout content\nstdout(M) ->\n    hb_ao:get(<<\"vfs/dev/stdout\">>, M)\n\n% WASI clock implementation\nclock_time_get(Msg1, _Msg2, Opts) ->\n    State = hb_ao:get(<<\"state\">>, Msg1, Opts),\n    {ok, #{ <<\"state\">> => State, <<\"results\">> => [1] }}\n```\n\n## Test Coverage\n\n### 1. VFS Serialization\n```erlang\nvfs_is_serializable_test() ->\n    % Tests VFS message serialization\n    % Verifies message conversion and matching\n```\n\n### 2. WASI Stack Tests\n```erlang\nwasi_stack_is_serializable_test() ->\n    % Tests WASI stack message serialization\n    % Verifies message conversion and matching\n```\n\n### 3. AOS Integration\n```erlang\nbasic_aos_exec_test() ->\n    % Tests WASI integration with AOS\n    % Verifies memory allocation and string handling\n    % Tests command execution and result parsing\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_beamr_io: WASM memory operations\n- hb_ao: Message handling\n- hb_private: Private state management\n- hb_json: JSON encoding/decoding\n\n### Usage Context\n- Called by dev_wasm for WASI operations\n- Provides filesystem abstraction\n- Manages WASM memory interactions\n- Implements WASI-preview-1 interface\n"},"devices/Process & Execution/modules/dev_wasm.md":{"content":"# Module: dev_wasm\n\n## Basic Information\n- **Source File:** dev_wasm.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** WASM execution device using Memory-64 preview standard\n- **Backend:** Uses beamr (Erlang wrapper for WAMR - WebAssembly Micro Runtime)\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([info/2, init/3, compute/3, import/3, terminate/3, snapshot/3, normalize/3]).\n\n% Device API\n-export([instance/3]).\n\n% Test API\n-export([cache_wasm_image/1, cache_wasm_image/2]).\n```\n\n### Include Files\n```erlang\n-include(\"include/hb.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n```\n\n## Message Requirements\n\n### Init Operation\n```\nM1/Init ->\n    Assumes:\n        M1/process\n        M1/[Prefix]/image\n    Generates:\n        /priv/[Prefix]/instance\n        /priv/[Prefix]/import-resolver\n    Side-effects:\n        Creates WASM executor in HyperBEAM node memory\n```\n\n### Compute Operation\n```\nM1/Compute ->\n    Assumes:\n        M1/priv/[Prefix]/instance\n        M1/priv/[Prefix]/import-resolver\n        M1/process\n        M2/message\n        M2/message/function OR M1/function\n        M2/message/parameters OR M1/parameters\n    Generates:\n        /results/[Prefix]/type\n        /results/[Prefix]/output\n    Side-effects:\n        Calls WASM executor with message and process\n```\n\n### State Operation\n```\nM1/[Prefix]/state ->\n    Assumes:\n        M1/priv/[Prefix]/instance\n    Generates:\n        Raw binary WASM state\n```\n\n## Implementation Details\n\n### 1. WASM Image Loading\n\n```erlang\ninit(M1, M2, Opts) ->\n    % Get input prefix for parameters\n    InPrefix = dev_stack:input_prefix(M1, M2, Opts),\n    % Get prefix for state\n    Prefix = dev_stack:prefix(M1, M2, Opts),\n    \n    % Load WASM image from various sources\n    ImageBin = case hb_ao:get(<<InPrefix/binary, \"/image\">>, M1, Opts) of\n        not_found -> \n            case hb_ao:get(<<\"body\">>, M1, Opts) of\n                not_found -> throw({wasm_init_error, ...});\n                Bin when is_binary(Bin) -> Bin\n            end;\n        ImageID when ?IS_ID(ImageID) ->\n            {ok, ImageMsg} = hb_cache:read(ImageID, Opts),\n            hb_ao:get(<<\"body\">>, ImageMsg, Opts);\n        ImageMsg when is_map(ImageMsg) ->\n            hb_ao:get(<<\"body\">>, ImageMsg, Opts);\n        Image when is_binary(Image) -> Image\n    end,\n    \n    % Start WASM executor\n    {ok, Instance, _, _} = hb_beamr:start(ImageBin, Mode),\n    \n    % Set up instance and handlers\n    {ok, hb_private:set(M1, #{\n        <<Prefix/binary, \"/write\">> => fun write_handler/1,\n        <<Prefix/binary, \"/read\">> => fun read_handler/1,\n        <<Prefix/binary, \"/instance\">> => Instance,\n        <<Prefix/binary, \"/import-resolver\">> => fun default_import_resolver/3\n    }, Opts)}\n```\n\n### 2. Computation Execution\n\n```erlang\ncompute(RawM1, M2, Opts) ->\n    % Normalize message state\n    {ok, M1} = normalize(RawM1, M2, Opts),\n    \n    % Extract function and parameters\n    WASMFunction = hb_ao:get_first([\n        {M2, <<\"body/function\">>},\n        {M2, <<\"function\">>},\n        {M1, <<\"function\">>}\n    ], Opts),\n    \n    WASMParams = hb_ao:get_first([\n        {M2, <<\"body/parameters\">>},\n        {M2, <<\"parameters\">>},\n        {M1, <<\"parameters\">>}\n    ], Opts),\n    \n    % Execute WASM function\n    {ResType, Res, MsgAfterExecution} = hb_beamr:call(\n        instance(M1, M2, Opts),\n        WASMFunction,\n        WASMParams,\n        ImportResolver,\n        M1,\n        Opts\n    ),\n    \n    % Return results\n    {ok, hb_ao:set(MsgAfterExecution, #{\n        <<\"results/\", Prefix/binary, \"/type\">> => ResType,\n        <<\"results/\", Prefix/binary, \"/output\">> => Res\n    })}\n```\n\n### 3. State Management\n\n```erlang\n% Normalize state\nnormalize(RawM1, M2, Opts) ->\n    case instance(RawM1, M2, Opts) of\n        not_found ->\n            % Load from snapshot if no instance\n            Memory = hb_ao:get([<<\"snapshot\">>] ++ DeviceKey ++ [<<\"body\">>],\n                             {as, dev_message, RawM1}, Opts),\n            case Memory of\n                not_found -> throw({error, no_wasm_instance_or_snapshot});\n                State ->\n                    {ok, M1} = init(RawM1, State, Opts),\n                    hb_beamr:deserialize(instance(M1, M2, Opts), State),\n                    M1\n            end;\n        _ -> RawM1\n    end\n\n% Create snapshot\nsnapshot(M1, M2, Opts) ->\n    Instance = instance(M1, M2, Opts),\n    {ok, Serialized} = hb_beamr:serialize(Instance),\n    {ok, #{ <<\"body\">> => Serialized }}\n```\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Initialization\n```erlang\n?event(running_init)\n?event({in_prefix, InPrefix})\n?event({getting_wasm_image, ImageID})\n?event(wasm_image_message_directly_provided)\n?event({setting_wasm_instance, Instance, {prefix, Prefix}})\n```\n\n2. Computation\n```erlang\n?event(running_compute)\n?event({skipping_wasm_exec, {reason, wasm_function_not_provided}})\n?event({calling_wasm_executor, {wasm_function, WASMFunction}})\n```\n\n3. State Management\n```erlang\n?event({normalize_raw_m1, RawM1})\n?event(wasm_instance_found_not_deserializing)\n?event(snapshot, generating_snapshot)\n?event(terminate_called_on_dev_wasm)\n```\n\n## Test Coverage\n\n1. **Initialization Tests**\n```erlang\ninput_prefix_test() ->\n    % Tests input prefix handling\nprocess_prefixes_test() ->\n    % Tests process prefix handling\ninit_test() ->\n    % Tests basic initialization\n```\n\n2. **Execution Tests**\n```erlang\nbasic_execution_test() ->\n    % Tests basic WASM function execution\nbasic_execution_64_test() ->\n    % Tests Memory-64 execution\nimported_function_test() ->\n    % Tests imported function handling\n```\n\n3. **Performance Tests**\n```erlang\nbenchmark_test() ->\n    % Tests execution performance\n    % Verifies >5 iterations in 0.5s\n```\n\n4. **State Management Tests**\n```erlang\nstate_export_and_restore_test() ->\n    % Tests state serialization\n    % Tests state restoration\n    % Verifies computation results\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_beamr: WASM runtime interface\n- hb_beamr_io: WASM I/O operations\n- dev_stack: Device stack management\n- hb_ao: Message handling\n- hb_cache: Image and state caching\n- hb_private: Private state management\n\n### Usage Context\n- Called by dev_process for WASM execution\n- Integrates with WAMR runtime\n- Manages WASM state persistence\n- Handles function imports/exports\n"},"devices/Process & Execution/observations.md":{"content":"# Process & Execution System Observations\n\n## Architectural Patterns\n\n### 1. Process Lifecycle Management\n- **Initialization Pattern**\n  - Common `init/3` interface across execution devices\n  - State initialization with error handling\n  - Resource allocation and setup\n  - Configuration validation\n\n- **State Management**\n  - Consistent use of `normalize/3` for state restoration\n  - `snapshot/3` for state persistence\n  - Private state encapsulation via hb_private\n  - Cache-based state storage\n\n### 2. Execution Models\n\n#### Direct Execution\n- **WASM/WASI**\n  - Direct bytecode execution\n  - Memory isolation\n  - System call interception\n  - Resource limits enforcement\n\n- **Lua**\n  - Sandboxed environment\n  - Function-level isolation\n  - State persistence\n  - AO Core integration\n\n#### Delegated Execution\n- **Remote Computation**\n  - JSON-Iface protocol\n  - Result verification\n  - State synchronization\n  - Error propagation\n\n- **Legacy Integration**\n  - Genesis WASM compatibility\n  - Process migration support\n  - State translation\n  - Protocol adaptation\n\n### 3. Integration Mechanisms\n\n#### Message-Based Communication\n- Consistent use of AO Core messaging\n- Standardized error formats\n- Event logging patterns\n- State transfer protocols\n\n#### Resource Management\n- Cache coordination\n- Memory limits\n- Process isolation\n- Resource cleanup\n\n## Implementation Patterns\n\n### 1. Error Handling\n```erlang\n% Common error response format\n{error, #{\n    <<\"status\">> => StatusCode,\n    <<\"body\">> => ErrorMessage,\n    <<\"details\">> => Details\n}}\n```\n\n### 2. State Management\n```erlang\n% Private state pattern\nhb_private:set(Base, <<\"state\">>, State, Opts)\nhb_private:get(<<\"state\">>, Base, Opts)\n```\n\n### 3. Event Logging\n```erlang\n% Standardized event logging\n?event(Category, {action, {param, Value}})\n?event(debug_category, {debug_info})\n```\n\n## Cross-Cutting Concerns\n\n### 1. Security\n- Sandboxing in execution environments\n- Resource limits enforcement\n- Input validation\n- State isolation\n\n### 2. Performance\n- Caching strategies\n- State persistence optimization\n- Resource pooling\n- Execution batching\n\n### 3. Reliability\n- Error recovery\n- State restoration\n- Process monitoring\n- Resource cleanup\n\n## Testing Approaches\n\n### 1. Unit Testing\n- Function-level tests\n- Error case coverage\n- State management verification\n- Resource cleanup validation\n\n### 2. Integration Testing\n- Cross-module interaction\n- Protocol compliance\n- Error propagation\n- Resource management\n\n### 3. Performance Testing\n- Execution benchmarks\n- Resource utilization\n- State persistence metrics\n- Cache effectiveness\n\n## Design Patterns\n\n### 1. Device Pattern\n```erlang\n% Common device interface\n-export([\n    init/3,\n    compute/3,\n    normalize/3,\n    snapshot/3\n]).\n```\n\n### 2. State Management Pattern\n```erlang\n% State lifecycle\ninit -> compute -> snapshot -> normalize\n```\n\n### 3. Resource Management Pattern\n```erlang\n% Resource allocation with cleanup\nsetup_resources() ->\n    allocate(),\n    register_cleanup().\n```\n\n## Module Relationships\n\n### Core Dependencies\n```mermaid\ngraph TD\n    A[dev_process] --> B[dev_process_worker]\n    A --> C[dev_process_cache]\n    B --> D[Execution Devices]\n    D --> E[dev_wasm]\n    D --> F[dev_lua]\n    D --> G[dev_genesis_wasm]\n    D --> H[dev_delegated_compute]\n```\n\n### State Flow\n```mermaid\ngraph LR\n    A[Initialize] --> B[Execute]\n    B --> C[Snapshot]\n    C --> D[Normalize]\n    D --> B\n```\n\n## Key Insights\n\n### 1. Modularity\n- Clear separation of concerns\n- Pluggable execution environments\n- Standardized interfaces\n- Flexible state management\n\n### 2. Extensibility\n- Common device pattern\n- Consistent error handling\n- Unified event logging\n- Resource management patterns\n\n### 3. Reliability\n- Comprehensive error handling\n- State persistence\n- Resource cleanup\n- Process isolation\n\n### 4. Performance\n- Caching strategies\n- Resource pooling\n- Execution optimization\n- State management efficiency\n\n## Areas for Enhancement\n\n### 1. Documentation\n- More detailed error scenarios\n- Performance tuning guidelines\n- Resource management best practices\n- Security considerations\n\n### 2. Testing\n- More comprehensive benchmarks\n- Cross-environment testing\n- Error injection testing\n- Resource leak detection\n\n### 3. Monitoring\n- Enhanced metrics collection\n- Resource usage tracking\n- Performance profiling\n- Error pattern analysis\n\n## Best Practices\n\n### 1. Process Management\n- Always cleanup resources\n- Validate state transitions\n- Handle all error cases\n- Log significant events\n\n### 2. State Management\n- Use private state encapsulation\n- Implement state snapshots\n- Handle restoration errors\n- Cache effectively\n\n### 3. Error Handling\n- Provide detailed error info\n- Clean up on failures\n- Log error contexts\n- Handle edge cases\n\n### 4. Testing\n- Test error scenarios\n- Verify state management\n- Check resource cleanup\n- Measure performance\n"},"devices/Process & Execution/OVERVIEW.md":{"content":"# Process & Execution System: Comprehensive Overview\n\n## System Foundation\n\nThe Process & Execution system serves as the cornerstone of HyperBEAM's computational capabilities, providing a sophisticated framework for executing code across diverse environments while maintaining robust security boundaries, ensuring reliable operation, and delivering consistent performance. This system implements a layered architecture that separates concerns between process management, execution environments, and resource control.\n\n### Core Philosophy\n\nThe system is built on several fundamental principles:\n\n1. **Environment Isolation**: Each execution context operates within strictly defined boundaries, preventing unauthorized access and resource consumption while enabling secure code execution.\n\n2. **State Management**: Comprehensive tracking and persistence of process states ensures reliability and enables recovery from failures, while maintaining execution consistency.\n\n3. **Resource Control**: Fine-grained management of system resources prevents overconsumption and ensures fair allocation across multiple processes.\n\n4. **Extensibility**: A plugin-based architecture allows for the addition of new execution environments without modifying the core system.\n\n## Architectural Components\n\n### 1. Process Management Layer\n\n#### dev_process\nThe central orchestrator that coordinates process lifecycle management:\n- Handles process creation and initialization\n- Manages state transitions and persistence\n- Coordinates between execution environments\n- Implements resource allocation strategies\n\n#### dev_process_worker\nDedicated worker processes that:\n- Execute individual process instances\n- Maintain isolation boundaries\n- Handle state transitions\n- Monitor resource usage\n\n#### dev_process_cache\nOptimizes process execution through:\n- State caching mechanisms\n- Quick recovery capabilities\n- Memory usage optimization\n- Performance enhancement\n\n### 2. Execution Environments\n\n#### Native Execution Layer\n\n##### dev_wasm & dev_wasi\nWebAssembly execution environment providing:\n- Direct bytecode execution capabilities\n- System call interception and validation\n- Memory isolation and protection\n- Resource usage monitoring and limits\n\n##### dev_lua\nLua scripting environment offering:\n- Sandboxed execution context\n- Function-level isolation\n- State persistence mechanisms\n- AO Core integration capabilities\n\n#### Remote Execution Layer\n\n##### dev_delegated_compute\nEnables distributed computation through:\n- Remote execution coordination\n- Result verification mechanisms\n- State synchronization protocols\n- Error handling and recovery\n\n##### dev_genesis_wasm\nProvides legacy system compatibility via:\n- Process migration support\n- State translation mechanisms\n- Protocol adaptation layers\n- Backward compatibility assurance\n\n#### Node-Specific Layer\n\n##### dev_node_process\nManages node-local processes with:\n- Local name registration\n- Process persistence\n- State management\n- Resource coordination\n\n## System Interactions\n\n### Process Lifecycle Flow\n\n```mermaid\nsequenceDiagram\n    participant Client as Client System\n    participant Process as Process Manager\n    participant Worker as Process Worker\n    participant Executor as Execution Environment\n    participant Cache as State Cache\n\n    Client->>Process: Initialize Process\n    Note over Process: Validate Configuration\n    Process->>Worker: Create Worker\n    Worker->>Executor: Setup Environment\n    Note over Executor: Configure Isolation\n    Executor-->>Worker: Environment Ready\n    Worker->>Cache: Initialize State\n    Worker-->>Process: Worker Ready\n    Process-->>Client: Process Initialized\n```\n\n### State Management Flow\n\n```mermaid\nsequenceDiagram\n    participant Process as Process Manager\n    participant Cache as State Cache\n    participant Storage as Persistent Storage\n    participant Executor as Execution Environment\n\n    Process->>Cache: Request State\n    alt State in Cache\n        Cache-->>Process: Return Cached State\n    else State Not Found\n        Cache->>Storage: Load State\n        Storage-->>Cache: State Data\n        Cache-->>Process: Return State\n    end\n    Process->>Executor: Initialize with State\n    Note over Executor: Execute Process\n    Executor->>Process: State Update\n    Process->>Cache: Store Updated State\n    Cache->>Storage: Persist State\n```\n\n## Implementation Details\n\n### 1. Process State Management\n\nThe system implements a sophisticated state management approach:\n\n```erlang\n% State Lifecycle Management\n-record(process_state, {\n    id :: binary(),\n    environment :: atom(),\n    resources :: map(),\n    execution_context :: map(),\n    metadata :: map()\n}).\n\n% State Transitions\nhandle_state_transition(State, Event) ->\n    validate_transition(State, Event),\n    apply_transition(State, Event),\n    persist_state(State),\n    notify_observers(State, Event).\n```\n\n### 2. Resource Control\n\nResource management is implemented through multiple layers:\n\n```erlang\n% Resource Allocation\nallocate_resources(Requirements) ->\n    validate_availability(Requirements),\n    reserve_resources(Requirements),\n    monitor_usage(Requirements),\n    register_cleanup(Requirements).\n\n% Usage Monitoring\nmonitor_resources(Allocation) ->\n    track_memory_usage(Allocation),\n    monitor_cpu_usage(Allocation),\n    check_time_limits(Allocation),\n    verify_permissions(Allocation).\n```\n\n### 3. Error Handling\n\nComprehensive error handling ensures system stability:\n\n```erlang\n% Error Management\nhandle_error(Error, Context) ->\n    log_error(Error, Context),\n    cleanup_resources(Context),\n    notify_monitoring(Error),\n    initiate_recovery(Context).\n\n% Recovery Procedures\nrecover_from_error(Error, State) ->\n    restore_safe_state(State),\n    reallocate_resources(State),\n    restart_execution(State),\n    verify_recovery(State).\n```\n\n## Security Considerations\n\n### 1. Isolation Mechanisms\n\nMultiple layers of isolation protect the system:\n\n- Memory isolation through WebAssembly\n- Process-level isolation via separate workers\n- Resource quotas and limits\n- Input validation and sanitization\n\n### 2. Permission Management\n\nGranular permission control ensures security:\n\n- Execution environment permissions\n- Resource access controls\n- Network restrictions\n- File system limitations\n\n## Performance Optimization\n\n### 1. Caching Strategy\n\nMulti-level caching improves performance:\n\n- Process state caching\n- Execution context caching\n- Resource allocation caching\n- Result caching\n\n### 2. Resource Pooling\n\nEfficient resource management through:\n\n- Worker process pooling\n- Memory pool management\n- Connection pooling\n- Cache pool optimization\n\n## Monitoring and Metrics\n\n### 1. Performance Metrics\n\nComprehensive monitoring includes:\n\n- Execution time tracking\n- Resource usage monitoring\n- Cache hit rates\n- Error frequency analysis\n\n### 2. Health Checks\n\nSystem health is maintained through:\n\n- Process health monitoring\n- Resource availability checks\n- Error rate tracking\n- Performance threshold monitoring\n\n## Future Enhancements\n\n### 1. Technical Improvements\n\nPlanned technical enhancements:\n\n- Additional execution environments\n- Enhanced security features\n- Improved performance monitoring\n- Better resource management\n\n### 2. Architectural Evolution\n\nFuture architectural changes:\n\n- Enhanced distribution capabilities\n- Improved state management\n- Better error recovery\n- More flexible resource allocation\n\n## Best Practices\n\n### 1. Development Guidelines\n\nKey development practices:\n\n- Follow the device pattern\n- Implement complete lifecycle\n- Handle all error cases\n- Maintain proper logging\n\n### 2. Operational Guidelines\n\nOperational considerations:\n\n- Monitor resource usage\n- Track performance metrics\n- Analyze error patterns\n- Maintain security protocols\n"},"devices/resource_stack_management/modules/dev_lookup.md":{"content":"# Module: dev_lookup\n\n## Basic Information\n- **Source File:** dev_lookup.erl\n- **Module Type:** Lookup Device\n- **Purpose:** Retrieves data from local storage by ID and handles format conversion based on accept headers.\n\n## Core Functionality\n\n### 1. Lookup Architecture\n```mermaid\ngraph TD\n    A[Lookup Request] --> B[ID Extraction]\n    B --> C[Cache Lookup]\n    \n    C --> D[Format Selection]\n    D --> E[Raw Format]\n    D --> F[AOS-2 Format]\n    \n    E --> G[Direct Return]\n    F --> H[JSON Conversion]\n    H --> I[Structured Response]\n```\n\n### 2. Request Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Lookup\n    participant Cache\n    participant Converter\n    \n    Client->>Lookup: Request with ID\n    Lookup->>Cache: Read ID\n    Cache-->>Lookup: Return Data\n    \n    alt Accept: application/aos-2\n        Lookup->>Converter: Convert to JSON\n        Converter-->>Lookup: Return Structured\n        Lookup-->>Client: Return AOS-2 Format\n    else Default Format\n        Lookup-->>Client: Return Raw Data\n    end\n```\n\n## Implementation Details\n\n### 1. Core Operation\n```erlang\nread(_M1, M2, Opts) ->\n    % Extract target ID\n    ID = hb_ao:get(<<\"target\">>, M2, Opts),\n    \n    % Attempt cache lookup\n    case hb_cache:read(ID, Opts) of\n        {ok, Res} ->\n            % Handle format conversion\n            case hb_ao:get(<<\"accept\">>, M2, Opts) of\n                <<\"application/aos-2\">> ->\n                    convert_to_aos2(Res);\n                _ ->\n                    {ok, Res}\n            end;\n        not_found ->\n            {error, not_found}\n    end\n```\n\n### 2. Format Conversion\n```erlang\nconvert_to_aos2(Data) ->\n    % Convert to JSON structure\n    Struct = dev_json_iface:message_to_json_struct(Data),\n    \n    % Return formatted response\n    {ok, #{\n        <<\"body\">> => hb_json:encode(Struct),\n        <<\"content-type\">> => <<\"application/aos-2\">>\n    }}\n```\n\n## Key Features\n\n### 1. ID Resolution\n- Target extraction\n- Cache lookup\n- Error handling\n- Result validation\n- Format detection\n\n### 2. Format Handling\n- Raw data support\n- AOS-2 conversion\n- JSON structuring\n- Content-type management\n- Response formatting\n\n### 3. Cache Integration\n- Local storage access\n- Data retrieval\n- Error handling\n- Format preservation\n- Response management\n\n## Usage Examples\n\n### 1. Basic Lookup\n```erlang\n% Look up raw data\n{ok, Result} = dev_lookup:read(\n    #{},\n    #{\n        <<\"target\">> => DataID\n    },\n    #{}\n)\n```\n\n### 2. AOS-2 Format\n```erlang\n% Look up with AOS-2 format\n{ok, Result} = dev_lookup:read(\n    #{},\n    #{\n        <<\"target\">> => DataID,\n        <<\"accept\">> => <<\"application/aos-2\">>\n    },\n    #{}\n)\n```\n\n### 3. HTTP Integration\n```erlang\n% HTTP-based lookup\nNode = hb_http_server:start_node(Opts),\nReq = hb_message:commit(#{\n    <<\"path\">> => <<\"/~lookup@1.0/read?target=\", ID/binary>>,\n    <<\"device\">> => <<\"lookup@1.0\">>,\n    <<\"accept\">> => <<\"application/aos-2\">>\n}, Wallet)\n```\n\n## Error Handling\n\n### 1. Lookup Errors\n- Missing IDs\n- Invalid targets\n- Cache failures\n- Format errors\n- Response validation\n\n### 2. Format Errors\n- Invalid formats\n- Conversion failures\n- Structure errors\n- Encoding issues\n- Type mismatches\n\n### 3. Cache Errors\n- Access failures\n- Missing data\n- Storage errors\n- Format issues\n- System failures\n\n## Performance Considerations\n\n### 1. Cache Efficiency\n- Quick lookups\n- Format caching\n- Response time\n- Memory usage\n- Storage optimization\n\n### 2. Format Conversion\n- Conversion speed\n- Memory impact\n- Response size\n- Structure efficiency\n- Cache utilization\n\n### 3. Response Time\n- Lookup speed\n- Format selection\n- Conversion time\n- Response building\n- Error handling\n\n## Future Improvements\n\n### 1. Feature Extensions\n- More formats\n- Better caching\n- Enhanced validation\n- Format detection\n- Error recovery\n\n### 2. Performance Optimization\n- Faster lookups\n- Better conversion\n- Improved caching\n- Enhanced validation\n- Error handling\n\n### 3. Integration Enhancement\n- More formats\n- Better protocols\n- Enhanced security\n- Improved validation\n- Better integration\n"},"devices/resource_stack_management/modules/dev_manifest.md":{"content":"# Module: dev_manifest\n\n## Basic Information\n- **Source File:** dev_manifest.erl\n- **Module Type:** Manifest Resolution Device\n- **Purpose:** Resolves Arweave path manifests according to the v1 schema specification (https://specs.ar.io/?tx=lXLd0OPwo-dJLB_Amz5jgIeDhiOkjXuM3-r0H_aiNj0)\n\n## Core Functionality\n\n### 1. Manifest Architecture\n```mermaid\ngraph TD\n    A[Manifest Request] --> B[Route Selection]\n    B --> C[Index Route]\n    B --> D[Path Route]\n    \n    C --> E[Manifest Lookup]\n    D --> E\n    \n    E --> F[JSON Deserialization]\n    F --> G[Path Resolution]\n    \n    G --> H[Data Retrieval]\n    H --> I[Fallback Resolution]\n```\n\n### 2. Resolution Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Router\n    participant Manifest\n    participant Cache\n    participant JSON\n    \n    Client->>Router: Request Path\n    Router->>Manifest: Route Request\n    Manifest->>Manifest: Load Manifest\n    Manifest->>JSON: Deserialize\n    \n    alt Index Path\n        JSON->>JSON: Get Index Path\n        JSON->>Router: Reroute to Path\n    else Direct Path\n        JSON->>JSON: Resolve Path\n        JSON->>Cache: Get Data\n        \n        alt Data Found\n            Cache-->>Client: Return Data\n        else Data Not Found\n            Cache->>Cache: Get Fallback\n            Cache-->>Client: Return Fallback\n        end\n    end\n```\n\n## Implementation Details\n\n### 1. Route Handler\n```erlang\nroute(<<\"index\">>, M1, M2, Opts) ->\n    % Get manifest\n    case manifest(M1, M2, Opts) of\n        {ok, JSONStruct} ->\n            % Resolve index path\n            case hb_ao:resolve(JSONStruct, [<<\"index\">>, <<\"path\">>], Opts) of\n                {ok, Path} ->\n                    % Route to resolved path\n                    route(Path, M1, M2, Opts);\n                _ -> {error, not_found}\n            end;\n        {error, not_found} ->\n            {error, not_found}\n    end\n```\n\n### 2. Path Resolution\n```erlang\nroute(Key, M1, M2, Opts) ->\n    % Get manifest\n    {ok, JSONStruct} = manifest(M1, M2, Opts),\n    \n    % Resolve path entry\n    case hb_ao:resolve(JSONStruct, [<<\"paths\">>, Key], Opts) of\n        {ok, Entry} ->\n            ID = maps:get(<<\"id\">>, Entry),\n            \n            % Try to get data\n            case hb_cache:read(ID, Opts) of\n                {ok, Data} ->\n                    {ok, Data};\n                {error, not_found} ->\n                    % Try fallback\n                    Fallback = hb_ao:get(JSONStruct, <<\"fallback\">>, Opts),\n                    FallbackID = maps:get(<<\"id\">>, Fallback),\n                    hb_cache:read(FallbackID, Opts)\n            end;\n        _ -> {error, not_found}\n    end\n```\n\n## Key Features\n\n### 1. Manifest Handling\n- JSON deserialization\n- Path resolution\n- Index handling\n- Fallback support\n- Error management\n\n### 2. Path Resolution\n- Index paths\n- Direct paths\n- Path validation\n- Entry lookup\n- Data retrieval\n\n### 3. Data Management\n- Cache integration\n- Fallback handling\n- ID resolution\n- Format handling\n- Error recovery\n\n## Usage Examples\n\n### 1. Index Resolution\n```erlang\n% Resolve index path\n{ok, Result} = dev_manifest:route(\n    <<\"index\">>,\n    ManifestBase,\n    #{},\n    #{}\n)\n```\n\n### 2. Path Resolution\n```erlang\n% Resolve specific path\n{ok, Result} = dev_manifest:route(\n    <<\"path/to/resource\">>,\n    ManifestBase,\n    #{},\n    #{}\n)\n```\n\n### 3. Manifest Structure\n```erlang\n% Example manifest structure\n{\n    \"index\": {\n        \"path\": \"index.html\"\n    },\n    \"paths\": {\n        \"index.html\": {\n            \"id\": \"primary-id\"\n        }\n    },\n    \"fallback\": {\n        \"id\": \"fallback-id\"\n    }\n}\n```\n\n## Error Handling\n\n### 1. Resolution Errors\n- Invalid paths\n- Missing entries\n- JSON errors\n- Cache failures\n- Manifest errors\n\n### 2. Data Errors\n- Missing data\n- Invalid IDs\n- Cache errors\n- Format issues\n- System failures\n\n### 3. Fallback Errors\n- Missing fallbacks\n- Invalid fallbacks\n- Cache errors\n- Format issues\n- System failures\n\n## Performance Considerations\n\n### 1. Resolution Speed\n- Path lookup\n- JSON parsing\n- Cache access\n- Fallback handling\n- Error recovery\n\n### 2. Cache Efficiency\n- Data retrieval\n- Fallback access\n- ID resolution\n- Format handling\n- Error management\n\n### 3. Resource Usage\n- Memory allocation\n- Cache utilization\n- JSON processing\n- Path resolution\n- Error handling\n\n## Future Improvements\n\n### 1. Feature Extensions\n- More formats\n- Better caching\n- Enhanced validation\n- Path optimization\n- Error recovery\n\n### 2. Performance Optimization\n- Faster resolution\n- Better caching\n- Improved validation\n- Enhanced fallbacks\n- Error handling\n\n### 3. Integration Enhancement\n- More formats\n- Better protocols\n- Enhanced security\n- Improved validation\n- Better integration\n"},"devices/resource_stack_management/modules/dev_push.md":{"content":"# Module: dev_push\n\n## Basic Information\n- **Source File:** dev_push.erl\n- **Module Type:** Message Push Device\n- **Purpose:** Handles recursive message pushing between processes, evaluating messages and propagating them through the system until no messages remain to be pushed.\n\n## Core Functionality\n\n### 1. Push Architecture\n```mermaid\ngraph TD\n    A[Push Request] --> B[Mode Selection]\n    B --> C[Synchronous]\n    B --> D[Asynchronous]\n    \n    C --> E[Message Evaluation]\n    D --> E\n    \n    E --> F[Message Type]\n    F --> G[Process]\n    F --> H[Message]\n    \n    G --> I[Initialize Process]\n    H --> J[Push Message]\n    \n    J --> K[Outbox Processing]\n    K --> L[Target Resolution]\n    L --> M[Message Delivery]\n```\n\n### 2. Message Flow\n```mermaid\nsequenceDiagram\n    participant Source as Source Process\n    participant Push as Push Device\n    participant Target as Target Process\n    participant Cache as Cache System\n    \n    Source->>Push: Submit Message/Slot\n    Push->>Push: Determine Mode\n    Push->>Push: Evaluate Message\n    Push->>Cache: Check Target\n    Cache-->>Push: Return Target Info\n    Push->>Target: Schedule Message\n    Target-->>Push: Return Assignment\n    Push->>Push: Process Outbox\n    Push->>Source: Return Result\n```\n\n## Implementation Details\n\n### 1. Push Operation\n```erlang\npush(Base, Req, Opts) ->\n    % Convert base to process\n    ModBase = dev_process:as_process(Base, Opts),\n    \n    % Check for slot number\n    case get_slot(Req) of\n        no_slot ->\n            % Schedule initial message\n            schedule_and_push(ModBase, Req, Opts);\n        _ ->\n            % Push with selected mode\n            push_with_mode(ModBase, Req, Opts)\n    end\n```\n\n### 2. Mode Selection\n```erlang\npush_with_mode(Base, Req, Opts) ->\n    Mode = is_async(Base, Req, Opts),\n    case Mode of\n        <<\"sync\">> ->\n            do_push(Base, Req, Opts);\n        <<\"async\">> ->\n            spawn(fun() -> do_push(Base, Req, Opts) end)\n    end\n```\n\n### 3. Message Processing\n```erlang\ndo_push(Base, Assignment, Opts) ->\n    % Get slot and process ID\n    Slot = get_slot(Assignment),\n    ID = get_process_id(Base),\n    \n    % Compute results\n    {Status, Result} = compute_results(Base, Slot, Opts),\n    \n    % Process outbox\n    case get_outbox(Result) of\n        empty -> \n            return_success(Slot, ID);\n        Outbox ->\n            process_outbox(Outbox, Base, Slot, Opts)\n    end\n```\n\n## Key Features\n\n### 1. Push Modes\n\n#### Synchronous\n- Direct execution\n- Result waiting\n- Error handling\n- State tracking\n- Resource management\n\n#### Asynchronous\n- Background processing\n- Non-blocking\n- Parallel execution\n- Resource efficiency\n- Error isolation\n\n### 2. Message Handling\n- Type detection\n- Slot management\n- Target resolution\n- State tracking\n- Error handling\n\n### 3. Process Management\n- Process conversion\n- Identity tracking\n- Resource control\n- State management\n- Error recovery\n\n## Usage Examples\n\n### 1. Basic Push\n```erlang\n% Push a message synchronously\n{ok, Result} = dev_push:push(\n    BaseProcess,\n    #{\n        <<\"slot\">> => SlotNumber,\n        <<\"push-mode\">> => <<\"sync\">>\n    },\n    #{}\n)\n```\n\n### 2. Async Push\n```erlang\n% Push a message asynchronously\n{ok, Result} = dev_push:push(\n    BaseProcess,\n    #{\n        <<\"slot\">> => SlotNumber,\n        <<\"push-mode\">> => <<\"async\">>\n    },\n    #{}\n)\n```\n\n### 3. Process Push\n```erlang\n% Push a process initialization\n{ok, Result} = dev_push:push(\n    BaseProcess,\n    #{\n        <<\"type\">> => <<\"Process\">>,\n        <<\"body\">> => ProcessDefinition\n    },\n    #{}\n)\n```\n\n## Error Handling\n\n### 1. Push Errors\n- Invalid slots\n- Missing targets\n- Process failures\n- Network issues\n- Resource exhaustion\n\n### 2. Target Errors\n- Invalid targets\n- Access denied\n- Resource limits\n- State conflicts\n- Network failures\n\n### 3. Process Errors\n- Initialization failures\n- State corruption\n- Resource limits\n- Access control\n- Network issues\n\n## Performance Considerations\n\n### 1. Resource Usage\n- Memory allocation\n- Process spawning\n- Network bandwidth\n- Cache utilization\n- State management\n\n### 2. Execution Efficiency\n- Mode selection\n- Target resolution\n- Message routing\n- State tracking\n- Error handling\n\n### 3. Network Impact\n- Message size\n- Target location\n- Protocol selection\n- Connection management\n- Error recovery\n\n## Future Improvements\n\n### 1. Feature Extensions\n- More push modes\n- Better error handling\n- Enhanced monitoring\n- Resource optimization\n- Performance tracking\n\n### 2. Performance Optimization\n- Faster processing\n- Better resource use\n- Improved error handling\n- Enhanced monitoring\n- State management\n\n### 3. Integration Enhancement\n- More protocols\n- Better coordination\n- Enhanced security\n- Improved monitoring\n- Better integration\n"}}