{"devices/network_routing/OVERVIEW.md":{"content":"# Network Routing System: Comprehensive Technical Analysis\n\n## Architectural Foundation & Core Design Principles\n\n### 1. System Architecture Overview\n```mermaid\ngraph TD\n    A[Network Routing System] --> B[Message Routing Layer]\n    A --> C[Message Relay Layer]\n    A --> D[Security & Identity Layer]\n    \n    B --> E[Route Management]\n    B --> F[Load Balancing]\n    B --> G[Configuration]\n    \n    C --> H[Sync Operations]\n    C --> I[Async Operations]\n    C --> J[Protocol Handling]\n    \n    D --> K[Identity Management]\n    D --> L[Trust Management]\n    D --> M[Cryptographic Operations]\n```\n\nThe Network Routing System represents a sophisticated and meticulously engineered architecture that orchestrates message routing, relaying, and secure communication within the HyperBEAM ecosystem. This system is built upon three fundamental pillars:\n\n1. **Message Routing Layer (dev_router)**\n   - **Intelligent Route Selection**: Implements advanced algorithms for determining optimal message paths based on multiple criteria including load, distance, and network conditions\n   - **Dynamic Load Balancing**: Utilizes sophisticated strategies to distribute network load effectively across available nodes\n   - **Adaptive Configuration**: Maintains flexible routing tables that can be updated at runtime to reflect network changes\n   - **Performance Optimization**: Employs various techniques to minimize latency and maximize throughput\n\n2. **Message Relay Layer (dev_relay)**\n   - **Dual Operation Modes**: Supports both synchronous and asynchronous message processing to accommodate different use cases\n   - **Protocol Adaptation**: Handles seamless conversion between different message formats and protocols\n   - **State Management**: Maintains consistent message state throughout the relay process\n   - **Error Recovery**: Implements robust error handling and recovery mechanisms\n\n3. **Security & Identity Layer (dev_green_zone)**\n   - **Cryptographic Foundation**: Provides strong encryption and digital signature capabilities\n   - **Trust Management**: Establishes and maintains trust relationships between nodes\n   - **Access Control**: Enforces fine-grained permissions and security policies\n   - **Identity Verification**: Ensures authentic communication between trusted nodes\n\n### 2. Component Integration & Interaction Flow\n```mermaid\nsequenceDiagram\n    participant App as Application Layer\n    participant Router as Router Device\n    participant Relay as Relay Device\n    participant GZ as Green Zone\n    participant Target as Target Node\n    \n    App->>Router: Submit Message\n    Router->>Router: Route Selection\n    Router->>GZ: Verify Trust\n    GZ-->>Router: Trust Confirmed\n    Router->>Relay: Forward Message\n    Relay->>Target: Process Request\n    Target-->>Relay: Return Response\n    Relay-->>Router: Forward Response\n    Router-->>App: Deliver Result\n```\n\n## Core System Components & Their Functions\n\n### 1. Router Device Implementation\n\n#### Route Management System\n```erlang\n% Route configuration structure\nRoute = #{\n    template => Template,      % Message matching pattern\n    strategy => Strategy,      % Load balancing strategy\n    nodes => Nodes,           % Available target nodes\n    priority => Priority,     % Route precedence\n    options => Options       % Additional parameters\n}\n```\n\nThe router device implements sophisticated route management:\n\n1. **Template Matching**\n   - Pattern-based message routing\n   - Regular expression support\n   - Priority-based selection\n   - Fallback handling\n\n2. **Load Distribution**\n   - Multiple balancing strategies\n   - Weight-based routing\n   - Hash-based distribution\n   - Nearest node selection\n\n### 2. Relay Device Architecture\n\n#### Message Processing Pipeline\n```erlang\nprocess_message(Message, Mode, Options) ->\n    % 1. Initial processing\n    Validated = validate_message(Message),\n    \n    % 2. Protocol adaptation\n    Adapted = adapt_protocol(Validated, Options),\n    \n    % 3. Message handling\n    case Mode of\n        sync -> \n            handle_sync(Adapted, Options);\n        async ->\n            handle_async(Adapted, Options)\n    end\n```\n\nThe relay device provides sophisticated message handling:\n\n1. **Operation Modes**\n   - Synchronous processing for immediate responses\n   - Asynchronous handling for background operations\n   - Batch processing capabilities\n   - Priority-based queuing\n\n2. **Protocol Support**\n   - Multiple protocol adaptations\n   - Format conversion\n   - Header management\n   - Content transformation\n\n### 3. Green Zone Security Implementation\n\n#### Security Operations\n```erlang\nsecure_communication(Message, Node, Options) ->\n    % 1. Identity verification\n    {ok, Identity} = verify_identity(Node),\n    \n    % 2. Trust establishment\n    {ok, Trust} = establish_trust(Identity),\n    \n    % 3. Secure message handling\n    encrypt_and_sign(Message, Trust, Options)\n```\n\nThe green zone provides comprehensive security:\n\n1. **Identity Management**\n   - RSA key pair generation\n   - Identity verification\n   - Trust establishment\n   - Access control\n\n2. **Cryptographic Operations**\n   - AES-256-GCM encryption\n   - RSA signature generation\n   - Key exchange protocols\n   - Secure storage\n\n## Advanced Features & Capabilities\n\n### 1. Intelligent Route Selection\nThe system employs sophisticated algorithms for route selection:\n\n1. **Strategy Implementation**\n   ```erlang\n   select_route(Message, Routes, Options) ->\n       % 1. Filter applicable routes\n       Candidates = filter_routes(Message, Routes),\n       \n       % 2. Apply routing strategy\n       Selected = apply_strategy(\n           Candidates,\n           Options#strategy,\n           Message\n       ),\n       \n       % 3. Validate selection\n       validate_route(Selected, Options)\n   ```\n\n2. **Load Balancing**\n   ```erlang\n   balance_load(Nodes, Strategy, Message) ->\n       case Strategy of\n           random -> \n               random_selection(Nodes);\n           weighted ->\n               weighted_selection(Nodes);\n           nearest ->\n               nearest_node(Nodes, Message);\n           custom ->\n               custom_strategy(Nodes, Message)\n       end\n   ```\n\n### 2. Security & Trust Management\nThe system implements robust security measures:\n\n1. **Trust Establishment**\n   ```erlang\n   establish_trust(Node, Options) ->\n       % 1. Verify identity\n       {ok, Identity} = verify_node_identity(Node),\n       \n       % 2. Check trust chain\n       {ok, Chain} = verify_trust_chain(Identity),\n       \n       % 3. Establish secure channel\n       create_secure_channel(Chain, Options)\n   ```\n\n2. **Message Protection**\n   ```erlang\n   protect_message(Message, Trust, Options) ->\n       % 1. Encrypt content\n       Encrypted = encrypt_content(Message),\n       \n       % 2. Generate signature\n       Signed = sign_message(Encrypted),\n       \n       % 3. Prepare final message\n       prepare_protected_message(Signed, Options)\n   ```\n\n## Performance Optimization & Resource Management\n\n### 1. Connection Management\nThe system optimizes connection handling:\n\n1. **Connection Pooling**\n   ```erlang\n   manage_connections(Pool, Options) ->\n       % 1. Monitor pool status\n       Status = monitor_pool(Pool),\n       \n       % 2. Optimize connections\n       Optimized = optimize_pool(Status),\n       \n       % 3. Clean unused\n       cleanup_inactive(Optimized, Options)\n   ```\n\n2. **Resource Control**\n   ```erlang\n   control_resources(Resources, Limits) ->\n       % 1. Monitor usage\n       Usage = monitor_usage(Resources),\n       \n       % 2. Apply limits\n       Controlled = apply_limits(Usage, Limits),\n       \n       % 3. Optimize allocation\n       optimize_allocation(Controlled)\n   ```\n\n## Future Development & Evolution\n\n### 1. Planned Enhancements\nThe system is designed for future expansion:\n\n1. **Protocol Extensions**\n   - New routing strategies\n   - Enhanced security features\n   - Improved monitoring\n   - Better integration\n\n2. **Performance Improvements**\n   - Faster routing\n   - Better resource usage\n   - Enhanced security\n   - Improved reliability\n\n### 2. Architectural Evolution\nThe system supports continuous improvement:\n\n1. **Component Updates**\n   - Enhanced modules\n   - Better integration\n   - Improved security\n   - Optimized performance\n\n2. **Feature Additions**\n   - New capabilities\n   - Better monitoring\n   - Enhanced security\n   - Improved reliability\n"},"devices/Process & Execution/modules/dev_delegated_compute.md":{"content":"# Module: dev_delegated_compute\n\n## Basic Information\n- **Source File:** dev_delegated_compute.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Wrapper for remote machine computation using JSON-Iface\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([init/3, compute/3, normalize/3, snapshot/3]).\n```\n\n### Include Files\n```erlang\n-include(\"include/hb.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n```\n\n## Implementation Details\n\n### 1. State Management\n\n```erlang\n% Simple initialization - no special handling needed\ninit(Msg1, _Msg2, _Opts) ->\n    {ok, Msg1}.\n\n% State normalization - pass through\nnormalize(Msg1, _Msg2, _Opts) ->\n    {ok, Msg1}.\n\n% State snapshot - pass through\nsnapshot(Msg1, _Msg2, _Opts) ->\n    {ok, Msg1}.\n```\n\n### 2. Computation Handling\n\n```erlang\ncompute(Msg1, Msg2, Opts) ->\n    % Get process ID from either message\n    RawProcessID = dev_process:process_id(Msg1, #{}, Opts),\n    ProcessID = case RawProcessID of\n        not_found -> hb_ao:get(<<\"process-id\">>, Msg2, Opts);\n        ProcID -> ProcID\n    end,\n    \n    % Get output prefix for results\n    OutputPrefix = dev_stack:prefix(Msg1, Msg2, Opts),\n    \n    % Execute computation\n    case do_compute(ProcessID, Msg2, Opts) of\n        {ok, JSONRes} ->\n            % Convert JSON result to message\n            {ok, Msg} = dev_json_iface:json_to_message(JSONRes, Opts),\n            \n            % Return results in both message and JSON formats\n            {ok, hb_ao:set(Msg1, #{\n                <<OutputPrefix/binary, \"/results\">> => Msg,\n                <<OutputPrefix/binary, \"/results/json\">> => #{\n                    <<\"content-type\">> => <<\"application/json\">>,\n                    <<\"body\">> => JSONRes\n                }\n            }, Opts)};\n            \n        {error, Error} -> {error, Error}\n    end\n```\n\n### 3. Remote Execution\n\n```erlang\ndo_compute(ProcID, Msg2, Opts) ->\n    % Get slot number\n    Slot = hb_ao:get(<<\"slot\">>, Msg2, Opts),\n    \n    % Convert to AOS2 format\n    {ok, AOS2 = #{ <<\"body\">> := Body }} =\n        dev_scheduler_formats:assignments_to_aos2(\n            ProcID,\n            #{ Slot => Msg2 },\n            false,\n            Opts\n        ),\n    \n    % Execute via relay device\n    case hb_ao:resolve(\n        #{ <<\"device\">> => <<\"relay@1.0\">>,\n           <<\"content-type\">> => <<\"application/json\">> },\n        AOS2#{\n            <<\"path\">> => <<\"call\">>,\n            <<\"relay-method\">> => <<\"POST\">>,\n            <<\"relay-body\">> => Body,\n            <<\"relay-path\">> =>\n                <<\"/result/\",\n                  (integer_to_binary(Slot))/binary,\n                  \"?process-id=\", ProcID/binary>>,\n            <<\"content-type\">> => <<\"application/json\">>\n        },\n        Opts#{\n            hashpath => ignore,\n            cache_control => [<<\"no-store\">>, <<\"no-cache\">>]\n        }\n    ) of\n        {ok, Response} ->\n            JSONRes = hb_ao:get(<<\"body\">>, Response, Opts),\n            {ok, JSONRes};\n        {Err, Error} when Err == error; Err == failure ->\n            {error, Error}\n    end\n```\n\n## Message Flow\n\n### Input Message Requirements\n1. Process Identification\n   - Either in base message via dev_process:process_id/3\n   - Or in request message as <<\"process-id\">>\n\n2. Computation Details\n   - Slot number in request message\n   - Computation parameters in request message\n\n### Output Message Structure\n1. Results Path (`<prefix>/results`)\n   - Converted JSON response as message\n\n2. JSON Results Path (`<prefix>/results/json`)\n   ```json\n   {\n     \"content-type\": \"application/json\",\n     \"body\": \"<JSON response>\"\n   }\n   ```\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Computation Results\n```erlang\n?event({compute_lite_res,\n    {process_id, ProcessID},\n    {slot, Slot},\n    {json_res, {string, JSONRes}},\n    {req, Msg2}})\n```\n\n2. Remote Execution\n```erlang\n?event({do_compute_msg, {req, Msg2}})\n?event({do_compute_msg, {aos2, {string, Body}}})\n?event({delegated_compute_res_metadata,\n    {req, maps:without([<<\"body\">>], Response)}})\n```\n\n## Integration Points\n\n### Direct Dependencies\n- dev_process: Process ID extraction\n- dev_stack: Prefix management\n- dev_json_iface: JSON conversion\n- dev_scheduler_formats: AOS2 format conversion\n- hb_ao: Message resolution\n\n### Usage Context\n- Used as standalone for trusted remote results\n- Used as execution device for AO processes\n- Integrates with relay device for remote calls\n- Handles JSON-Iface protocol\n\n### Remote Protocol\n1. Request Format\n   - HTTP POST to `/result/<slot>?process-id=<id>`\n   - Body contains AOS2-formatted computation request\n   - Content-Type: application/json\n\n2. Response Format\n   - JSON response body\n   - No caching (no-store, no-cache)\n   - Response converted to message format\n\n## Key Features\n\n1. **Dual Usage Modes**\n   - Standalone for trusted remote results\n   - AO process execution device\n\n2. **Format Handling**\n   - AOS2 format for requests\n   - JSON-Iface for responses\n   - Message format conversion\n\n3. **State Management**\n   - Stateless operation\n   - Pass-through initialization\n   - No snapshot requirements\n\n4. **Error Handling**\n   - Remote execution errors\n   - JSON conversion errors\n   - Process ID resolution\n"},"devices/Process & Execution/modules/dev_genesis_wasm.md":{"content":"# Module: dev_genesis_wasm\n\n## Basic Information\n- **Source File:** dev_genesis_wasm.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Emulates legacynet AO process environment using HyperBEAM infrastructure\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([init/3, compute/3, normalize/3, snapshot/3]).\n```\n\n### Include Files\n```erlang\n-include_lib(\"eunit/include/eunit.hrl\").\n-include_lib(\"include/hb.hrl\").\n```\n\n### Constants\n```erlang\n% Timeout for legacy CU status check\n-define(STATUS_TIMEOUT, 100).\n```\n\n## Implementation Details\n\n### 1. Server Management\n\n```erlang\nensure_started(Opts) ->\n    % Check if server is running\n    IsRunning = is_genesis_wasm_server_running(Opts),\n    IsCompiled = hb_features:genesis_wasm(),\n    GenWASMProc = is_pid(hb_name:lookup(<<\"genesis-wasm@1.0\">>)),\n    \n    case IsRunning orelse (IsCompiled andalso GenWASMProc) of\n        true -> true;\n        false ->\n            % Start server process\n            PID = spawn(fun() ->\n                % Set up directories\n                NodeURL = \"http://localhost:\" ++ \n                         integer_to_list(hb_opts:get(port, no_port, Opts)),\n                DBDir = filename:absname(hb_util:list(\n                    hb_opts:get(genesis_wasm_db_dir,\n                               \"cache-mainnet/genesis-wasm\",\n                               Opts))),\n                CheckpointDir = filename:absname(hb_util:list(\n                    hb_opts:get(genesis_wasm_checkpoints_dir,\n                               \"cache-mainnet/genesis-wasm/checkpoints\",\n                               Opts))),\n                DatabaseUrl = filename:absname(DBDir ++ \"/genesis-wasm-db\"),\n                \n                % Create directories\n                filelib:ensure_path(DBDir),\n                filelib:ensure_path(CheckpointDir),\n                \n                % Start server process\n                Port = open_port({spawn_executable,\n                    \"_build/genesis-wasm-server/launch-monitored.sh\"},\n                    [binary, use_stdio, stderr_to_stdout,\n                     {args, [\"npm\", \"--prefix\",\n                            \"_build/genesis-wasm-server\",\n                            \"run\", \"dev\"]},\n                     {env, [\n                         {\"UNIT_MODE\", \"hbu\"},\n                         {\"HB_URL\", NodeURL},\n                         {\"PORT\", integer_to_list(\n                             hb_opts:get(genesis_wasm_port, 6363, Opts))},\n                         {\"DB_URL\", DatabaseUrl},\n                         {\"NODE_CONFIG_ENV\", \"development\"},\n                         {\"DEFAULT_LOG_LEVEL\", hb_util:list(\n                             hb_opts:get(genesis_wasm_log_level,\n                                        \"error\", Opts))},\n                         {\"WALLET_FILE\", filename:absname(hb_util:list(\n                             hb_opts:get(priv_key_location,\n                                        no_key, Opts)))},\n                         {\"DISABLE_PROCESS_FILE_CHECKPOINT_CREATION\", \"false\"},\n                         {\"PROCESS_MEMORY_FILE_CHECKPOINTS_DIR\", CheckpointDir}\n                     ]}]),\n                collect_events(Port)\n            end),\n            \n            % Register process\n            hb_name:register(<<\"genesis-wasm@1.0\">>, PID),\n            \n            % Wait for startup\n            hb_util:until(fun() ->\n                receive after 2000 -> ok end,\n                Status = is_genesis_wasm_server_running(Opts),\n                Status\n            end),\n            true\n    end\n```\n\n### 2. Computation Handling\n\n```erlang\ncompute(Msg, Msg2, Opts) ->\n    % Validate genesis-wasm feature\n    case ensure_started(Opts) of\n        true ->\n            % Execute via delegated-compute device\n            case hb_ao:resolve(Msg,\n                    {as, <<\"delegated-compute@1.0\">>, Msg2}, Opts) of\n                {ok, Msg3} ->\n                    % Apply patches via patch device\n                    {ok, Msg4} = hb_ao:resolve(Msg3,\n                        {as, <<\"patch@1.0\">>, Msg2}, Opts),\n                    {ok, Msg4};\n                {error, Error} -> {error, Error}\n            end;\n        false ->\n            {error, #{\n                <<\"status\">> => 500,\n                <<\"message\">> =>\n                    <<\"HyperBEAM was not compiled with genesis-wasm@1.0 on \"\n                        \"this node.\">>\n            }}\n    end\n```\n\n### 3. Server Status Management\n\n```erlang\n% Check server status with caching\nis_genesis_wasm_server_running(Opts) ->\n    case get(genesis_wasm_pid) of\n        undefined ->\n            Parent = self(),\n            PID = spawn(fun() ->\n                Parent ! {ok, self(), status(Opts)}\n            end),\n            receive\n                {ok, PID, Status} ->\n                    put(genesis_wasm_pid, Status),\n                    Status\n            after ?STATUS_TIMEOUT ->\n                erlang:exit(PID, kill),\n                false\n            end;\n        _ -> true\n    end\n\n% Check server status via HTTP\nstatus(Opts) ->\n    ServerPort = integer_to_binary(\n        hb_opts:get(genesis_wasm_port, 6363, Opts)),\n    try hb_http:get(\n        <<\"http://localhost:\", ServerPort/binary, \"/status\">>,\n        Opts) of\n        {ok, _} -> true;\n        _ -> false\n    catch\n        _:_ -> false\n    end\n```\n\n### 4. Event Collection\n\n```erlang\n% Collect and log server events\ncollect_events(Port) ->\n    collect_events(Port, <<>>).\ncollect_events(Port, Acc) ->\n    receive\n        {Port, {data, Data}} ->\n            collect_events(Port,\n                log_server_events(<<Acc/binary, Data/binary>>));\n        stop ->\n            port_close(Port),\n            ok\n    end\n\n% Log server output lines\nlog_server_events(Bin) when is_binary(Bin) ->\n    log_server_events(binary:split(Bin, <<\"\\n\">>, [global]));\nlog_server_events([Remaining]) -> Remaining;\nlog_server_events([Line | Rest]) ->\n    ?event(genesis_wasm_server, {server_logged, Line}),\n    log_server_events(Rest)\n```\n\n## Configuration Options\n\n### Server Settings\n- **genesis_wasm_port**: Server port (default: 6363)\n- **genesis_wasm_db_dir**: Database directory (default: \"cache-mainnet/genesis-wasm\")\n- **genesis_wasm_checkpoints_dir**: Checkpoints directory (default: \"cache-mainnet/genesis-wasm/checkpoints\")\n- **genesis_wasm_log_level**: Log level (default: \"error\")\n- **priv_key_location**: Wallet key file location\n\n### Feature Flags\n- **genesis_wasm**: Must be compiled with genesis-wasm support\n- **DISABLE_PROCESS_FILE_CHECKPOINT_CREATION**: Checkpoint creation control\n- **UNIT_MODE**: Set to \"hbu\" for HyperBEAM unit mode\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Server Management\n```erlang\n?event({ensure_started, genesis_wasm, self()})\n?event({genesis_wasm_booting, {pid, self()}})\n?event({genesis_wasm_port_opened, {port, Port}})\n?event({genesis_wasm_starting, {pid, PID}})\n?event({genesis_wasm_started, {pid, PID}})\n```\n\n2. Status Checking\n```erlang\n?event(genesis_wasm_pinging_server)\n?event({genesis_wasm_get_info_endpoint, {worker, self()}})\n?event({genesis_wasm_received_status, Status})\n?event({genesis_wasm_status_check, timeout})\n```\n\n3. Server Output\n```erlang\n?event(genesis_wasm_server, {server_logged, Line})\n?event(genesis_wasm_stopped, {pid, self()})\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_features: Feature flag checking\n- hb_name: Process registration\n- hb_http: Server status checking\n- hb_ao: Message resolution\n- hb_opts: Configuration management\n\n### Usage Context\n- Called by dev_process for legacy AO execution\n- Integrates with delegated-compute device\n- Manages genesis-wasm server process\n- Handles legacy process migration\n"},"devices/Process & Execution/modules/dev_lua.md":{"content":"# Module: dev_lua\n\n## Basic Information\n- **Source File:** dev_lua.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Lua script execution device with sandboxing capabilities\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([info/1, init/3, snapshot/3, normalize/3]).\n```\n\n### Include Files\n```erlang\n-include(\"include/hb.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n```\n\n## Sandboxing Configuration\n\n### Default Sandbox Functions\n```erlang\n-define(DEFAULT_SANDBOX, [\n    {['_G', io], <<\"sandboxed\">>},\n    {['_G', file], <<\"sandboxed\">>},\n    {['_G', os, execute], <<\"sandboxed\">>},\n    {['_G', os, exit], <<\"sandboxed\">>},\n    {['_G', os, getenv], <<\"sandboxed\">>},\n    {['_G', os, remove], <<\"sandboxed\">>},\n    {['_G', os, rename], <<\"sandboxed\">>},\n    {['_G', os, tmpname], <<\"sandboxed\">>},\n    {['_G', package], <<\"sandboxed\">>},\n    {['_G', loadfile], <<\"sandboxed\">>},\n    {['_G', require], <<\"sandboxed\">>},\n    {['_G', dofile], <<\"sandboxed\">>},\n    {['_G', load], <<\"sandboxed\">>},\n    {['_G', loadfile], <<\"sandboxed\">>},\n    {['_G', loadstring], <<\"sandboxed\">>}\n]).\n```\n\n## Implementation Details\n\n### 1. Script Loading & Initialization\n\n```erlang\ninit(Base, Req, Opts) ->\n    case find_script(Base, Opts) of\n        {ok, Script} ->\n            % Initialize Lua state\n            State0 = luerl:init(),\n            {ok, _, State1} = luerl:do_dec(Script, State0),\n            \n            % Apply sandboxing if configured\n            State2 = case hb_ao:get(<<\"sandbox\">>, Base, false, Opts) of\n                false -> State1;\n                true -> sandbox(State1, ?DEFAULT_SANDBOX, Opts);\n                Spec -> sandbox(State1, Spec, Opts)\n            end,\n            \n            % Add AO Core resolver\n            {ok, State3} = add_ao_core_resolver(Base, State2, Opts),\n            \n            % Return initialized state\n            {ok, hb_private:set(Base, <<\"state\">>, State3, Opts)};\n            \n        Error -> Error\n    end\n```\n\n### 2. Function Resolution\n\n```erlang\ncompute(Key, RawBase, Req, Opts) ->\n    % Initialize if needed\n    {ok, Base} = ensure_initialized(RawBase, Req, Opts),\n    State = hb_private:get(<<\"state\">>, Base, Opts),\n    \n    % Get function and parameters\n    Function = hb_ao:get_first([\n        {Req, <<\"body/function\">>},\n        {Req, <<\"function\">>},\n        {Base, <<\"function\">>}\n    ], Key, Opts),\n    \n    Params = hb_ao:get_first([\n        {Req, <<\"body/parameters\">>},\n        {Req, <<\"parameters\">>},\n        {Base, <<\"parameters\">>}\n    ], [Base, Req, #{}], Opts),\n    \n    % Execute function\n    case luerl:call_function_dec([Function], encode(Params), State) of\n        {ok, [LuaResult], NewState} when is_map(LuaResult) ->\n            Result = decode(LuaResult),\n            {ok, Result#{\n                <<\"priv\">> => #{<<\"state\">> => NewState}\n            }};\n        {ok, [LuaResult], _} ->\n            {ok, LuaResult};\n        {lua_error, Error, Details} ->\n            {error, #{\n                <<\"status\">> => 500,\n                <<\"body\">> => Error,\n                <<\"details\">> => Details\n            }}\n    end\n```\n\n### 3. State Management\n\n```erlang\n% Create snapshot\nsnapshot(Base, _Req, Opts) ->\n    case hb_private:get(<<\"state\">>, Base, Opts) of\n        not_found ->\n            {error, <<\"Cannot snapshot Lua state: state not initialized.\">>};\n        State ->\n            {ok, #{\n                <<\"body\">> => term_to_binary(luerl:externalize(State))\n            }}\n    end\n\n% Restore from snapshot\nnormalize(Base, _Req, Opts) ->\n    case hb_private:get(<<\"state\">>, Base, Opts) of\n        not_found ->\n            SerializedState = hb_ao:get(\n                [<<\"snapshot\">>] ++ DeviceKey ++ [<<\"body\">>],\n                {as, dev_message, Base},\n                Opts\n            ),\n            case SerializedState of\n                not_found -> throw({error, no_lua_state_snapshot_found});\n                State ->\n                    ExternalizedState = binary_to_term(State),\n                    InternalizedState = luerl:internalize(ExternalizedState),\n                    {ok, hb_private:set(Base, <<\"state\">>, \n                                      InternalizedState, Opts)}\n            end;\n        _ -> {ok, Base}\n    end\n```\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Initialization\n```erlang\n?event(debug_lua, lua_state_already_initialized)\n?event(debug_lua, initializing_lua_state)\n```\n\n2. Function Resolution\n```erlang\n?event(debug_lua, compute_called)\n?event(debug_lua, ensure_initialized_done)\n?event(debug_lua, function_found)\n?event(debug_lua, parameters_found)\n```\n\n3. Execution\n```erlang\n?event({calling_lua_func, {function, Function}, {args, Params}})\n?event(debug_lua, calling_lua_func)\n?event(debug_lua, got_lua_result)\n?event(debug_lua, decoded_result)\n```\n\n## Test Coverage\n\n### 1. Basic Operations\n```erlang\nsimple_invocation_test() ->\n    % Tests basic Lua function call\n    % Verifies result retrieval\n\nsandboxed_failure_test() ->\n    % Tests sandbox restrictions\n    % Verifies blocked operations\n```\n\n### 2. AO Core Integration\n```erlang\nao_core_sandbox_test() ->\n    % Tests device sandboxing\n    % Verifies allowed/blocked devices\n\nao_core_resolution_from_lua_test() ->\n    % Tests AO Core resolution from Lua\n    % Verifies result handling\n```\n\n### 3. Performance Tests\n```erlang\ndirect_benchmark_test() ->\n    % Tests execution performance\n    % Verifies >10 iterations in 3s\n\npure_lua_process_benchmark_test_() ->\n    % Tests process execution performance\n    % Measures execution time per message\n```\n\n### 4. Process Integration\n```erlang\npure_lua_process_test() ->\n    % Tests Lua process execution\n    % Verifies process state handling\n\ninvoke_aos_test() ->\n    % Tests AOS integration\n    % Verifies command execution\n\naos_authority_not_trusted_test() ->\n    % Tests authority validation\n    % Verifies untrusted message handling\n```\n\n## Integration Points\n\n### Direct Dependencies\n- luerl: Lua VM implementation\n- hb_ao: Message handling\n- hb_private: Private state management\n- hb_cache: Script caching\n- hb_message: Message operations\n\n### Usage Context\n- Called by dev_process for Lua execution\n- Integrates with AO Core resolution\n- Manages Lua state persistence\n- Provides sandboxed environment\n- Supports HTTP preprocessing\n"},"devices/Process & Execution/modules/dev_node_process.md":{"content":"# Module: dev_node_process\n\n## Basic Information\n- **Source File:** dev_node_process.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Node-specific singleton process management with local name registration\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([info/1]).\n```\n\n### Include Files\n```erlang\n-include(\"include/hb.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n```\n\n## Implementation Details\n\n### 1. Device Configuration\n\n```erlang\ninfo(_Opts) ->\n    #{\n        default => fun lookup/4,\n        excludes => [<<\"set\">>, <<\"keys\">>]\n    }\n```\n\n### 2. Process Lookup\n\n```erlang\nlookup(Name, _Base, Req, Opts) ->\n    % Try to find process in local registry\n    case hb_ao:resolve(\n        #{ <<\"device\">> => <<\"local-name@1.0\">> },\n        #{ <<\"path\">> => <<\"lookup\">>,\n           <<\"key\">> => Name,\n           <<\"load\">> => true },\n        Opts\n    ) of\n        {ok, ProcessID} ->\n            % Process found, load from cache\n            hb_cache:read(ProcessID, Opts);\n            \n        {error, not_found} ->\n            % Process not found, spawn if allowed\n            case hb_ao:get(<<\"spawn\">>, Req, true, Opts) of\n                true -> spawn_register(Name, Opts);\n                false -> {error, not_found}\n            end\n    end\n```\n\n### 3. Process Spawning\n\n```erlang\nspawn_register(Name, Opts) ->\n    % Look up process definition in node config\n    case hb_opts:get(node_processes, #{}, Opts) of\n        #{ Name := BaseDef } ->\n            % Create and sign process definition\n            Signed = hb_message:commit(\n                augment_definition(BaseDef, Opts),\n                Opts),\n            ID = hb_message:id(Signed, signed, Opts),\n            \n            % Schedule process execution\n            {ok, _} = hb_ao:resolve(\n                Signed,\n                #{\n                    <<\"path\">> => <<\"schedule\">>,\n                    <<\"method\">> => <<\"POST\">>,\n                    <<\"body\">> => Signed\n                },\n                Opts),\n            \n            % Register with local name service\n            case dev_local_name:direct_register(\n                #{ <<\"key\">> => Name,\n                   <<\"value\">> => ID },\n                Opts) of\n                {ok, _} -> {ok, Signed};\n                {error, Err} ->\n                    {error, #{\n                        <<\"status\">> => 500,\n                        <<\"body\">> => <<\"Failed to register process.\">>,\n                        <<\"details\">> => Err\n                    }}\n            end;\n            \n        _ -> {error, not_found}\n    end\n```\n\n### 4. Definition Augmentation\n\n```erlang\naugment_definition(BaseDef, Opts) ->\n    % Add node address to process definition\n    Address = hb_util:human_id(\n        ar_wallet:to_address(\n            hb_opts:get(priv_wallet, no_viable_wallet, Opts)\n        )\n    ),\n    hb_ao:set(BaseDef, #{\n        <<\"scheduler\">> => Address\n    })\n```\n\n## Process Definition Format\n\n### Node Configuration\n```erlang\n#{\n    node_processes => #{\n        ProcessName => #{\n            <<\"device\">> => <<\"process@1.0\">>,\n            <<\"execution-device\">> => ExecutionDevice,\n            <<\"scheduler-device\">> => <<\"scheduler@1.0\">>,\n            % Process-specific configuration...\n        }\n    }\n}\n```\n\n### Augmented Definition\n```erlang\n#{\n    % Original process definition fields...\n    <<\"scheduler\">> => NodeAddress\n}\n```\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Process Lookup\n```erlang\n?event(node_process, {lookup, {name, Name}})\n```\n\n2. Process Registration\n```erlang\n?event(node_process, {registering, {name, Name}, {base_def, BaseDef}})\n?event(node_process, {spawned, {name, Name}, {process, Signed}})\n?event(node_process, {initialized, {name, Name}, {assignment, Assignment}})\n?event(node_process, {registered, {name, Name}, {process_id, ID}})\n```\n\n## Test Coverage\n\n### 1. Basic Operations\n```erlang\nlookup_no_spawn_test() ->\n    % Tests lookup without spawning\n    % Verifies not_found handling\n\nlookup_spawn_test() ->\n    % Tests process spawning\n    % Verifies process persistence\n    % Checks process identity\n```\n\n### 2. Process Execution\n```erlang\nlookup_execute_test() ->\n    % Tests full process lifecycle:\n    % - Process spawning\n    % - Message scheduling\n    % - Result retrieval\n```\n\n### 3. Test Environment\n```erlang\ngenerate_test_opts() ->\n    % Creates test environment with:\n    % - Lua test script\n    % - Process definition\n    % - File system store\n    % - Test wallet\n```\n\n## Integration Points\n\n### Direct Dependencies\n- dev_local_name: Local process registration\n- hb_message: Message signing and ID generation\n- hb_ao: Message resolution\n- hb_cache: Process state storage\n- ar_wallet: Node address generation\n\n### Usage Context\n- Manages node-specific singleton processes\n- Integrates with local name service\n- Handles process persistence\n- Coordinates with scheduler\n\n### Process Lifecycle\n1. Definition Loading\n   - From node configuration\n   - With node address augmentation\n\n2. Process Creation\n   - Message signing\n   - State initialization\n   - Local registration\n\n3. Execution Management\n   - Scheduler integration\n   - State persistence\n   - Result handling\n\n## Key Features\n\n1. **Singleton Pattern**\n   - Node-specific processes\n   - Local name registration\n   - Cross-reboot persistence\n\n2. **Process Management**\n   - Automatic spawning\n   - Definition augmentation\n   - State persistence\n\n3. **Integration**\n   - Local name service\n   - Process scheduler\n   - Message system\n\n4. **Error Handling**\n   - Missing definitions\n   - Registration failures\n   - Lookup failures\n"},"devices/Process & Execution/modules/dev_process_cache.md":{"content":"# Module: dev_process_cache\n\n## Basic Information\n- **Source File:** dev_process_cache.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Wrapper around hb_cache providing convenient interface for process result caching\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([latest/2, latest/3, latest/4]).  % Get latest process state\n-export([read/2, read/3]).                % Read process state\n-export([write/4]).                       % Write process state\n```\n\n### Include Files\n```erlang\n-include_lib(\"eunit/include/eunit.hrl\").\n-include(\"include/hb.hrl\").\n```\n\n## Implementation Details\n\n### 1. Process Result Reading\n\n```erlang\nread(ProcID, Opts) ->\n    hb_util:ok(latest(ProcID, Opts)).\n\nread(ProcID, SlotRef, Opts) ->\n    ?event({reading_computed_result, ProcID, SlotRef}),\n    Path = path(ProcID, SlotRef, Opts),\n    hb_cache:read(Path, Opts).\n```\n\nKey aspects:\n- Reads process state by slot number or message ID\n- Uses hb_cache for actual storage operations\n- Logs read operations with event system\n\n### 2. Process Result Writing\n\n```erlang\nwrite(ProcID, Slot, Msg, Opts) ->\n    % Write to cache root\n    {ok, Root} = hb_cache:write(Msg, Opts),\n    \n    % Link by slot number\n    SlotNumPath = path(ProcID, Slot, Opts),\n    hb_cache:link(Root, SlotNumPath, Opts),\n    \n    % Link by message ID\n    MsgIDPath = path(\n        ProcID,\n        ID = hb_util:human_id(hb_ao:get(id, Msg)),\n        Opts\n    ),\n    ?event({linking_id, {proc_id, ProcID}, {slot, Slot}, {id, ID}, {path, MsgIDPath}}),\n    hb_cache:link(Root, MsgIDPath, Opts),\n    \n    {ok, SlotNumPath}.\n```\n\nKey aspects:\n- Writes process state to cache\n- Creates links by both slot number and message ID\n- Enables retrieval by either reference\n- Logs linking operations\n\n### 3. Latest State Retrieval\n\n```erlang\nlatest(ProcID, Opts) -> \n    latest(ProcID, [], Opts).\n\nlatest(ProcID, RequiredPath, Opts) ->\n    latest(ProcID, RequiredPath, undefined, Opts).\n\nlatest(ProcID, RawRequiredPath, Limit, Opts) ->\n    % Convert path to binary keys\n    RequiredPath = case RawRequiredPath of\n        undefined -> [];\n        [] -> [];\n        _ -> hb_path:term_to_path_parts(RawRequiredPath, Opts)\n    end,\n    \n    % Get all slots\n    Path = path(ProcID, slot_root, Opts),\n    AllSlots = hb_cache:list_numbered(Path, Opts),\n    \n    % Apply limit if specified\n    CappedSlots = case Limit of\n        undefined -> AllSlots;\n        _ -> lists:filter(fun(Slot) -> Slot =< Limit end, AllSlots)\n    end,\n    \n    % Find highest slot with required path\n    case first_with_path(ProcID, RequiredPath, \n                        lists:reverse(lists:sort(CappedSlots)), \n                        Opts) of\n        not_found -> not_found;\n        SlotNum ->\n            {ok, Msg} = hb_cache:read(path(ProcID, SlotNum, Opts), Opts),\n            {ok, SlotNum, Msg}\n    end.\n```\n\nKey aspects:\n- Finds latest process state optionally filtered by:\n  * Required path presence\n  * Maximum slot number\n- Returns both slot number and state\n- Handles path conversion and validation\n\n### 4. Path Management\n\n```erlang\npath(ProcID, Ref, Opts) ->\n    path(ProcID, Ref, [], Opts).\n\npath(ProcID, Ref, PathSuffix, Opts) ->\n    Store = hb_opts:get(store, no_viable_store, Opts),\n    hb_store:path(Store, [\n        <<\"computed\">>,\n        hb_util:human_id(ProcID)\n    ] ++ case Ref of\n        Int when is_integer(Int) -> \n            [\"slot\", integer_to_binary(Int)];\n        root -> [];\n        slot_root -> [\"slot\"];\n        _ -> [Ref]\n    end ++ PathSuffix).\n```\n\nKey aspects:\n- Constructs cache paths for process states\n- Handles different reference types:\n  * Integer slots\n  * Root references\n  * Message IDs\n- Supports path suffixes for nested data\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Read Operations\n```erlang\n?event({reading_computed_result, ProcID, SlotRef})\n```\n\n2. Write Operations\n```erlang\n?event({linking_id, {proc_id, ProcID}, {slot, Slot}, {id, ID}, {path, MsgIDPath}})\n```\n\n3. Latest State Lookup\n```erlang\n?event({latest_called, {proc_id, ProcID}, {required_path, RawRequiredPath}, {limit, Limit}})\n?event({required_path_converted, {proc_id, ProcID}, {required_path, RequiredPath}})\n?event({all_slots, {proc_id, ProcID}, {slots, AllSlots}})\n```\n\n## Test Coverage\n\nThe module includes comprehensive tests:\n\n1. **Write and Read Process Outputs**\n```erlang\ntest_write_and_read_output(Opts) ->\n    % Tests:\n    % - Writing signed and unsigned outputs\n    % - Reading by slot number\n    % - Reading by message ID\n    % - Verifying message matching\n```\n\n2. **Latest Output Finding**\n```erlang\nfind_latest_outputs(Opts) ->\n    % Tests:\n    % - Finding latest slot without qualifiers\n    % - Finding latest slot with required path\n    % - Finding latest slot with deep path\n    % - Finding latest slot with limit\n```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_cache: Underlying cache operations\n- hb_store: Storage path management\n- hb_path: Path manipulation\n- hb_util: Utility functions\n- hb_ao: Message access\n- hb_message: Message operations\n\n### Usage Context\n- Called by dev_process for state caching\n- Integrates with hb_cache system\n- Supports process state persistence\n- Enables state retrieval by slot or ID\n"},"devices/Process & Execution/modules/dev_process_worker.md":{"content":"# Module: dev_process_worker\n\n## Basic Information\n- **Source File:** dev_process_worker.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Long-lived process worker maintaining state between calls\n- **Behavior:** Implements hb_ao interface for process computation\n\n## Interface\n\n### Public API\n```erlang\n% Core functionality\n-export([server/3, stop/1]).\n\n% Process grouping and coordination\n-export([group/3, await/5, notify_compute/4]).\n```\n\n### Include Files\n```erlang\n-include_lib(\"include/hb.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n```\n\n## Runtime Options\n\n1. **Process Workers Control**\n   - Option: process_workers\n   - Default: false\n   - Purpose: Enables/disables worker process grouping\n\n2. **Worker Timeout**\n   - Option: process_worker_max_idle\n   - Default: 300_000 (5 minutes)\n   - Purpose: Maximum idle time before state snapshot\n\n3. **Server Options**\n   ```erlang\n   ServerOpts = #{\n       await_inprogress => false,\n       spawn_worker => false,\n       process_workers => false\n   }\n   ```\n\n## Implementation Details\n\n### 1. Process Grouping\n\n```erlang\ngroup(Msg1, Msg2, Opts) ->\n    case hb_opts:get(process_workers, false, Opts) of\n        false ->\n            hb_persistent:default_grouper(Msg1, Msg2, Opts);\n        true ->\n            case Msg2 of\n                undefined ->\n                    hb_persistent:default_grouper(Msg1, undefined, Opts);\n                _ ->\n                    case hb_path:matches(<<\"compute\">>, hb_path:hd(Msg2, Opts)) of\n                        true ->\n                            process_to_group_name(Msg1, Opts);\n                        _ ->\n                            hb_persistent:default_grouper(Msg1, Msg2, Opts)\n                    end\n            end\n    end\n```\n\nKey aspects:\n- Groups by process ID for compute operations\n- Falls back to default grouping for other operations\n- Only active when process_workers=true\n\n### 2. Worker Server\n\n```erlang\nserver(GroupName, Msg1, Opts) ->\n    ServerOpts = #{\n        await_inprogress => false,\n        spawn_worker => false,\n        process_workers => false\n    },\n    Timeout = hb_opts:get(process_worker_max_idle, 300_000, Opts),\n    receive\n        {resolve, Listener, GroupName, Msg2, ListenerOpts} ->\n            TargetSlot = hb_ao:get(<<\"slot\">>, Msg2, Opts),\n            Res = hb_ao:resolve(Msg1, #{\n                <<\"path\">> => <<\"compute\">>,\n                <<\"slot\">> => TargetSlot\n            }, maps:merge(ListenerOpts, ServerOpts)),\n            send_notification(Listener, GroupName, TargetSlot, Res),\n            server(GroupName, case Res of\n                {ok, Msg3} -> Msg3;\n                _ -> Msg1\n            end, Opts);\n        stop ->\n            exit(normal)\n    after Timeout ->\n        hb_ao:resolve(Msg1, <<\"snapshot\">>,\n            ServerOpts#{ <<\"cache-control\">> => [<<\"store\">>] }),\n        {ok, Msg1}\n    end\n```\n\nKey behaviors:\n- Maintains state between computations\n- Auto-snapshots on timeout\n- Handles resolution requests\n- Propagates computation results\n\n### 3. Result Notification\n\n```erlang\nnotify_compute(GroupName, SlotToNotify, Msg3, Opts) ->\n    notify_compute(GroupName, SlotToNotify, Msg3, Opts, 0).\nnotify_compute(GroupName, SlotToNotify, Msg3, Opts, Count) ->\n    receive\n        {resolve, Listener, GroupName, #{ <<\"slot\">> := SlotToNotify }, _} ->\n            send_notification(Listener, GroupName, SlotToNotify, Msg3),\n            notify_compute(GroupName, SlotToNotify, Msg3, Opts, Count + 1);\n        {resolve, Listener, GroupName, Msg, _}\n                when is_map(Msg) andalso not is_map_key(<<\"slot\">>, Msg) ->\n            send_notification(Listener, GroupName, SlotToNotify, Msg3),\n            notify_compute(GroupName, SlotToNotify, Msg3, Opts, Count + 1)\n    after 0 ->\n        ok\n    end\n```\n\nKey aspects:\n- Notifies all waiting listeners\n- Handles both slot-specific and general requests\n- Tracks notification count\n- Non-blocking (0 timeout)\n\n## Event Logging\n\nThe module logs events at key points:\n\n1. Worker Lifecycle\n   ```erlang\n   ?event(worker, {waiting_for_req, {group, GroupName}})\n   ?event(worker, {work_received, {group, GroupName}, {slot, TargetSlot}})\n   ?event(worker, {work_done, {group, GroupName}, {req, Msg2}, {res, Res}})\n   ?event(worker, {stopping, {group, GroupName}, {msg1, Msg1}})\n   ```\n\n2. Computation Flow\n   ```erlang\n   ?event({awaiting_compute, {worker, Worker}, {group, GroupName}})\n   ?event(compute_debug, {notified_of_resolution, {target, TargetSlot}})\n   ?event(worker_short, {finished_notifying, {listeners, Count}})\n   ```\n\n## Test Coverage\n\nThe module includes tests for:\n\n1. **Info Interface**\n   ```erlang\n   info_test() ->\n       M1 = dev_process:test_wasm_process(...),\n       Res = hb_ao:info(M1, #{}),\n       ?assertEqual(fun dev_process_worker:group/3, maps:get(grouper, Res)).\n   ```\n\n2. **Grouping Logic**\n   ```erlang\n   grouper_test() ->\n       M1 = dev_process:test_aos_process(),\n       M2 = #{ <<\"path\">> => <<\"compute\">>, <<\"v\">> => 1 },\n       M3 = #{ <<\"path\">> => <<\"compute\">>, <<\"v\">> => 2 },\n       M4 = #{ <<\"path\">> => <<\"not-compute\">>, <<\"v\">> => 3 },\n       % Verifies grouping behavior for compute vs non-compute paths\n   ```\n\n## Integration Points\n\n### Direct Dependencies\n- hb_persistent: Default grouping behavior\n- hb_path: Path matching and handling\n- hb_ao: Message resolution\n- hb_opts: Configuration management\n- dev_process: Process key management\n\n### Usage Context\n- Called by dev_process for worker management\n- Integrates with hb_ao resolution system\n- Coordinates with process cache system\n- Manages long-lived worker processes\n"}}