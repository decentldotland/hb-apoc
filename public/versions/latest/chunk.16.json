{"devices/scheduling_control/modules/dev_scheduler_server.md":{"content":"# Module: dev_scheduler_server\n\n## Basic Information\n- **Source File:** dev_scheduler_server.erl\n- **Module Type:** Device Scheduling Control\n- **Purpose:** Long-lived server that manages message scheduling for processes, acting as a deliberate bottleneck to prevent slot assignment conflicts\n\n## Interface\n\n### Public API\n```erlang\n% Server management\n-export([start/2, stop/1]).\n% Scheduling operations\n-export([schedule/2, info/1]).\n```\n\n## Core Functionality\n\n### 1. Server State Structure\n```erlang\n#{\n    id => ProcessID,           % Process identifier\n    current => CurrentSlot,    % Current slot number\n    wallet => WalletKey,       % Server wallet for signing\n    hash_chain => HashChain,   % Assignment hash chain\n    opts => Options           % Configuration options\n}\n```\n\n### 2. Server Initialization\n\n```erlang\nstart(ProcID, Opts) ->\n    spawn_link(fun() ->\n        % Verify scheduling is enabled\n        case hb_opts:get(scheduling_mode, disabled, Opts) of\n            disabled -> throw({scheduling_disabled_on_node, ProcID});\n            _ -> ok\n        end,\n        \n        % Register server process\n        hb_name:register({dev_scheduler, ProcID}),\n        \n        % Initialize state from cache or start fresh\n        {CurrentSlot, HashChain} =\n            case dev_scheduler_cache:latest(ProcID, Opts) of\n                not_found -> {-1, <<>>};\n                {Slot, Chain} -> {Slot, Chain}\n            end,\n            \n        % Start server loop\n        server(#{\n            id => ProcID,\n            current => CurrentSlot,\n            wallet => hb_opts:get(priv_wallet, hb:wallet(), Opts),\n            hash_chain => HashChain,\n            opts => Opts\n        })\n    end)\n```\n\n### 3. Message Assignment\n\n```erlang\ndo_assign(State, Message, ReplyPID) ->\n    % Generate next hash chain element\n    HashChain = next_hashchain(maps:get(hash_chain, State), Message),\n    NextSlot = maps:get(current, State) + 1,\n    \n    % Create assignment\n    AssignFun = fun() ->\n        % Get timestamp and block info\n        {Timestamp, Height, Hash} = ar_timestamp:get(),\n        \n        % Create and sign assignment\n        Assignment = hb_message:commit(#{\n            <<\"path\">> => get_path(Message),\n            <<\"data-protocol\">> => <<\"ao\">>,\n            <<\"variant\">> => <<\"ao.N.1\">>,\n            <<\"process\">> => ProcessID,\n            <<\"slot\">> => NextSlot,\n            <<\"block-height\">> => Height,\n            <<\"block-hash\">> => Hash,\n            <<\"timestamp\">> => erlang:system_time(millisecond),\n            <<\"hash-chain\">> => HashChain,\n            <<\"body\">> => Message\n        }, Wallet),\n        \n        % Store and notify based on mode\n        maybe_inform_recipient(aggressive, ReplyPID, Message, Assignment, State),\n        ok = dev_scheduler_cache:write(Assignment, Opts),\n        maybe_inform_recipient(local_confirmation, ReplyPID, Message, Assignment, State),\n        hb_client:upload(Assignment, Opts),\n        maybe_inform_recipient(remote_confirmation, ReplyPID, Message, Assignment, State)\n    end,\n    \n    % Execute based on scheduling mode\n    case hb_opts:get(scheduling_mode, sync, maps:get(opts, State)) of\n        aggressive -> spawn(AssignFun);\n        _ -> AssignFun()\n    end,\n    \n    % Update state\n    State#{\n        current := NextSlot,\n        hash_chain := HashChain\n    }\n```\n\n## Implementation Details\n\n### 1. Hash Chain Management\n\n```erlang\nnext_hashchain(HashChain, Message) ->\n    ID = hb_message:id(Message, all),\n    crypto:hash(sha256, <<HashChain/binary, ID/binary>>)\n```\n\nThe hash chain links assignments together to maintain order integrity:\n- Each assignment includes the hash of the previous assignment\n- Message IDs are incorporated into the chain\n- SHA-256 is used for hashing\n\n### 2. Scheduling Modes\n\nThree confirmation modes are supported:\n\n1. **Aggressive**\n   - Immediate response\n   - Async storage and upload\n   - Fastest but least reliable\n\n2. **Local Confirmation**\n   - Wait for local storage\n   - Async upload\n   - Balance of speed and reliability\n\n3. **Remote Confirmation**\n   - Wait for local storage\n   - Wait for upload confirmation\n   - Slowest but most reliable\n\n### 3. Error Handling\n\n```erlang\nassign(State, Message, ReplyPID) ->\n    try\n        do_assign(State, Message, ReplyPID)\n    catch\n        _Class:Reason:Stack ->\n            ?event({error_scheduling, Reason, Stack}),\n            State\n    end\n```\n\n## Event Logging\n\n### 1. Server Lifecycle\n```erlang\n?event(scheduling, {starting_scheduling_server, {proc_id, ProcID}})\n?event({starting_new_schedule, {proc_id, ProcID}})\n?event({continuing_schedule, {proc_id, ProcID}, {current_slot, Slot}})\n```\n\n### 2. Assignment Operations\n```erlang\n?event(scheduling, {assigned, {proc_id, ProcID}, {slot, Slot}, {assignment, ID}})\n?event(starting_message_write)\n?event(writes_complete)\n?event(uploading_assignment)\n?event(uploads_complete)\n```\n\n### 3. Error Handling\n```erlang\n?event({error_scheduling, Reason, Stack})\n?event({scheduling_mode, Mode})\n```\n\n## Testing Coverage\n\n### 1. Basic Operations\n```erlang\nnew_proc_test_() ->\n    % Tests:\n    % - Server initialization\n    % - Message scheduling\n    % - Slot progression\n    % - State maintenance\n```\n\n### 2. Performance Testing\n```erlang\nbenchmark_test() ->\n    % Tests:\n    % - Scheduling throughput\n    % - State consistency\n    % - Resource usage\n```\n\n## Integration Points\n\n### Direct Dependencies\n- dev_scheduler_cache: Assignment storage\n- dev_scheduler_registry: Server registration\n- hb_message: Message operations\n- hb_client: Assignment upload\n- ar_timestamp: Block information\n\n### Usage Context\n- Called by dev_scheduler\n- Integrates with scheduler cache\n- Manages assignment persistence\n- Coordinates with registry\n\n## Key Features\n\n### 1. Concurrency Control\n- Single server per process\n- Ordered slot assignment\n- Hash chain verification\n- State consistency\n\n### 2. Persistence\n- Local caching\n- Remote storage\n- State recovery\n- Assignment tracking\n\n### 3. Configuration\n- Multiple scheduling modes\n- Customizable timeouts\n- Flexible notification\n- Error recovery\n\n### 4. Performance\n- Async operations\n- Batched updates\n- State caching\n- Resource management\n\n## Best Practices\n\n### 1. Server Management\n- Initialize with proper options\n- Monitor server health\n- Handle errors gracefully\n- Clean up resources\n\n### 2. Assignment Handling\n- Verify message integrity\n- Maintain hash chain\n- Confirm persistence\n- Track slot progression\n\n### 3. Integration\n- Check scheduling mode\n- Handle timeouts\n- Verify responses\n- Monitor performance\n"},"devices/scheduling_control/modules/dev_scheduler.md":{"content":"# Module: dev_scheduler\n\n## Basic Information\n- **Source File:** dev_scheduler.erl\n- **Module Type:** Device Core Processing\n- **Purpose:** Implements AO process scheduling with support for local and remote execution\n\n## Interface\n\n### Public API\n```erlang\n% Core operations\n-export([info/0]).\n% Local scheduling\n-export([schedule/3, router/4, register/3]).\n% CU-flow operations\n-export([slot/3, status/3, next/3]).\n% System operations\n-export([start/0, checkpoint/1]).\n```\n\n### Constants\n```erlang\n% Maximum assignments per query\n-define(MAX_ASSIGNMENT_QUERY_LEN, 1000).\n% Lookahead worker timeout\n-define(LOOKAHEAD_TIMEOUT, 200).\n```\n\n## Core Functionality\n\n### 1. Process Message Format\n```erlang\n#{\n    <<\"device\">> => <<\"scheduler@1.0\">>,\n    <<\"device-stack\">> => [<<\"Cron@1.0\">>, <<\"WASM-64@1.0\">>, <<\"PODA@1.0\">>],\n    <<\"image\">> => <<\"wasm-image-id\">>,\n    <<\"type\">> => <<\"Process\">>,\n    <<\"scheduler-location\">> => Address,\n    <<\"test-random-seed\">> => RandomSeed\n}\n```\n\n### 2. Scheduling Operations\n\n#### Schedule Message\n```erlang\nschedule(Msg1, Msg2, Opts) ->\n    case hb_ao:get(<<\"method\">>, Msg2, <<\"GET\">>, Opts) of\n        <<\"POST\">> -> post_schedule(Msg1, Msg2, Opts);\n        <<\"GET\">> -> get_schedule(Msg1, Msg2, Opts)\n    end\n```\n\n#### Get Current Slot\n```erlang\nslot(M1, M2, Opts) ->\n    ProcID = find_target_id(M1, M2, Opts),\n    case find_server(ProcID, M1, Opts) of\n        {local, PID} -> \n            % Get local slot info\n            {Timestamp, Hash, Height} = ar_timestamp:get(),\n            #{ current := CurrentSlot } = dev_scheduler_server:info(PID),\n            {ok, #{\n                <<\"process\">> => ProcID,\n                <<\"current\">> => CurrentSlot,\n                <<\"timestamp\">> => Timestamp,\n                <<\"block-height\">> => Height,\n                <<\"block-hash\">> => Hash\n            }};\n        {redirect, Redirect} -> \n            % Handle remote slot\n            remote_slot(ProcID, Redirect, Opts)\n    end\n```\n\n### 3. Server Management\n\n#### Server Location\n```erlang\nregister(_Msg1, Req, Opts) ->\n    % Validate operator signature\n    Signers = hb_message:signers(OnlyCommitted),\n    Operator = hb_util:human_id(\n        ar_wallet:to_address(\n            hb_opts:get(priv_wallet, hb:wallet(), Opts)\n        )\n    ),\n    \n    % Create scheduler location\n    NewSchedulerLocation = #{\n        <<\"data-protocol\">> => <<\"ao\">>,\n        <<\"variant\">> => <<\"ao.N.1\">>,\n        <<\"type\">> => <<\"scheduler-location\">>,\n        <<\"url\">> => URL,\n        <<\"nonce\">> => NewNonce,\n        <<\"time-to-live\">> => TimeToLive,\n        <<\"codec-device\">> => Codec\n    }\n```\n\n## Implementation Details\n\n### 1. Local Scheduling\n\n#### Assignment Management\n```erlang\nget_local_assignments(ProcID, From, To, Opts) ->\n    ComputedTo =\n        case (RequestedTo - From) > ?MAX_ASSIGNMENT_QUERY_LEN of\n            true -> From + ?MAX_ASSIGNMENT_QUERY_LEN;\n            false -> RequestedTo\n        end,\n    {\n        read_local_assignments(ProcID, From, ComputedTo, Opts),\n        ComputedTo < RequestedTo\n    }\n```\n\n#### Cache Integration\n```erlang\ncache_remote_schedule(Schedule, Opts) ->\n    Cacher = fun() ->\n        Assignments = hb_ao:get(<<\"assignments\">>, Schedule, Opts),\n        lists:foreach(\n            fun(Assignment) ->\n                dev_scheduler_cache:write(Assignment, Opts)\n            end,\n            AssignmentList\n        )\n    end,\n    case hb_opts:get(scheduler_async_remote_cache, true, Opts) of\n        true -> spawn(Cacher);\n        false -> Cacher()\n    end\n```\n\n### 2. Remote Scheduling\n\n#### Remote Slot Access\n```erlang\nremote_slot(<<\"ao.N.1\">>, ProcID, Node, Opts) ->\n    % Mainnet AO-Core scheduler\n    hb_http:get(Node, <<ProcID/binary, \"/slot\">>, Opts);\n\nremote_slot(<<\"ao.TN.1\">>, ProcID, Node, Opts) ->\n    % Testnet AO-Core scheduler\n    Path = << ProcID/binary, \"/latest?proc-id=\", ProcID/binary>>,\n    case hb_http:get(Node, Path, Opts#{ http_client => httpc }) of\n        {ok, Res} ->\n            % Convert response to standard format\n            Body = hb_ao:get(<<\"body\">>, Res, Opts),\n            JSON = hb_json:decode(Body),\n            A = dev_scheduler_formats:aos2_to_assignment(JSON, Opts),\n            {ok, #{\n                <<\"process\">> => ProcID,\n                <<\"current\">> => maps:get(<<\"slot\">>, A),\n                <<\"timestamp\">> => maps:get(<<\"timestamp\">>, A),\n                <<\"block-height\">> => maps:get(<<\"block-height\">>, A)\n            }}\n    end\n```\n\n### 3. Performance Optimization\n\n#### Lookahead Workers\n```erlang\nspawn_lookahead_worker(ProcID, Slot, Opts) ->\n    Caller = self(),\n    spawn(fun() ->\n        case dev_scheduler_cache:read(ProcID, Slot, Opts) of\n            {ok, Assignment} ->\n                Caller ! {assignment, ProcID, Slot, Assignment};\n            not_found -> fail\n        end\n    end)\n```\n\n## Event Logging\n\n### 1. Server Management\n```erlang\n?event({ensure_started, genesis_wasm, self()})\n?event({registering_scheduler, {msg1, Msg1}, {req, Req}})\n?event({uploading_signed_scheduler_location, Signed})\n```\n\n### 2. Assignment Operations\n```erlang\n?event({scheduling_message, {proc_id, ProcID}})\n?event({got_assignments, length(Assignments), {more, More}})\n?event({assignments_bundle_outbound, {format, Format}, {res, Res}})\n```\n\n### 3. Remote Operations\n```erlang\n?event({getting_remote_slot, {proc_id, ProcID}, {redirect, Redirect}})\n?event({remote_schedule_result, {res, Res}})\n?event({legacy_scheduler_not_found, {url, URL}, {resp, Resp}})\n```\n\n## Testing Coverage\n\n### 1. Basic Operations\n```erlang\nstatus_test() ->\n    % Tests status retrieval\nregister_new_process_test() ->\n    % Tests process registration\nschedule_message_and_get_slot_test() ->\n    % Tests scheduling and slot retrieval\n```\n\n### 2. HTTP Integration\n```erlang\nhttp_post_schedule_test() ->\n    % Tests HTTP schedule posting\nhttp_get_schedule_test() ->\n    % Tests schedule retrieval via HTTP\nhttp_get_legacy_schedule_test() ->\n    % Tests legacy schedule compatibility\n```\n\n### 3. Performance Tests\n```erlang\nbenchmark_suite_test_() ->\n    % Tests different store configurations:\n    % - FS store with local confirmation\n    % - FS store with aggressive confirmation\n    % - RocksDB store with local confirmation\n    % - RocksDB store with aggressive confirmation\n    % - RocksDB with HTTP/3 and 100 workers\n```\n\n## Integration Points\n\n### Direct Dependencies\n- dev_scheduler_server: Server process management\n- dev_scheduler_cache: Assignment caching\n- dev_scheduler_formats: Format conversion\n- dev_scheduler_registry: Process registration\n- hb_http: Remote communication\n- hb_ao: Message handling\n- hb_cache: State persistence\n\n### Usage Context\n- Process scheduling coordination\n- Assignment management\n- Remote scheduler integration\n- Cache optimization\n- HTTP API support\n\n## Key Features\n\n### 1. Scheduling Capabilities\n- Local process scheduling\n- Remote scheduler integration\n- Legacy system compatibility\n- Assignment caching\n\n### 2. Performance Optimization\n- Lookahead workers\n- Async caching\n- Query size limits\n- Connection pooling\n\n### 3. Protocol Support\n- AO Core protocol\n- Legacy protocol adaptation\n- HTTP/2 and HTTP/3 support\n- Multiple store backends\n\n### 4. Security\n- Operator validation\n- Message signing\n- Access control\n- Resource limits\n\n## Best Practices\n\n### 1. Development\n- Use lookahead workers for performance\n- Implement proper error handling\n- Cache assignments effectively\n- Handle protocol variations\n\n### 2. Operations\n- Monitor assignment processing\n- Track cache effectiveness\n- Handle remote failures\n- Manage resource usage\n\n### 3. Integration\n- Validate scheduler locations\n- Handle protocol differences\n- Implement proper timeouts\n- Manage state consistently\n"},"devices/scheduling_control/observations.md":{"content":"# Scheduling Control System Observations\n\n## Architectural Patterns\n\n### 1. Layered Design\n- Clear separation between scheduling interfaces (dev_scheduler) and implementation details\n- Hierarchical organization from high-level API to low-level storage\n- Modular components with well-defined responsibilities\n- Clean integration points between layers\n\n### 2. Service Architecture\n```mermaid\ngraph TD\n    A[Scheduler API] --> B[Server]\n    B --> C[Cache]\n    B --> D[Registry]\n    B --> E[Formats]\n    C --> F[Storage]\n    D --> G[Process Groups]\n```\n\n### 3. State Management\n- Persistent state through caching system\n- In-memory state in scheduler servers\n- Registry for process tracking\n- Format conversion for compatibility\n\n## Design Patterns\n\n### 1. Server Pattern\n- Long-lived server processes for scheduling\n- Message-based communication\n- State encapsulation\n- Error handling and recovery\n\n### 2. Registry Pattern\n- Central registration point\n- Process lookup capabilities\n- Dynamic process creation\n- Resource cleanup\n\n### 3. Cache Pattern\n- Layered caching strategy\n- Symlink-based organization\n- Format normalization\n- Efficient retrieval\n\n## Key Mechanisms\n\n### 1. Scheduling Control\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant S as Scheduler\n    participant R as Registry\n    participant D as Database\n    \n    C->>S: Schedule Request\n    S->>R: Lookup/Create Server\n    S->>D: Store Assignment\n    D-->>S: Confirmation\n    S-->>C: Assignment ID\n```\n\n### 2. Task Management\n```mermaid\ngraph TD\n    A[Task Creation] --> B{Task Type}\n    B -->|One-Time| C[Execute Once]\n    B -->|Recurring| D[Schedule Loop]\n    B -->|Multi-Pass| E[Pass Control]\n    C --> F[Complete]\n    D --> G[Next Interval]\n    E --> H[Next Pass]\n```\n\n### 3. Format Handling\n```mermaid\ngraph LR\n    A[Internal Format] --> B[Format Converter]\n    B --> C[HTTP Bundle]\n    B --> D[AOS2 JSON]\n    B --> E[Legacy Format]\n```\n\n## Implementation Insights\n\n### 1. Concurrency Management\n- Deliberate bottlenecks for consistency\n- Process-based isolation\n- State synchronization\n- Resource coordination\n\n### 2. Error Handling\n- Comprehensive error detection\n- Recovery mechanisms\n- State preservation\n- Event logging\n\n### 3. Performance Considerations\n- Efficient caching\n- Optimized lookups\n- Minimal copying\n- Resource reuse\n\n## Integration Patterns\n\n### 1. System Integration\n- Core system compatibility\n- Message protocol adherence\n- Storage system integration\n- Event system usage\n\n### 2. External Integration\n- Format conversion support\n- Protocol compatibility\n- API consistency\n- Client adaptation\n\n### 3. Component Integration\n- Clear interfaces\n- Defined protocols\n- State sharing\n- Resource management\n\n## Optimization Opportunities\n\n### 1. Performance\n- Cache optimization\n- Lookup efficiency\n- Process reuse\n- Resource pooling\n\n### 2. Reliability\n- Enhanced error recovery\n- State consistency\n- Resource cleanup\n- Monitoring improvements\n\n### 3. Scalability\n- Distributed scheduling\n- Load balancing\n- Resource distribution\n- State partitioning\n\n## Best Practices\n\n### 1. Code Organization\n- Clear module boundaries\n- Consistent interfaces\n- Error handling patterns\n- Resource management\n\n### 2. State Management\n- Persistent storage\n- Memory efficiency\n- State consistency\n- Resource tracking\n\n### 3. Integration\n- Protocol adherence\n- Format compatibility\n- Error propagation\n- Resource coordination\n\n## Future Considerations\n\n### 1. Extensibility\n- New scheduling patterns\n- Additional formats\n- Enhanced protocols\n- Extended capabilities\n\n### 2. Maintenance\n- Code clarity\n- Documentation\n- Testing coverage\n- Monitoring capabilities\n\n### 3. Evolution\n- Feature additions\n- Performance improvements\n- Protocol updates\n- Integration enhancements\n\n## Critical Patterns\n\n### 1. Message Flow\n```mermaid\ngraph TD\n    A[Client Request] --> B[Format Conversion]\n    B --> C[Scheduling]\n    C --> D[Storage]\n    D --> E[Confirmation]\n    E --> F[Format Response]\n```\n\n### 2. State Flow\n```mermaid\ngraph TD\n    A[Memory State] --> B[Cache Layer]\n    B --> C[Persistent Storage]\n    C --> D[Format Conversion]\n    D --> E[Client Response]\n```\n\n### 3. Control Flow\n```mermaid\ngraph TD\n    A[Request] --> B[Validation]\n    B --> C[Processing]\n    C --> D[Storage]\n    D --> E[Response]\n```\n\n## Recommendations\n\n### 1. Short Term\n- Optimize cache usage\n- Enhance error handling\n- Improve monitoring\n- Extend testing\n\n### 2. Medium Term\n- Add scheduling patterns\n- Enhance format support\n- Improve scalability\n- Extend protocols\n\n### 3. Long Term\n- Distributed scheduling\n- Enhanced reliability\n- Protocol evolution\n- System expansion\n"},"devices/scheduling_control/OVERVIEW.md":{"content":"# Scheduling Control System Overview\n\n## System Architecture\n\nThe scheduling control system represents a sophisticated orchestration layer within HyperBEAM that manages the execution timing and sequencing of processes. This system is architected as a multi-layered solution that combines several specialized components working in harmony to provide reliable, efficient, and flexible scheduling capabilities.\n\n### Core Components\n```mermaid\ngraph TD\n    A[Scheduler Interface Layer] --> B[Server Management Layer]\n    B --> C[Cache & Storage Layer]\n    B --> D[Registry & Process Layer]\n    B --> E[Format & Protocol Layer]\n    \n    subgraph \"Interface Components\"\n        A\n    end\n    \n    subgraph \"Processing Components\"\n        B\n        D\n        E\n    end\n    \n    subgraph \"Persistence Components\"\n        C\n    end\n```\n\n## Component Interactions\n\n### 1. Primary Control Flow\n\nThe scheduling system operates through a carefully orchestrated sequence of interactions:\n\n1. **Initial Request Processing**\n   - Client requests arrive at the scheduler interface\n   - Requests are validated and normalized\n   - Control is passed to appropriate server instance\n\n2. **Server Management**\n   - Long-lived servers handle specific process scheduling\n   - State is maintained per process\n   - Assignments are tracked and managed\n\n3. **Storage Operations**\n   - Assignments are persisted to cache\n   - State is maintained across restarts\n   - Format conversions are applied as needed\n\n### 2. Data Flow Architecture\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Interface\n    participant Server\n    participant Cache\n    participant Storage\n    \n    Client->>Interface: Schedule Request\n    Interface->>Server: Process Request\n    Server->>Cache: Store Assignment\n    Cache->>Storage: Persist Data\n    Storage-->>Cache: Confirm Storage\n    Cache-->>Server: Confirm Cache\n    Server-->>Interface: Return Result\n    Interface-->>Client: Return Response\n```\n\n## Key Subsystems\n\n### 1. Scheduler Core (dev_scheduler)\nThe scheduler core provides the primary interface for scheduling operations:\n- Handles incoming scheduling requests\n- Manages scheduling policies\n- Coordinates with other components\n- Ensures consistent behavior\n\n### 2. Server Management (dev_scheduler_server)\nThe server management layer maintains process-specific scheduling servers:\n- One server per managed process\n- State isolation between processes\n- Consistent assignment handling\n- Resource management\n\n### 3. Cache System (dev_scheduler_cache)\nThe caching system provides efficient state management:\n- Hierarchical cache structure\n- Symlink-based organization\n- Format normalization\n- Quick retrieval\n\n### 4. Registry Service (dev_scheduler_registry)\nThe registry maintains process tracking and management:\n- Process registration\n- Server lookup\n- Dynamic creation\n- Resource cleanup\n\n### 5. Format Handling (dev_scheduler_formats)\nThe format system manages data representation:\n- Multiple format support\n- Conversion handling\n- Compatibility layers\n- Protocol adherence\n\n### 6. Task Management\nTask management is handled through specialized components:\n\n#### Cron System (dev_cron)\n- Scheduled task execution\n- Interval management\n- Task persistence\n- Execution tracking\n\n#### Multi-pass System (dev_multipass)\n- Sequential execution\n- Pass management\n- State tracking\n- Flow control\n\n## Implementation Details\n\n### 1. State Management\n\nThe system employs a sophisticated state management approach:\n\n```mermaid\ngraph TD\n    A[Runtime State] --> B[Memory Cache]\n    B --> C[Persistent Cache]\n    C --> D[Storage System]\n    \n    subgraph \"State Layers\"\n        A\n        B\n        C\n        D\n    end\n```\n\n### 2. Process Management\n\nProcess handling follows a structured approach:\n\n```mermaid\ngraph TD\n    A[Process Request] --> B{Exists?}\n    B -->|Yes| C[Load Server]\n    B -->|No| D[Create Server]\n    C --> E[Process]\n    D --> E\n    E --> F[Store Result]\n```\n\n### 3. Format Handling\n\nFormat management is implemented through:\n\n```mermaid\ngraph TD\n    A[Internal Format] --> B[Format Handler]\n    B --> C[HTTP Format]\n    B --> D[JSON Format]\n    B --> E[Legacy Format]\n```\n\n## System Integration\n\n### 1. Core System Integration\nThe scheduling system integrates with core HyperBEAM components:\n- Message system integration\n- Storage system usage\n- Process management\n- Event handling\n\n### 2. External Integration\nExternal system integration is handled through:\n- Protocol adaptation\n- Format conversion\n- State synchronization\n- Resource coordination\n\n### 3. Client Integration\nClient integration is facilitated by:\n- Clean interfaces\n- Format support\n- Error handling\n- State tracking\n\n## Operational Characteristics\n\n### 1. Performance Considerations\nThe system is optimized for:\n- Quick response times\n- Efficient state management\n- Resource utilization\n- Scalability support\n\n### 2. Reliability Features\nReliability is ensured through:\n- Error handling\n- State preservation\n- Resource management\n- Recovery mechanisms\n\n### 3. Maintenance Aspects\nThe system supports maintenance through:\n- Clear structure\n- Documented interfaces\n- Testing support\n- Monitoring capabilities\n\n## Future Directions\n\n### 1. Architectural Evolution\nFuture architectural improvements may include:\n- Enhanced distribution\n- Improved scalability\n- Better resilience\n- Extended capabilities\n\n### 2. Feature Enhancement\nPlanned feature enhancements include:\n- New scheduling patterns\n- Additional formats\n- Enhanced protocols\n- Improved monitoring\n\n### 3. Integration Expansion\nIntegration capabilities may be expanded through:\n- New protocols\n- Additional formats\n- Enhanced compatibility\n- Extended features\n\n## Best Practices\n\n### 1. Development Guidelines\nDevelopment should follow:\n- Clear interfaces\n- Consistent patterns\n- Error handling\n- Resource management\n\n### 2. Operational Guidelines\nOperations should maintain:\n- State consistency\n- Resource efficiency\n- Error handling\n- Performance monitoring\n\n### 3. Integration Guidelines\nIntegration should ensure:\n- Protocol compliance\n- Format compatibility\n- Error propagation\n- Resource coordination\n"},"devices/security_access/modules/dev_faff.md":{"content":"# Module: dev_faff\n\n## Basic Information\n- **Source File:** dev_faff.erl\n- **Module Type:** Pricing Policy Device\n- **Purpose:** Implements a 'friends and family' pricing policy that restricts node access to a predefined allow-list of addresses.\n\n## Core Functionality\n\n### 1. Access Control Architecture\n```mermaid\ngraph TD\n    A[Request] --> B[Type Check]\n    B --> C{Request Type}\n    C -->|Pre-request| D[Allow-list Check]\n    C -->|Post-request| E[Auto-approve]\n    \n    D --> F{Signer Check}\n    F -->|Allowed| G[Return Cost: 0]\n    F -->|Not Allowed| H[Return Cost: infinity]\n    \n    E --> I[Return Cost: 0]\n```\n\n### 2. Request Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant FAFF\n    participant Node\n    \n    Client->>FAFF: Request Access\n    FAFF->>FAFF: Check Request Type\n    \n    alt Pre-request\n        FAFF->>FAFF: Extract Signers\n        FAFF->>Node: Get Allow-list\n        \n        alt Signers in Allow-list\n            FAFF-->>Client: Cost: 0\n        else Signers not in Allow-list\n            FAFF-->>Client: Cost: infinity\n        end\n    else Post-request\n        FAFF-->>Client: Cost: 0\n    end\n```\n\n## Implementation Details\n\n### 1. Pricing API\n```erlang\n% Estimate cost based on request type and signer status\nestimate(_, Msg, NodeMsg) ->\n    case hb_ao:get(<<\"type\">>, Msg, <<\"pre\">>, NodeMsg) of\n        <<\"pre\">> ->\n            case is_admissible(Msg, NodeMsg) of\n                true -> {ok, 0};           % Allow-listed: free\n                false -> {ok, <<\"infinity\">>}  % Not allow-listed: blocked\n            end;\n        <<\"post\">> -> {ok, 0}  % Post-requests: always free\n    end.\n```\n\n### 2. Access Control\n```erlang\n% Verify all signers are in allow-list\nis_admissible(Msg, NodeMsg) ->\n    % Get configured allow-list\n    AllowList = hb_opts:get(faff_allow_list, [], NodeMsg),\n    \n    % Extract request signers\n    Req = hb_ao:get(<<\"request\">>, Msg, NodeMsg),\n    Signers = hb_message:signers(Req),\n    \n    % Check all signers are allowed\n    lists:all(\n        fun(Signer) -> lists:member(Signer, CacheWriters) end,\n        Signers\n    ).\n```\n\n### 3. Ledger API\n```erlang\n% No-op debit implementation\ndebit(_, Req, _NodeMsg) ->\n    ?event(payment, {debit, Req}),\n    {ok, true}.  % Always succeed since actual charging is disabled\n```\n\n## Key Features\n\n### 1. Access Control\n- **Allow-list Based**: Uses a configurable list of permitted addresses\n- **Multi-signer Support**: Validates all message signers\n- **Request Type Awareness**: Different handling for pre/post requests\n- **Zero Cost**: Free access for allowed addresses\n- **Complete Blocking**: Infinite cost for non-allowed addresses\n\n### 2. Pricing Model\n- **Binary Pricing**: Either free (0) or blocked (infinity)\n- **Pre/Post Differentiation**: Only pre-requests are checked\n- **No Actual Charging**: Debit operations are no-ops\n- **Simple Estimation**: Direct allow/block decisions\n- **Event Logging**: Tracks access attempts\n\n### 3. Integration\n- **P4 API Compatible**: Implements required pricing interface\n- **Ledger API Compatible**: Implements required ledger interface\n- **Node Configuration**: Uses node options for allow-list\n- **Message Handling**: Integrates with message system\n- **Event System**: Uses standard event logging\n\n## Usage Examples\n\n### 1. Node Configuration\n```erlang\n% Configure node with FAFF policy\nNodeOpts = #{\n    faff_allow_list => [\n        <<\"user1-address\">>,\n        <<\"user2-address\">>\n    ]\n},\nNode = hb_node:start(NodeOpts).\n```\n\n### 2. Request Processing\n```erlang\n% Process pre-request\nPreReq = #{\n    <<\"type\">> => <<\"pre\">>,\n    <<\"request\">> => SignedRequest\n},\n{ok, Cost} = dev_faff:estimate(none, PreReq, NodeOpts).\n\n% Process post-request\nPostReq = #{\n    <<\"type\">> => <<\"post\">>,\n    <<\"request\">> => SignedRequest\n},\n{ok, 0} = dev_faff:estimate(none, PostReq, NodeOpts).\n```\n\n### 3. Access Control\n```erlang\n% Check request admissibility\nMsg = #{\n    <<\"request\">> => SignedRequest\n},\nIsAllowed = dev_faff:is_admissible(Msg, NodeOpts).\n```\n\n## Error Handling\n\n### 1. Access Errors\n- Invalid signers\n- Missing allow-list\n- Malformed requests\n- Type mismatches\n- Configuration issues\n\n### 2. Pricing Errors\n- Invalid request types\n- Missing parameters\n- Format errors\n- State issues\n- System errors\n\n### 3. Integration Errors\n- API mismatches\n- Configuration problems\n- Message errors\n- State corruption\n- System failures\n\n## Future Considerations\n\n### 1. Access Control\n- Dynamic allow-lists\n- Role-based access\n- Temporary access\n- Group permissions\n- Access patterns\n\n### 2. Pricing Model\n- Tiered pricing\n- Usage tracking\n- Cost allocation\n- Payment integration\n- Billing support\n\n### 3. Integration\n- Better monitoring\n- Enhanced logging\n- Audit support\n- Analytics\n- Reporting tools\n"},"devices/security_access/modules/dev_p4.md":{"content":"# Module: dev_p4\n\n## Basic Information\n- **Source File:** dev_p4.erl\n- **Module Type:** Core Payment Ledger\n- **Purpose:** Orchestrates payment processing by coordinating pricing and ledger devices for transaction cost estimation and payment handling.\n\n## Core Functionality\n\n### 1. Payment Architecture\n```mermaid\ngraph TD\n    A[Request] --> B[Route Check]\n    B --> C{Chargeable?}\n    C -->|No| D[Free Pass]\n    C -->|Yes| E[Device Check]\n    \n    E --> F{Devices Configured?}\n    F -->|No| D\n    F -->|Yes| G[Price Estimation]\n    \n    G --> H{Estimate Result}\n    H -->|Error| I[Reject: Price Error]\n    H -->|Infinity| J[Reject: Not Serviced]\n    H -->|Price| K[Check Balance]\n    \n    K --> L{Balance Check}\n    L -->|Sufficient| M[Approve]\n    L -->|Insufficient| N[Reject: Low Funds]\n    L -->|Error| O[Reject: Ledger Error]\n```\n\n### 2. Processing Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant P4\n    participant PricingDevice\n    participant LedgerDevice\n    \n    Client->>P4: Request\n    P4->>P4: Check Route\n    \n    alt Non-chargeable Route\n        P4-->>Client: Approve\n    else Chargeable Route\n        P4->>PricingDevice: Estimate Cost\n        \n        alt Price Available\n            PricingDevice-->>P4: Return Price\n            P4->>LedgerDevice: Check Balance\n            \n            alt Sufficient Funds\n                LedgerDevice-->>P4: Approve\n                P4-->>Client: Process Request\n            else Insufficient Funds\n                LedgerDevice-->>P4: Reject\n                P4-->>Client: Return Error\n            end\n        else Price Error\n            PricingDevice-->>P4: Return Error\n            P4-->>Client: Return Error\n        end\n    end\n```\n\n## Implementation Details\n\n### 1. Request Preprocessing\n```erlang\n% Preprocess request to check pricing and balance\npreprocess(State, Raw, NodeMsg) ->\n    PricingDevice = hb_ao:get(<<\"pricing_device\">>, State, false, NodeMsg),\n    LedgerDevice = hb_ao:get(<<\"ledger_device\">>, State, false, NodeMsg),\n    Messages = hb_ao:get(<<\"body\">>, Raw, NodeMsg),\n    Request = hb_ao:get(<<\"request\">>, Raw, NodeMsg),\n    \n    case {is_chargable_req(Request, NodeMsg), \n          (PricingDevice =/= false) and (LedgerDevice =/= false)} of\n        {false, _} -> {ok, Messages};  % Non-chargeable route\n        {true, false} -> {ok, Messages};  % No devices configured\n        {true, true} ->\n            % Get price estimate and check balance\n            estimate_and_validate(PricingDevice, LedgerDevice, \n                                Request, Messages, NodeMsg)\n    end.\n```\n\n### 2. Response Postprocessing\n```erlang\n% Postprocess response to apply charges\npostprocess(State, RawResponse, NodeMsg) ->\n    PricingDevice = hb_ao:get(<<\"pricing_device\">>, State, false, NodeMsg),\n    LedgerDevice = hb_ao:get(<<\"ledger_device\">>, State, false, NodeMsg),\n    Response = hb_ao:get(<<\"body\">>, RawResponse, NodeMsg),\n    Request = hb_ao:get(<<\"request\">>, RawResponse, NodeMsg),\n    \n    case (PricingDevice =/= false) and (LedgerDevice =/= false) of\n        false -> {ok, Response};\n        true ->\n            % Calculate final price and debit account\n            calculate_and_debit(PricingDevice, LedgerDevice,\n                              Request, Response, NodeMsg)\n    end.\n```\n\n### 3. Route Management\n```erlang\n% Check if route is chargeable\nis_chargable_req(Req, NodeMsg) ->\n    NonChargableRoutes = hb_opts:get(\n        p4_non_chargable_routes,\n        ?DEFAULT_NON_CHARGABLE_ROUTES,\n        NodeMsg\n    ),\n    Matches = dev_router:match_routes(Req, NonChargableRoutes, NodeMsg),\n    case Matches of\n        no_matches -> true;\n        _ -> false\n    end.\n```\n\n## Key Features\n\n### 1. Payment Processing\n- **Device Orchestration**: Coordinates pricing and ledger devices\n- **Flexible Pricing**: Supports custom pricing strategies\n- **Balance Management**: Integrates with ledger systems\n- **Route Control**: Configurable non-chargeable routes\n- **Error Handling**: Comprehensive error states\n\n### 2. Device Integration\n- **Pricing Device API**: \n  - `/estimate` - Pre-request cost estimation\n  - `/price` - Post-request cost calculation\n- **Ledger Device API**:\n  - `/credit` - Process payments\n  - `/debit` - Handle charges\n  - `/balance` - Check balances\n\n### 3. Configuration\n- **Required Settings**:\n  - `p4_pricing_device`: Cost estimation device\n  - `p4_ledger_device`: Payment ledger device\n- **Optional Settings**:\n  - `p4_non_chargable_routes`: Free routes list\n  - Custom device configurations\n\n## Usage Examples\n\n### 1. Node Configuration\n```erlang\n% Configure node with p4 payment system\nNodeOpts = #{\n    preprocessor => #{\n        <<\"device\">> => <<\"p4@1.0\">>,\n        <<\"pricing_device\">> => <<\"simple-pay@1.0\">>,\n        <<\"ledger_device\">> => <<\"simple-pay@1.0\">>\n    },\n    p4_non_chargable_routes => [\n        #{ <<\"template\">> => <<\"/~p4@1.0/balance\">> },\n        #{ <<\"template\">> => <<\"/~meta@1.0/*\">> }\n    ]\n}.\n```\n\n### 2. Device Integration\n```erlang\n% Pricing device implementation\nestimate(Request, NodeMsg) ->\n    Messages = hb_ao:get(<<\"body\">>, Request, NodeMsg),\n    Price = calculate_price(Messages),\n    {ok, Price}.\n\n% Ledger device implementation\ndebit(Request, NodeMsg) ->\n    Amount = hb_ao:get(<<\"amount\">>, Request, NodeMsg),\n    update_balance(-Amount, Request, NodeMsg).\n```\n\n### 3. Request Processing\n```erlang\n% Process request with payment\nProcessReq = #{\n    <<\"path\">> => <<\"/service\">>,\n    <<\"body\">> => ServiceMessages\n},\n{ok, Response} = hb_http:post(Node, SignedReq, #{}).\n```\n\n## Error Handling\n\n### 1. Pricing Errors\n- Price calculation failures\n- Invalid request formats\n- Device communication issues\n- Configuration problems\n- Service restrictions\n\n### 2. Ledger Errors\n- Insufficient funds\n- Account access issues\n- Balance update failures\n- Transaction errors\n- State inconsistencies\n\n### 3. Processing Errors\n- Device unavailability\n- Route matching failures\n- Message validation issues\n- System errors\n- Integration problems\n\n## Future Considerations\n\n### 1. Payment System\n- Dynamic pricing models\n- Multi-currency support\n- Payment aggregation\n- Batch processing\n- Cost optimization\n\n### 2. Device Integration\n- Enhanced protocols\n- More device types\n- Better coordination\n- Failure recovery\n- Performance tuning\n\n### 3. Management\n- Advanced monitoring\n- Usage analytics\n- Audit capabilities\n- Admin interfaces\n- Reporting tools\n"},"devices/security_access/modules/dev_poda.md":{"content":"# Module: dev_poda\n\n## Basic Information\n- **Source File:** dev_poda.erl\n- **Module Type:** Consensus Device\n- **Purpose:** Implements a decentralized Proof of Authority (PoDA) consensus algorithm for validating and committing AO process messages.\n\n## Core Functionality\n\n### 1. Consensus Architecture\n```mermaid\ngraph TD\n    A[Message] --> B[Execution Flow]\n    A --> C[Commitment Flow]\n    \n    B --> D[Initialization]\n    B --> E[Pre-execution Validation]\n    \n    C --> F[Commitment Generation]\n    C --> G[Commitment Collection]\n    C --> H[Quorum Check]\n    \n    D --> I[Extract Options]\n    D --> J[Set Authorities]\n    D --> K[Set Quorum]\n    \n    E --> L[User Signature Check]\n    E --> M[Authority Validation]\n    E --> N[Commitment Verification]\n    \n    F --> O[Local Commitment]\n    G --> P[Remote Commitments]\n    H --> Q[Validation Count]\n```\n\n### 2. Message Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant PoDA\n    participant Authorities\n    participant Process\n    \n    Client->>PoDA: Submit Message\n    PoDA->>PoDA: Check User Signature\n    \n    alt User Signed\n        PoDA-->>Process: Allow Execution\n    else Authority Required\n        PoDA->>Authorities: Request Commitments\n        Authorities-->>PoDA: Return Commitments\n        \n        PoDA->>PoDA: Verify Quorum\n        \n        alt Quorum Met\n            PoDA-->>Process: Allow Execution\n        else Insufficient Commitments\n            PoDA-->>Client: Reject Message\n        end\n    end\n```\n\n## Implementation Details\n\n### 1. Initialization\n```erlang\n% Initialize PoDA device\ninit(State, Params) ->\n    % Extract authority addresses and quorum requirement\n    Authorities = extract_authorities(Params),\n    Quorum = extract_quorum(Params),\n    \n    % Configure device state\n    {ok, State, #{\n        authorities => Authorities,\n        quorum => Quorum\n    }}.\n```\n\n### 2. Message Validation\n```erlang\n% Validate incoming message\nexecute(Msg, State, Opts) ->\n    case is_user_signed(Msg) of\n        true -> {ok, State};  % User-signed messages pass through\n        false ->\n            % Validate authority commitments\n            case validate_commitments(Msg, Opts) of\n                true -> {ok, update_state(State, Msg)};\n                {false, Reason} -> {error, Reason}\n            end\n    end.\n```\n\n### 3. Commitment Management\n```erlang\n% Add commitments to results\npush(Item, State = #{results := Results}) ->\n    % Generate local commitment\n    LocalComm = generate_commitment(Item, State),\n    \n    % Collect remote commitments\n    RemoteComms = collect_commitments(Item, State),\n    \n    % Bundle all commitments\n    AllComms = [LocalComm | RemoteComms],\n    \n    % Update results with commitments\n    {ok, State#{results => add_commitments(Results, AllComms)}}.\n```\n\n## Key Features\n\n### 1. Authority Management\n- **Authority List**: Configurable list of trusted nodes\n- **Quorum Setting**: Required number of validations\n- **Dynamic Updates**: Modifiable authority set\n- **Role Validation**: Authority verification\n- **Permission Control**: Access management\n\n### 2. Message Processing\n- **User Messages**: Direct pass-through\n- **Authority Messages**: Validation required\n- **Commitment Collection**: Distributed gathering\n- **Validation Rules**: Configurable checks\n- **Error Handling**: Detailed responses\n\n### 3. Consensus Features\n- **Distributed Validation**: Multi-node verification\n- **Quorum Enforcement**: Minimum approval count\n- **Parallel Processing**: Concurrent commitment collection\n- **State Management**: Consistent tracking\n- **Result Bundling**: Organized outputs\n\n## Usage Examples\n\n### 1. Device Configuration\n```erlang\n% Configure PoDA device\nConfig = #{\n    <<\"authority\">> => <<\"addr1\">>,\n    <<\"authority\">> => <<\"addr2\">>,\n    <<\"authority\">> => <<\"addr3\">>,\n    <<\"quorum\">> => <<\"2\">>\n},\n{ok, State} = dev_poda:init(#{}, Config).\n```\n\n### 2. Message Validation\n```erlang\n% Process message with commitments\nMessage = #{\n    <<\"body\">> => Content,\n    <<\"commitments\">> => #{\n        <<\"1\">> => Commitment1,\n        <<\"2\">> => Commitment2\n    }\n},\n{ok, NewState} = dev_poda:execute(Message, State, Opts).\n```\n\n### 3. Commitment Addition\n```erlang\n% Add commitments to results\nItem = #{\n    <<\"target\">> => ProcessId,\n    <<\"data\">> => Content\n},\n{ok, UpdatedState} = dev_poda:push(Item, State).\n```\n\n## Error Handling\n\n### 1. Validation Errors\n- Missing commitments\n- Invalid signatures\n- Insufficient quorum\n- Authority mismatch\n- Format issues\n\n### 2. Processing Errors\n- Message format invalid\n- Commitment collection failed\n- Authority unreachable\n- State inconsistency\n- Timeout issues\n\n### 3. System Errors\n- Configuration problems\n- Network failures\n- Resource exhaustion\n- State corruption\n- Protocol violations\n\n## Future Considerations\n\n### 1. Consensus\n- Dynamic quorum adjustment\n- Authority rotation\n- Weight-based voting\n- Timeout management\n- Fork resolution\n\n### 2. Performance\n- Commitment caching\n- Parallel validation\n- Network optimization\n- State compression\n- Resource management\n\n### 3. Security\n- Authority verification\n- Message integrity\n- Replay protection\n- Access control\n- Audit support\n"},"devices/security_access/modules/dev_simple_pay.md":{"content":"# Module: dev_simple_pay\n\n## Basic Information\n- **Source File:** dev_simple_pay.erl\n- **Module Type:** Pricing & Ledger Device\n- **Purpose:** Implements a simple per-message payment system with built-in ledger functionality.\n\n## Core Functionality\n\n### 1. Payment Architecture\n```mermaid\ngraph TD\n    A[Request] --> B[Type Check]\n    B --> C{Request Type}\n    C -->|Pre-request| D[Cost Estimation]\n    C -->|Post-request| E[Free Pass]\n    \n    D --> F{Operator Check}\n    F -->|Is Operator| G[Free Pass]\n    F -->|Not Operator| H[Calculate Cost]\n    \n    H --> I[Message Count]\n    I --> J[Apply Price]\n    \n    E --> K[Return Cost: 0]\n    G --> K\n    J --> L[Return Final Cost]\n```\n\n### 2. Ledger Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant SimplePay\n    participant Ledger\n    \n    Client->>SimplePay: Request Operation\n    SimplePay->>SimplePay: Check Request Type\n    \n    alt Pre-request\n        SimplePay->>SimplePay: Extract Signer\n        SimplePay->>Ledger: Get Balance\n        \n        alt Sufficient Balance\n            SimplePay->>Ledger: Deduct Cost\n            SimplePay-->>Client: Approve\n        else Insufficient Balance\n            SimplePay-->>Client: Reject\n        end\n    else Post-request\n        SimplePay-->>Client: Auto-approve\n    end\n```\n\n## Implementation Details\n\n### 1. Pricing API\n```erlang\n% Cost estimation based on message count and type\nestimate(_, EstimateReq, NodeMsg) ->\n    Req = hb_ao:get(<<\"request\">>, EstimateReq, NodeMsg),\n    ReqType = hb_ao:get(<<\"type\">>, EstimateReq, undefined, NodeMsg),\n    \n    case {is_operator(Req, NodeMsg), ReqType} of\n        {true, _} -> {ok, 0};  % Operator requests are free\n        {_, <<\"post\">>} -> {ok, 0};  % Post-processing is free\n        {_, <<\"pre\">>} ->\n            % Calculate cost based on message count\n            Messages = hb_ao:get(<<\"body\">>, EstimateReq, NodeMsg),\n            Price = hb_opts:get(simple_pay_price, 1, NodeMsg),\n            {ok, length(Messages) * Price}\n    end.\n```\n\n### 2. Ledger API\n```erlang\n% Balance deduction during preprocessing\ndebit(_, RawReq, NodeMsg) ->\n    case hb_ao:get(<<\"type\">>, RawReq, undefined, NodeMsg) of\n        <<\"post\">> -> \n            {ok, true};  % Post-processing always succeeds\n        <<\"pre\">> ->\n            Req = hb_ao:get(<<\"request\">>, RawReq, NodeMsg),\n            case hb_message:signers(Req) of\n                [] -> \n                    {ok, false};  % Unsigned requests fail\n                [Signer] ->\n                    % Check and update balance\n                    UserBalance = get_balance(Signer, NodeMsg),\n                    Price = hb_ao:get(<<\"amount\">>, RawReq, 0, NodeMsg),\n                    case UserBalance >= Price of\n                        true ->\n                            set_balance(Signer, UserBalance - Price, NodeMsg),\n                            {ok, true};\n                        false ->\n                            {ok, false}\n                    end\n            end\n    end.\n```\n\n### 3. Balance Management\n```erlang\n% Balance retrieval with normalization\nget_balance(Signer, NodeMsg) ->\n    NormSigner = hb_util:human_id(Signer),\n    Ledger = hb_opts:get(simple_pay_ledger, #{}, NodeMsg),\n    hb_ao:get(NormSigner, Ledger, 0, NodeMsg).\n\n% Balance update with event logging\nset_balance(Signer, Amount, NodeMsg) ->\n    NormSigner = hb_util:human_id(Signer),\n    Ledger = hb_opts:get(simple_pay_ledger, #{}, NodeMsg),\n    \n    % Update ledger with new balance\n    NewMsg = NodeMsg#{\n        simple_pay_ledger =>\n            hb_ao:set(Ledger, NormSigner, Amount, NodeMsg)\n    },\n    hb_http_server:set_opts(NewMsg),\n    {ok, NewMsg}.\n```\n\n## Key Features\n\n### 1. Payment System\n- **Per-message Pricing**: Cost based on message count\n- **Configurable Rate**: Adjustable per-message price\n- **Operator Exemption**: Free access for node operator\n- **Pre/Post Handling**: Charges only during pre-processing\n- **Balance Validation**: Ensures sufficient funds before processing\n\n### 2. Ledger Management\n- **Built-in Ledger**: Integrated balance tracking\n- **Address Normalization**: Consistent wallet ID handling\n- **Default Balances**: Zero balance for new users\n- **Atomic Updates**: Safe balance modifications\n- **Event Logging**: Comprehensive transaction tracking\n\n### 3. Integration\n- **P4 Compatible**: Implements pricing and ledger APIs\n- **HTTP Integration**: Works with HTTP server infrastructure\n- **Message System**: Integrates with message handling\n- **Node Configuration**: Uses node options for settings\n- **Event System**: Uses standard event logging\n\n## Usage Examples\n\n### 1. Node Configuration\n```erlang\n% Configure node with simple-pay\nNodeOpts = #{\n    simple_pay_price => 10,  % Cost per message\n    simple_pay_ledger => #{  % Initial balances\n        <<\"user1\">> => 1000,\n        <<\"user2\">> => 500\n    },\n    operator => OperatorAddress\n}.\n```\n\n### 2. Balance Operations\n```erlang\n% Check balance\nBalanceReq = #{\n    <<\"path\">> => <<\"/~simple-pay@1.0/balance\">>\n},\n{ok, Balance} = hb_http:get(Node, SignedBalanceReq, #{}).\n\n% Top up balance\nTopupReq = #{\n    <<\"path\">> => <<\"/~simple-pay@1.0/topup\">>,\n    <<\"amount\">> => 100,\n    <<\"recipient\">> => UserAddress\n},\n{ok, NewBalance} = hb_http:post(Node, SignedTopupReq, #{}).\n```\n\n### 3. Request Processing\n```erlang\n% Process request with payment\nProcessReq = #{\n    <<\"type\">> => <<\"pre\">>,\n    <<\"body\">> => Messages,\n    <<\"amount\">> => Cost\n},\n{ok, Result} = hb_http:post(Node, SignedProcessReq, #{}).\n```\n\n## Error Handling\n\n### 1. Payment Errors\n- Insufficient balance\n- Invalid request type\n- Missing signatures\n- Price calculation issues\n- Configuration problems\n\n### 2. Ledger Errors\n- Balance update failures\n- Ledger corruption\n- State inconsistencies\n- Normalization issues\n- Storage problems\n\n### 3. Integration Errors\n- API mismatches\n- Configuration issues\n- Message errors\n- State corruption\n- System failures\n\n## Future Considerations\n\n### 1. Payment System\n- Variable pricing\n- Bulk discounts\n- Subscription model\n- Payment plans\n- Cost optimization\n\n### 2. Ledger System\n- Persistent storage\n- Transaction history\n- Balance limits\n- Account types\n- Audit support\n\n### 3. Integration\n- Better monitoring\n- Enhanced logging\n- Analytics support\n- Reporting tools\n- Admin interface\n"}}