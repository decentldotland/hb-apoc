{"Cross-subsystem Integrations/07_cross_subsystem_security_model_analysis.md":{"content":"# Cross-Subsystem Security Model\n\n## Overview\n\nThe Cross-Subsystem Security Model in HyperBEAM is a comprehensive framework that ensures security guarantees are maintained as data and operations traverse subsystem boundaries. This analysis examines how security properties such as authentication, authorization, integrity, confidentiality, and non-repudiation are preserved across subsystem transitions, focusing on the mechanisms, patterns, and architectural approaches that enable end-to-end security.\n\nHyperBEAM's architecture implements security as a cross-cutting concern that spans all subsystems, requiring careful design to maintain security guarantees as operations cross subsystem boundaries. The system addresses this challenge through attestation chains, cryptographic verification, explicit trust boundaries, and consistent security policy enforcement.\n\nUnderstanding the Cross-Subsystem Security Model reveals critical aspects of HyperBEAM's overall security architecture, illuminating how the system maintains a consistent security posture despite the diversity and complexity of its subsystems.\n\n## Security Properties Across Boundaries\n\nSeveral key security properties must be maintained across subsystem boundaries:\n\n### 1. Authentication\n\nAuthentication guarantees must cross boundaries:\n\n- **Identity Preservation**: Entity identities must be preserved across boundaries\n- **Credential Transfer**: Authentication credentials must transfer appropriately\n- **Authentication Context**: Authentication context must propagate with operations\n- **Re-authentication Points**: Points where re-authentication occurs must be defined\n- **Multi-Factor Integration**: Multiple authentication factors must be coordinated\n\n### 2. Authorization\n\nAuthorization controls must span boundaries:\n\n- **Permission Propagation**: Permissions must propagate with operations\n- **Authority Delegation**: Authority must be delegated across boundaries\n- **Principle of Least Privilege**: Minimal necessary privileges must be maintained\n- **Context-Based Access**: Access based on context must be consistent\n- **Capability Transfer**: Security capabilities must transfer appropriately\n\n### 3. Integrity\n\nIntegrity guarantees must be preserved:\n\n- **Data Integrity**: Data must maintain integrity across transformations\n- **Control Integrity**: Control flows must maintain integrity\n- **Cryptographic Chaining**: Cryptographic proofs must maintain continuity\n- **Verification Points**: Verification must occur at boundary crossings\n- **Tamper Evidence**: Evidence of tampering must be detectable\n\n### 4. Confidentiality\n\nConfidentiality must be maintained:\n\n- **Data Protection**: Protected data must remain protected\n- **Encryption Boundaries**: Encryption state must be managed at boundaries\n- **Information Flow Control**: Information flows must be controlled\n- **Need-to-Know Enforcement**: Need-to-know principles must be enforced\n- **Containment Boundaries**: Sensitive data must be contained appropriately\n\n### 5. Non-repudiation\n\nNon-repudiation must extend across boundaries:\n\n- **Evidence Preservation**: Evidence of actions must be preserved\n- **Signature Chaining**: Digital signatures must be chained appropriately\n- **Audit Continuity**: Audit trails must maintain continuity\n- **Attribution Preservation**: Attribution must be preserved\n- **Witness Mechanisms**: Witnessing of operations must be maintained\n\n## Security Boundary Types\n\nHyperBEAM implements several types of security boundaries:\n\n### 1. Trust Domain Boundaries\n\nBoundaries between different trust domains:\n\n- **Green Zone Boundary**: Boundary between trusted Green Zone nodes and others\n- **External API Boundary**: Boundary between external clients and internal systems\n- **Third-Party Integration Boundary**: Boundary with external services\n- **Untrusted Code Boundary**: Boundary around WebAssembly execution\n- **Hardware Trust Boundary**: Boundary between hardware and software trust\n\n### 2. Privilege Boundaries\n\nBoundaries between different privilege levels:\n\n- **Administrator/User Boundary**: Boundary between admin and user operations\n- **Device Privilege Boundary**: Boundary between device privilege levels\n- **Attestation Level Boundary**: Boundary between attestation requirement levels\n- **Resource Access Boundary**: Boundary between resource access levels\n- **Payment Tier Boundary**: Boundary between different payment/subscription tiers\n\n### 3. Subsystem Boundaries\n\nBoundaries between functional subsystems:\n\n- **Storage/Processing Boundary**: Boundary between storage and processing\n- **Network/Application Boundary**: Boundary between network and application\n- **Blockchain/Local Boundary**: Boundary between blockchain and local systems\n- **Device/Framework Boundary**: Boundary between devices and framework\n- **Security/Application Boundary**: Boundary between security and application logic\n\n### 4. Component Boundaries\n\nBoundaries between individual components:\n\n- **Module Interface Boundary**: Boundary at module interfaces\n- **Process Boundary**: Boundary between Erlang processes\n- **Message Boundary**: Boundary at message exchanges\n- **API Contract Boundary**: Boundary at API contracts\n- **Protocol Boundary**: Boundary at protocol transitions\n\n## Security Transition Mechanisms\n\nSeveral mechanisms ensure security in cross-boundary transitions:\n\n### 1. Attestation Chain Mechanism\n\nAttestation chains preserve security across boundaries:\n\n```erlang\n% Example based on attestation chain propagation\nprocess_with_attestation_chain(Message, Device, Opts) ->\n    % Verify existing attestation chain\n    case verify_attestation_chain(Message, Opts) of\n        {ok, VerifiedMessage} ->\n            % Process with device\n            case hb_converge:resolve(VerifiedMessage, {as, Device, {}}, Opts) of\n                {ok, Result} ->\n                    % Extend attestation chain to result\n                    {ok, extend_attestation_chain(Result, VerifiedMessage, Opts)};\n                {error, Error} ->\n                    {error, Error}\n            end;\n        {error, Error} ->\n            {error, {attestation_verification_failed, Error}}\n    end.\n\nextend_attestation_chain(Result, InputMessage, Opts) ->\n    % Get existing chain\n    Chain = hb_converge:get(InputMessage, [<<\"attestation\">>, <<\"chain\">>], [], Opts),\n    \n    % Create new attestation entry\n    NewEntry = create_attestation_entry(InputMessage, Result, Opts),\n    \n    % Add to chain\n    NewChain = [NewEntry | Chain],\n    \n    % Add chain to result\n    hb_converge:set(Result, [<<\"attestation\">>, <<\"chain\">>], NewChain, Opts).\n```\n\nThis mechanism provides:\n- **Continuous Attestation**: Maintaining attestation through processing chains\n- **Cryptographic Binding**: Binding each step to its predecessors\n- **Verification Points**: Allowing verification at boundary crossings\n- **Provenance Tracking**: Tracking the origin and processing history\n- **Trust Transfer**: Transferring trust from inputs to outputs\n\n### 2. Security Context Propagation\n\nSecurity context propagates across boundaries:\n\n```erlang\n% Example based on security context propagation\npropagate_security_context(Message, Context, Opts) ->\n    % Extract security attributes from context\n    Principal = maps:get(principal, Context, undefined),\n    Permissions = maps:get(permissions, Context, []),\n    AuthLevel = maps:get(auth_level, Context, <<\"none\">>),\n    TrustChain = maps:get(trust_chain, Context, []),\n    \n    % Add security context to message\n    SecurityContext = #{\n        <<\"principal\">> => Principal,\n        <<\"permissions\">> => Permissions,\n        <<\"auth_level\">> => AuthLevel,\n        <<\"trust_chain\">> => TrustChain,\n        <<\"timestamp\">> => os:system_time(millisecond)\n    },\n    \n    % Add security information to message\n    hb_converge:set(Message, [<<\"security_context\">>], SecurityContext, Opts).\n```\n\nThis mechanism enables:\n- **Context Transfer**: Transferring security context across boundaries\n- **Implicit Authentication**: Carrying authentication information\n- **Authorization Carriage**: Carrying authorization information\n- **Trust Level Indication**: Indicating trust level\n- **Security Metadata**: Providing security-related metadata\n\n### 3. Cryptographic Envelopes\n\nCryptographic envelopes secure cross-boundary transitions:\n\n```erlang\n% Example based on cryptographic envelope creation\ncreate_secure_envelope(Message, Recipient, Opts) ->\n    % Extract message content\n    Content = hb_converge:get(Message, <<\"content\">>, Opts),\n    \n    % Get recipient's public key\n    case get_recipient_public_key(Recipient, Opts) of\n        {ok, PublicKey} ->\n            % Generate random symmetric key\n            SymmetricKey = crypto:strong_rand_bytes(32),\n            \n            % Encrypt content with symmetric key\n            EncryptedContent = encrypt_symmetric(Content, SymmetricKey, Opts),\n            \n            % Encrypt symmetric key with recipient's public key\n            EncryptedKey = encrypt_asymmetric(SymmetricKey, PublicKey, Opts),\n            \n            % Create envelope\n            Envelope = #{\n                <<\"encrypted_content\">> => EncryptedContent,\n                <<\"encrypted_key\">> => EncryptedKey,\n                <<\"recipient\">> => Recipient,\n                <<\"timestamp\">> => os:system_time(millisecond),\n                <<\"format\">> => <<\"AES-256-GCM+RSA\">>\n            },\n            \n            % Sign the envelope\n            {ok, sign_envelope(Envelope, Opts)};\n        {error, Error} ->\n            {error, {recipient_key_error, Error}}\n    end.\n```\n\nThis mechanism provides:\n- **End-to-End Encryption**: Protecting data across boundaries\n- **Targeted Protection**: Protecting data for specific recipients\n- **Integrity Protection**: Ensuring data integrity\n- **Authentication**: Authenticating the sender\n- **Non-repudiation**: Preventing sender repudiation\n\n### 4. Policy Enforcement Points\n\nPolicy enforcement points secure boundary crossings:\n\n```erlang\n% Example based on policy enforcement at boundaries\nenforce_boundary_policy(Message, BoundaryType, Direction, Opts) ->\n    % Get applicable policies for this boundary\n    Policies = get_boundary_policies(BoundaryType, Direction, Opts),\n    \n    % Evaluate message against all policies\n    EvaluationResults = lists:map(\n        fun(Policy) -> evaluate_policy(Message, Policy, Opts) end,\n        Policies\n    ),\n    \n    % Check if any policy denied the message\n    case lists:any(\n        fun({Decision, _}) -> Decision =:= deny end,\n        EvaluationResults\n    ) of\n        true ->\n            % Get first denial reason\n            {_, DenyReason} = lists:keyfind(deny, 1, EvaluationResults),\n            {error, {policy_violation, DenyReason}};\n        false ->\n            % All policies passed, apply any transformations\n            TransformedMessage = apply_policy_transformations(Message, EvaluationResults, Opts),\n            {ok, TransformedMessage}\n    end.\n```\n\nThis mechanism enables:\n- **Boundary Guarding**: Controlling what crosses boundaries\n- **Policy Evaluation**: Evaluating policies at boundaries\n- **Transformation Application**: Applying required transformations\n- **Decision Enforcement**: Enforcing access decisions\n- **Audit Recording**: Recording policy decisions\n\n## Security Patterns for Boundary Crossing\n\nSeveral patterns ensure security across boundaries:\n\n### 1. Cryptographic Re-Attestation Pattern\n\nThis pattern re-attests data at boundary crossings:\n\n```\nOriginal Attestation → Boundary Crossing →\nVerification → Data Extraction → Transformation →\nNew Attestation → Attested Result\n```\n\nKey aspects of this pattern:\n- **Attestation Verification**: Verifying incoming attestation\n- **Attestation Break**: Breaking the attestation chain\n- **Data Transformation**: Transforming data as needed\n- **Re-Attestation**: Creating new attestation for transformed data\n- **Chain Linking**: Linking to previous attestation\n\n### 2. Security Gateway Pattern\n\nThis pattern mediates between security domains:\n\n```\nSource Domain → Security Gateway → Protocol Conversion →\nSecurity Validation → Authorization →\nTransformation → Target Domain\n```\n\nKey aspects of this pattern:\n- **Domain Isolation**: Isolating security domains\n- **Protocol Adaptation**: Adapting between domain protocols\n- **Security Validation**: Validating security properties\n- **Transformation Mediation**: Mediating transformations\n- **Policy Enforcement**: Enforcing cross-domain policies\n\n### 3. Privilege Reduction Pattern\n\nThis pattern reduces privileges at boundaries:\n\n```\nHigh Privilege Context → Boundary Crossing →\nPrivilege Calculation → Capability Restriction →\nMinimal Privilege Assignment → Low Privilege Context\n```\n\nKey aspects of this pattern:\n- **Privilege Evaluation**: Evaluating required privileges\n- **Principle of Least Privilege**: Assigning minimal privileges\n- **Capability Restriction**: Restricting capabilities\n- **Context Transformation**: Transforming security context\n- **Permission Narrowing**: Narrowing permissions\n\n### 4. Trusted Intermediary Pattern\n\nThis pattern uses trusted components for transitions:\n\n```\nSource Component → Trusted Intermediary →\nValidation → Transformation → Attestation →\nTarget Component\n```\n\nKey aspects of this pattern:\n- **Trust Anchoring**: Anchoring trust in the intermediary\n- **Validation Logic**: Validating security properties\n- **Transformation Logic**: Performing trusted transformations\n- **Attestation Creation**: Creating attestation of transformation\n- **Trust Transfer**: Transferring trust to the result\n\n## Configuration Aspects\n\nCross-Subsystem Security can be configured in several ways:\n\n### 1. Boundary Configuration\n\nSecurity boundaries can be configured:\n\n```erlang\n% Example boundary configuration\nboundary_configuration() ->\n    #{\n        boundaries => [\n            {<<\"storage_processing\">>, #{\n                enforcement_level => strict,\n                required_attestation => true,\n                required_authorization => true,\n                audit_level => detailed\n            }},\n            {<<\"network_application\">>, #{\n                enforcement_level => moderate,\n                required_attestation => false,\n                required_authorization => true,\n                audit_level => basic\n            }}\n        ],\n        default_enforcement => moderate,\n        audit_storage => local,\n        policy_conflict_resolution => deny_overrides\n    }.\n```\n\nThis configuration controls:\n- **Boundary Definitions**: Defining security boundaries\n- **Enforcement Levels**: Setting enforcement strictness\n- **Security Requirements**: Setting security requirements\n- **Audit Settings**: Configuring boundary audit\n- **Default Behavior**: Setting default behavior\n\n### 2. Trust Configuration\n\nTrust relationships can be configured:\n\n```erlang\n% Example trust configuration\ntrust_configuration() ->\n    #{\n        trust_domains => [\n            {<<\"internal\">>, #{\n                trust_level => high,\n                authentication_requirement => strong,\n                attestation_requirement => hardware\n            }},\n            {<<\"partner\">>, #{\n                trust_level => medium,\n                authentication_requirement => two_factor,\n                attestation_requirement => software\n            }},\n            {<<\"public\">>, #{\n                trust_level => low,\n                authentication_requirement => basic,\n                attestation_requirement => none\n            }}\n        ],\n        cross_domain_rules => [\n            {<<\"internal\">>, <<\"partner\">>, #{\n                allowed_operations => [<<\"read\">>, <<\"limited_write\">>],\n                data_classification_limit => <<\"confidential\">>\n            }},\n            {<<\"partner\">>, <<\"public\">>, #{\n                allowed_operations => [<<\"read\">>],\n                data_classification_limit => <<\"public\">>\n            }}\n        ],\n        default_domain => <<\"public\">>,\n        unknown_domain_policy => deny\n    }.\n```\n\nThis configuration controls:\n- **Trust Domain Definitions**: Defining trust domains\n- **Trust Levels**: Setting trust levels\n- **Authentication Requirements**: Setting authentication requirements\n- **Cross-Domain Rules**: Defining rules between domains\n- **Default Policies**: Setting default policies\n\n### 3. Attestation Configuration\n\nAttestation behavior can be configured:\n\n```erlang\n% Example attestation configuration\nattestation_configuration() ->\n    #{\n        attestation_chains => #{\n            enabled => true,\n            max_chain_length => 10,\n            verification_depth => full,\n            signature_algorithm => <<\"ed25519\">>,\n            include_timestamps => true\n        },\n        attestation_requirements => [\n            {<<\"storage_operations\">>, #{\n                level => <<\"hardware\">>,\n                freshness_requirement => 3600,\n                required_attributes => [<<\"operation\">>, <<\"data_hash\">>]\n            }},\n            {<<\"payment_operations\">>, #{\n                level => <<\"hardware\">>,\n                freshness_requirement => 300,\n                required_attributes => [<<\"amount\">>, <<\"recipient\">>, <<\"timestamp\">>]\n            }}\n        ],\n        attestation_verification => #{\n            cache_results => true,\n            cache_ttl => 600,\n            lazy_verification => false\n        }\n    }.\n```\n\nThis configuration controls:\n- **Chain Management**: Managing attestation chains\n- **Attestation Requirements**: Setting operation requirements\n- **Verification Settings**: Configuring verification behavior\n- **Performance Settings**: Optimizing attestation performance\n- **Algorithm Selection**: Selecting attestation algorithms\n\n### 4. Audit Configuration\n\nAudit behavior can be configured:\n\n```erlang\n% Example audit configuration\naudit_configuration() ->\n    #{\n        cross_boundary_audit => #{\n            enabled => true,\n            detail_level => high,\n            include_data => false,\n            storage_location => <<\"both\">>,\n            retention_period => 90\n        },\n        audit_events => [\n            {<<\"authentication\">>, #{\n                record => true,\n                alert_on_failure => true,\n                include_context => true\n            }},\n            {<<\"authorization\">>, #{\n                record => true,\n                alert_on_failure => true,\n                include_context => true\n            }},\n            {<<\"data_access\">>, #{\n                record => true,\n                alert_on_failure => false,\n                include_context => false\n            }}\n        ],\n        audit_format => <<\"structured\">>,\n        audit_batching => #{\n            enabled => true,\n            max_batch_size => 100,\n            max_batch_interval => 60\n        }\n    }.\n```\n\nThis configuration controls:\n- **Boundary Audit**: Configuring boundary audit\n- **Event Selection**: Selecting events to audit\n- **Detail Settings**: Setting audit detail level\n- **Storage Settings**: Configuring audit storage\n- **Performance Settings**: Optimizing audit performance\n\n## Security Implications\n\nCross-Subsystem Security has several implications:\n\n### 1. Attack Surface Management\n\nSecurity model affects attack surface:\n\n- **Boundary Minimization**: Minimizing the number of boundaries\n- **Interface Narrowing**: Narrowing interfaces at boundaries\n- **Validation Depth**: Deep validation at boundaries\n- **Privilege Separation**: Separating privileges across boundaries\n- **Isolation Enforcement**: Enforcing isolation between components\n\n### 2. Trust Management\n\nTrust must be managed across boundaries:\n\n- **Trust Chains**: Building and maintaining chains of trust\n- **Trust Derivation**: Deriving trust from trusted sources\n- **Trust Verification**: Verifying trust at boundaries\n- **Trust Revocation**: Revoking trust when needed\n- **Trust Establishment**: Establishing trust between components\n\n### 3. Consistency of Protection\n\nProtection must be consistent:\n\n- **Protection Continuity**: Maintaining continuous protection\n- **Consistent Enforcement**: Enforcing policies consistently\n- **Security Level Matching**: Matching security levels across boundaries\n- **Gap Prevention**: Preventing security gaps at boundaries\n- **Overlapping Protections**: Creating overlapping protections\n\n### 4. Security Decomposition\n\nSecurity is decomposed across boundaries:\n\n- **Responsibility Allocation**: Allocating security responsibilities\n- **Control Distribution**: Distributing security controls\n- **Layered Defense**: Implementing layered defenses\n- **Coordinated Protection**: Coordinating protection mechanisms\n- **Defense in Depth**: Implementing defense in depth\n\n## Security Challenges\n\nCross-Subsystem Security poses several challenges:\n\n### 1. Security Composition\n\nComposing security across boundaries is challenging:\n\n- **Composition Correctness**: Ensuring correct security composition\n- **Emergent Properties**: Managing emergent security properties\n- **Interference Detection**: Detecting security mechanism interference\n- **Compatibility Assurance**: Ensuring security mechanism compatibility\n- **Complete Coverage**: Ensuring complete security coverage\n\n### 2. Security Abstraction Leakage\n\nSecurity abstractions may leak across boundaries:\n\n- **Abstraction Breaking**: Preventing abstraction breaking\n- **Implementation Exposure**: Preventing implementation exposure\n- **Model Consistency**: Maintaining consistent security model\n- **Abstraction Level Matching**: Matching abstraction levels\n- **Security Representation**: Managing security representation\n\n### 3. Security State Management\n\nSecurity state must be managed across boundaries:\n\n- **State Synchronization**: Synchronizing security state\n- **State Consistency**: Maintaining consistent security state\n- **State Transfer**: Transferring security state properly\n- **State Protection**: Protecting security state\n- **State Recovery**: Recovering from security state inconsistencies\n\n### 4. Security Tradeoffs\n\nSecurity involves tradeoffs across boundaries:\n\n- **Performance vs. Security**: Balancing performance and security\n- **Usability vs. Security**: Balancing usability and security\n- **Flexibility vs. Security**: Balancing flexibility and security\n- **Compatibility vs. Security**: Balancing compatibility and security\n- **Cost vs. Security**: Balancing cost and security\n\n## Examples\n\nLet's examine concrete examples of Cross-Subsystem Security from the codebase:\n\n### Attestation Chain Across Process and Storage\n\n```erlang\n% Example based on process/storage boundary crossing\nstore_process_result(ProcessResult, SourceMessage, Opts) ->\n    % Verify attestation chain from process\n    case verify_attestation_chain(ProcessResult, Opts) of\n        {ok, VerifiedResult} ->\n            % Extract data to store\n            StorableData = extract_storable_data(VerifiedResult, Opts),\n            \n            % Create storage message\n            StorageMessage = create_storage_message(StorableData, VerifiedResult, Opts),\n            \n            % Extend attestation chain\n            StorageMessageWithAttestation = extend_attestation_chain(\n                StorageMessage, \n                VerifiedResult,\n                <<\"process_to_storage\">>,\n                Opts\n            ),\n            \n            % Store with attestation\n            hb_converge:resolve(\n                StorageMessageWithAttestation,\n                {as, <<\"store@1.0\">>, #{<<\"action\">> => <<\"put\">>}},\n                Opts\n            );\n        {error, Error} ->\n            {error, {attestation_verification_failed, Error}}\n    end.\n\nextend_attestation_chain(Message, SourceMessage, BoundaryType, Opts) ->\n    % Get attestation chain from source\n    SourceChain = hb_converge:get(SourceMessage, [<<\"attestation\">>, <<\"chain\">>], [], Opts),\n    \n    % Create boundary crossing attestation\n    CrossingAttestation = create_boundary_crossing_attestation(\n        Message,\n        SourceMessage,\n        BoundaryType,\n        Opts\n    ),\n    \n    % Add to chain\n    NewChain = [CrossingAttestation | SourceChain],\n    \n    % Add chain to message\n    hb_converge:set(Message, [<<\"attestation\">>, <<\"chain\">>], NewChain, Opts).\n```\n\nThis example demonstrates:\n- **Chain Verification**: Verifying attestation before crossing\n- **Chain Extension**: Extending attestation across boundary\n- **Boundary Context**: Adding boundary context to attestation\n- **Data Extraction**: Extracting appropriate data for crossing\n- **Storage Integration**: Integrating with storage subsystem\n\n### Security Context Propagation in HTTP-to-Core\n\n```erlang\n% Example based on HTTP-to-Core boundary crossing\nprocess_authenticated_request(HttpRequest, AuthInfo, Opts) ->\n    % Convert HTTP request to internal message\n    case hb_http:message_from_request(HttpRequest, Opts) of\n        {ok, InternalMessage} ->\n            % Create security context from authentication\n            SecurityContext = create_security_context_from_auth(AuthInfo, Opts),\n            \n            % Add security context to message\n            MessageWithSecurity = add_security_context(InternalMessage, SecurityContext, Opts),\n            \n            % Process message with security context\n            case hb_converge:resolve(MessageWithSecurity, Opts) of\n                {ok, Result} ->\n                    % Convert result back to HTTP response\n                    hb_http:message_to_response(Result, 200, Opts);\n                {error, {security_error, Error}} ->\n                    % Security error\n                    create_security_error_response(Error, Opts);\n                {error, Error} ->\n                    % Other error\n                    create_error_response(Error, Opts)\n            end;\n        {error, Error} ->\n            % Conversion error\n            create_conversion_error_response(Error, Opts)\n    end.\n\ncreate_security_context_from_auth(AuthInfo, Opts) ->\n    % Extract authentication components\n    Principal = maps:get(principal, AuthInfo),\n    AuthMethod = maps:get(method, AuthInfo),\n    AuthLevel = maps:get(level, AuthInfo),\n    \n    % Lookup permissions for principal\n    Permissions = lookup_permissions(Principal, Opts),\n    \n    % Create security context\n    #{\n        <<\"principal\">> => Principal,\n        <<\"auth_method\">> => AuthMethod,\n        <<\"auth_level\">> => AuthLevel,\n        <<\"permissions\">> => Permissions,\n        <<\"source\">> => <<\"http_boundary\">>,\n        <<\"timestamp\">> => os:system_time(millisecond)\n    }.\n```\n\nThis example demonstrates:\n- **Context Creation**: Creating security context from authentication\n- **Context Propagation**: Propagating context across boundary\n- **Permission Resolution**: Resolving permissions for authenticated user\n- **Error Handling**: Handling security errors at boundary\n- **Protocol Adaptation**: Adapting between HTTP and internal protocols\n\n### Green Zone Trust Boundary Enforcement\n\n```erlang\n% Example based on Green Zone boundary enforcement\nsend_to_node(Message, TargetNode, Opts) ->\n    % Check if target is in the Green Zone\n    case is_node_in_green_zone(TargetNode, Opts) of\n        true ->\n            % Node is trusted, check message classification\n            case get_message_classification(Message, Opts) of\n                {ok, Classification} ->\n                    % Check if classification can be sent to Green Zone\n                    case can_send_classification_to_green_zone(Classification, Opts) of\n                        true ->\n                            % Send through Green Zone secure channel\n                            send_through_green_zone(Message, TargetNode, Opts);\n                        false ->\n                            % Classification too high for Green Zone\n                            {error, {classification_too_high_for_green_zone, Classification}}\n                    end;\n                {error, Error} ->\n                    % Cannot determine classification\n                    {error, {classification_error, Error}}\n            end;\n        false ->\n            % Node is not in Green Zone, check if external sending is allowed\n            case can_send_to_external_node(Message, TargetNode, Opts) of\n                true ->\n                    % Send through external channel with protections\n                    send_to_external_node(Message, TargetNode, Opts);\n                false ->\n                    % Cannot send to external node\n                    {error, {cannot_send_to_external_node, TargetNode}}\n            end\n    end.\n```\n\nThis example demonstrates:\n- **Trust Boundary Check**: Checking trust boundary membership\n- **Classification Control**: Controlling data by classification\n- **Channel Selection**: Selecting appropriate channel based on trust\n- **External Protection**: Adding protection for external transmission\n- **Policy Enforcement**: Enforcing transmission policy\n\n### WebAssembly Execution Sandbox Boundary\n\n```erlang\n% Example based on WebAssembly sandbox boundary\nexecute_in_wasm_sandbox(Message, Module, Opts) ->\n    % Extract code and data\n    Code = hb_converge:get(Message, [<<\"code\">>], undefined, Opts),\n    InputData = hb_converge:get(Message, [<<\"input\">>], #{}, Opts),\n    \n    % Verify code attestation if present\n    CodeAttestation = hb_converge:get(Message, [<<\"code_attestation\">>], undefined, Opts),\n    case verify_code_attestation(Code, CodeAttestation, Opts) of\n        {ok, verified} ->\n            % Prepare sandbox environment\n            SandboxOpts = prepare_sandbox_options(Message, Opts),\n            \n            % Convert input to JSON for WASM boundary crossing\n            case dev_json_iface:message_to_json(InputData, Opts) of\n                {ok, JsonInput} ->\n                    % Execute in isolated WASM environment\n                    case dev_wasm:execute_code(Module, Code, JsonInput, SandboxOpts) of\n                        {ok, JsonResult} ->\n                            % Convert result back across boundary\n                            case dev_json_iface:json_to_message(JsonResult, Opts) of\n                                {ok, ResultMessage} ->\n                                    % Add sandbox attestation\n                                    {ok, add_sandbox_attestation(ResultMessage, Code, InputData, Opts)};\n                                {error, Error} ->\n                                    {error, {result_conversion_error, Error}}\n                            end;\n                        {error, Error} ->\n                            {error, {wasm_execution_error, Error}}\n                    end;\n                {error, Error} ->\n                    {error, {input_conversion_error, Error}}\n            end;\n        {error, Error} ->\n            {error, {code_attestation_error, Error}}\n    end.\n```\n\nThis example demonstrates:\n- **Code Verification**: Verifying code before execution\n- **Sandbox Preparation**: Preparing isolated execution environment\n- **Format Adaptation**: Adapting data formats across boundary\n- **Resource Limitation**: Limiting resources in sandboxed execution\n- **Result Attestation**: Attesting execution results\n\n## Architectural Significance\n\nCross-Subsystem Security is architecturally significant for several reasons:\n\n### 1. Security Decomposition\n\nThe security model enables effective decomposition:\n\n- **Modular Security**: Security decomposed into modules\n- **Responsibility Allocation**: Clear allocation of security responsibilities\n- **Interface Contracts**: Clear security contracts between components\n- **Reusable Mechanisms**: Reusable security mechanisms\n- **Consistent Model**: Consistent security model across decomposition\n\n### 2. End-to-End Security\n\nThe security model enables end-to-end security:\n\n- **Continuous Protection**: Continuous protection across boundaries\n- **Property Preservation**: Preservation of security properties\n- **Chain of Trust**: Unbroken chain of trust\n- **Attestation Chaining**: Chained attestations across operations\n- **Cryptographic Continuity**: Continuous cryptographic protection\n\n### 3. Defense in Depth\n\nThe security model implements defense in depth:\n\n- **Multiple Layers**: Multiple security layers\n- **Diverse Mechanisms**: Diverse security mechanisms\n- **Progressive Protection**: Progressive protection through system\n- **Overlapping Controls**: Overlapping security controls\n- **Independent Verification**: Independent verification mechanisms\n\n### 4. Evolution Support\n\nThe security model supports evolution:\n\n- **Security Abstraction**: Security abstracted from implementation\n- **Standard Interfaces**: Standard security interfaces\n- **Pluggable Mechanisms**: Pluggable security mechanisms\n- **Configuration-Driven**: Configuration-driven security behavior\n- **Versioned Security**: Support for multiple security versions\n\n## Conclusion\n\nThe Cross-Subsystem Security Model in HyperBEAM represents a comprehensive approach to maintaining security guarantees across subsystem boundaries. By implementing attestation chains, security context propagation, cryptographic envelopes, and policy enforcement points, the system ensures that security properties such as authentication, authorization, integrity, confidentiality, and non-repudiation are preserved as operations traverse subsystem boundaries.\n\nThe security model reveals key architectural principles in HyperBEAM:\n\n1. **Security Continuity**: Continuous security across subsystem boundaries\n2. **Explicit Boundaries**: Well-defined and explicitly secured boundaries\n3. **Attestation Chains**: Cryptographic attestation chains for verification\n4. **Trust Architecture**: Clear trust relationships between components\n5. **Defense in Depth**: Multiple security layers throughout the system\n\nUnderstanding this security model is essential for working with HyperBEAM's security capabilities, diagnosing security issues that span subsystem boundaries, and extending the system with new security mechanisms. The sophisticated approach to cross-subsystem security demonstrates the elegant architectural foundation that enables HyperBEAM to function as a secure distributed computing platform.\n"}}